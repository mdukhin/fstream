; =============================================================================
; УК (основной файл)
; 
; created by du      :  2016-10-20
;   идеология (вкратце):
;   проекты (branches) и счета (accnts) из dbores.cfg
;   1) Контрагенты (в настройках)
;   2) Сотрудники  (в настройках)
;   3) Договора
;   4) Распоряжения
; =============================================================================

#opencfg <dbores.cfg>
#opencfg <bobmisc.cfg>
#opencfg <crbase.cfg>
#opencfg <uk_const.cfg>
;

SECPATH=abbrs::;ospcs::;4glgpf::;crbase::;uk_const::;dbores::;$CURCFG::;::;.

[]

;#include "$FSDIR/cfgs/lua_templ.cfg"

; -----------------------------------------------------------------------------
; Текущий пользователь
; -----------------------------------------------------------------------------
[UK_Init]
const char main_class=DB_Cfgcur
const char read_access=any
const char update_access=any
const char sections=$CURCFG::$CURSEC
const char fields=c_user,cfg_spc_code
long c_user=0
long cfg_spc_code=0

; -------------------------------------
; тут нельзя использовать, т.к. UK_REF_Settings завязан на выбранном текущем проекте
; -------------------------------------
;const char synonyms=\
;#{";"
;  _default_days_shift_minus[LONG] == @${CURCFG}::UK_REF_Settings{setting_param=$SETTING_PARAM_DAYS_SHIFT_MINUS}._value
;  _default_days_shift_plus[LONG]  == @${CURCFG}::UK_REF_Settings{setting_param=$SETTING_PARAM_DAYS_SHIFT_PLUS}._value
;  url_login[80]==@${CURCFG}::UK_REF_Settings{setting_type=$SETTINGTYPE_URL_LOGIN}.value_s
;  url_help[80]==@${CURCFG}::UK_REF_Settings{setting_type=$SETTINGTYPE_URL_HELP}.value_s
;#}

const char refs_x1=\
#{";"
  REF_DogKinds($CURCFG::UK_REF_DogKinds_RPT):@today(op_day)
#}

const char spc_codes=\
#{";"
  $spc_get_tunning_info (<@get_tunning_info ()>):#Pget_tunning_info_parms
#}

;> ------------------------------------------------
;> __get_tunning_info
;    получение аттрибутов объекта и сохранение их во внешней коллекции
;    для использования в Delphi
;> ------------------------------------------------
const char get_tunning_info_parms=\
#{";"
  ext_coll_name:Имя внешней коллекции#Tstring_t
#}

const char get_tunning_info=\
#{
  $LONG(_c_branch,_default_days_shift_plus)
    StdEnv.GetVarLong("BranchSelect.c_branch", "_c_branch");
    _default_days_shift_plus  = call("$CURCFG::cmds:get_setting_attr", $SETTING_PARAM_DAYS_SHIFT_PLUS,  @@_c_branch, "value_i");

  @ext_coll_name.RenewVarsFromColl(CURRENT.get_name());
#}


;> ----------------------------------------------------------------------------
;> __pipe_init
;> ----------------------------------------------------------------------------
const char pipe_init=\
#{
  $LONG(_today)
    _today = Otoday();
    StdEnv.GetVarLong("CurrUser.c_user", "c_user");


  $LONG(_default_days_shift_minus,_default_days_shift_plus)
    _default_days_shift_minus = call("$CURCFG::cmds:get_setting_attr", $SETTING_PARAM_DAYS_SHIFT_MINUS, $BRANCH_OUR, "value_i");
    _default_days_shift_plus  = call("$CURCFG::cmds:get_setting_attr", $SETTING_PARAM_DAYS_SHIFT_PLUS, $BRANCH_OUR, "value_i");


  call("$CURCFG::$CURSEC:_check_current_user_in_filter", @@c_user, @@_default_days_shift_minus, @@_default_days_shift_plus);
;  call("$CURCFG::$CURSEC:_refresh_current_user_in_filter", @@c_user, @@_default_days_shift_minus, @@_default_days_shift_plus);

  return(0);

; -------------------------------------
  SQL SELECT COUNT(*) into ?_cnt FROM $xirr_users WHERE c_user = ?c_user AND @_today BETWEEN open_day AND delete_day;
  
  (@@_cnt > 0)
    ? ExecutePipe("SQL SELECT c_branch into ?c_branch FROM $xirr_users" +
                  "    WHERE c_user = ?c_user AND @_today BETWEEN open_day AND delete_day;")
    : 0;

  StdEnv.SetVarLong( "c_branch", @@c_branch);  
  c_tmp_param = (@@_cnt > 0)
                      ? call("$CURCFG::$CURSEC:add_current_params")
                      : 0;

  (@@_cnt > 0) ? return(0) : 0;

; -------------------------------------
; вывод ошибки в случае незаведенного пользователя
; -------------------------------------
  $CHAR(_user_shname,_user_name)
  SQL SELECT shname, name into ?_user_shname, ?_user_name FROM users WHERE c_user = ?c_user;

  RaiseError(-1, "[@c_user] Пользователь <" + @@_user_name + "> с логином <" + @@_user_shname + "> " +
                 "не заведен в программе. Обратитесь в УРПО!", "");
#}

;> ----------------------------------------------------------------------------
;> __check_current_user_in_filter
;> ----------------------------------------------------------------------------
const char _check_current_user_in_filter_parms=_c_user,_default_days_shift_minus,_default_days_shift_plus
const char _check_current_user_in_filter=\
#{
  $LONG(_count_filter_for_orders)
  SQL
    select count(*) into ?_count_filter_for_orders
    from $uk_users_filter_for_orders
    where
      c_user = @c_user;

  (@@_count_filter_for_orders == 0)
      ? 0
      : return(0);

  _coll_insert  = Auth.obj_by_name("<null>", "DB_Coll");
    @_coll_insert.AssignVarLong("c_user",           @@_c_user);
    @_coll_insert.AssignVarLong("days_shift_minus", @@_default_days_shift_minus);
    @_coll_insert.AssignVarLong("days_shift_plus",  @@_default_days_shift_plus);
  $CURCFG::UK_Users_Filters_For_Orders.DoInsertForColl(@@_coll_insert);
  Auth.delete_obj_by_name(@@_coll_insert);
#}

;> ----------------------------------------------------------------------------
;> __refresh_current_user_in_filter
;> ----------------------------------------------------------------------------
const char _refresh_current_user_in_filter_parms=_c_user,_days_shift_minus,_days_shift_plus
const char _refresh_current_user_in_filter=\
#{
  _coll_update  = Auth.obj_by_name("<null>", "DB_Coll");
    @_coll_update.AssignVarLong("days_shift_minus", @@_days_shift_minus);
    @_coll_update.AssignVarLong("days_shift_plus", @@_days_shift_plus);
  $CURCFG::UK_Users_Filters_For_Orders.SetKeyLong("c_user", @@_c_user);
  $CURCFG::UK_Users_Filters_For_Orders.DoUpdateForColl(@@_coll_update);
  Auth.delete_obj_by_name(@@_coll_update);
#}


[UK_REF_DogKinds_RPT]
const char main_class=DB_Ksrpt
const char read_access=any
const char ks_keys=dog_kind
const char cursor_type=scroll
const char base_attrs=op_day
const char attrs=\
#{","
  dog_kind   int
  count_dogs int  default 0
  op_day     date
#}

const char foreigns=\
#{";"
  DogKind($CURCFG::UK_Abbrs_DogovorKinds):dog_kind(type)
#}

const char references=\
#{";"
  OrderTypes($CURCFG::UK_REF_DogKinds_OrderTypes):dog_kind
#}

const char pipe_subobj=\
#{
  SQL create unique index idx_@{_rpt_table}_0 on @_rpt_table (dog_kind);
  SQL
    insert into @_rpt_table (dog_kind)
      select a.type
      from $uk_ref_abbrs a
      where a.abbr matches 'DOG_KIND_*';
  SQL update statistics high for table @_rpt_table (dog_kind);

  SQL
    update @_rpt_table set (count_dogs) =
      ((
        select count(*)
        from $uk_dogovors_def d 
        where
          d.dog_kind = @_rpt_table.dog_kind and
          ?op_day between d.date0 and d.date1
      ));

#}

[1C_Accnts_Def]
const char main_class=DB_Kstat
const char read_access=any
const char insert_access=PLACE_ACCNT
const char update_access=PLACE_ACCNT
const char delete_access=PLACE_ACCNT
char cursor_type=scroll
const char mode=sidur
const char ks_table=$tmp_accnts_def
const char ks_keys=c_accnt_tmp
const char serial=c_accnt_tmp

const char foreigns=\
#{";"
  Curr:c_curr
  Accnt:c_accnt
  AccntCurr:c_accnt,c_curr
  Branch:c_branch
  MainType($CURCFG::UK_Abbrs_MainType):ndep(type)
  Depreciation($CURCFG::UK_Abbrs_DepreciationType):nukind(type)
  Contractor($CURCFG::UK_Contractors_Def):c_contractor
  Dogovor($CURCFG::UK_Dogovors_All):c_dogovor
#}

const char refs_x1=\
#{";"
  NPL(NPl_accnt2):naccnt
#}

;> ----------------------------------------------------------------------------
;> __spc_codes
;> ----------------------------------------------------------------------------
const char spc_codes=\
#{
  $spc_import_accnts_from_1C (<@import_accnts_from_1C (c_accnt_tmp,accnt_obj,
                                                       _c_accnt=AccntCurr.c_accnt,
                                                       _necurracc=AccntCurr.necurracc,
                                                       c_curr,
                                                       c_branch,oaccnt,
                                                       NPL.type,
                                                       naccnt,_c_naccnt=NPL.c_naccnt,
                                                       MainType.cfg_attr,Depreciation.cfg_attr,
                                                       debit1,credit1,access,name,c_contractor)>);
  $spc_refresh_accnts_on_contractor (<@refresh_accnts_on_contractor (c_accnt_tmp,_c_accnt=AccntCurr.c_accnt,c_contractor,NPL.type)>);
  $spc_create_dogovor_os_for_accnts_1C (<@create_dogovor_OS (c_accnt_tmp,_c_accnt_os=Accnt.c_accnt,c_contractor,date0,
                                                             Accnt.name, 
                                                             c_curr,c_branch,
                                                             _nsubacc=Accnt.nsubacc,_ndep=Accnt.ndep,_access=Accnt.access,_name=Accnt.name,
                                                             isum_main,depreciation_isum,depreciation_count,
                                                             _c_dogovor=c_dogovor)>);
  $spc_set_accnt_rest0 (<@set_accnt_rest0(_c_accnt=AccntCurr.c_accnt,c_curr,debit1)>);
#}


;> ----------------------------------------------------------------------------
;> __create_dogovor_OS
;> ----------------------------------------------------------------------------
const char create_dogovor_OS=\
#{
  (@@_c_dogovor == 0)
      ? 0
      : return(0);

  _coll_insert  = Auth.obj_by_name("<null>", "DB_Coll");

  $MONEY(_tax_nds,_isum_nds)
    _tax_nds  = call("$CURCFG::cmds:get_setting_attr", $SETTING_PARAM_TAX_NDS,  @@c_branch, "value_m");
    _isum_nds = @@isum_main - round(@@isum_main/(1 + @_tax_nds * 0.01), 2);

; -------------------------------------
; 1) создаем счет для амортизации (с тем же nsubacc)
; -------------------------------------
  $LONG(_c_accnt_depreciation,_c_naccnt_depreciation)
    _c_naccnt_depreciation = 532;
    _c_accnt_depreciation  = call("crbase::UserUtils:_insert_new_accnt", @@c_curr, @@c_branch, @@_c_naccnt_depreciation, 0, @@_ndep, 0, @@_nsubacc,
                                                                         @@_access, @@_name, "02", "02.01", "", 0, 0, "AccntNormal", @@_coll_insert);

; -------------------------------------
; 2) создаем договор ОС (с двумя счетами и остальными параметрами)
;      - дата начала
;      - c_contractor
;      - кол-во амортизаций
;      - сумма амортизаций
; -------------------------------------
  _coll_insert  = Auth.obj_by_name("<null>", "DB_Coll");
  @_coll_insert.ClearNames();
    @_coll_insert.AssignVarLong("c_branch",                             @@c_branch);
    @_coll_insert.AssignVarLong("dog_kind",                             $DOG_KIND_OS);
    @_coll_insert.AssignVarLong("c_contractor",                         @@c_contractor);
    @_coll_insert.AssignVarLong("date0",                                long(@@date0));
    @_coll_insert.AssignVarLong("date1",                                $DayMax);
    @_coll_insert.AssignVarString("comment",                            @@Accnt.name);
    @_coll_insert.AssignVarLong("Accnt_OS_Main.c_accnt",                @@_c_accnt_os);
    @_coll_insert.AssignVarLong("Accnt_OS_Depreciation.c_accnt",        @@_c_accnt_depreciation);
    @_coll_insert.AssignVarLong("Param_CountDepreciations.param_value", @@depreciation_count);
    @_coll_insert.SetVarMoney("ISum_Main.isum",                         @@isum_main);
    @_coll_insert.SetVarMoney("ISum_NDS.isum",                          @@_isum_nds);
    @_coll_insert.SetVarMoney("ISum_Depreciation.isum",                 @@depreciation_isum);
  $CURCFG::UK_Dogovors_All.DoInsertForColl(@@_coll_insert);
  $CURCFG::UK_Dogovors_All.GetKeyLong( "c_dogovor", "_c_dogovor");
  Auth.delete_obj_by_name(@@_coll_insert);

; -------------------------------------
; обновляем ссылку на только что созданный договор
; -------------------------------------
  _coll_update  = Auth.obj_by_name("<null>", "DB_Coll");
    @_coll_update.ClearNames();
    @_coll_update.AssignVarLong("c_dogovor", @@_c_dogovor);
  @THIS.DoUpdateForColl(@@_coll_update);
  Auth.delete_obj_by_name(@@_coll_update);
;  RaiseError(-1, "success!!!", "");
#}

;> ----------------------------------------------------------------------------
;> __set_accnt_rest0
;> ----------------------------------------------------------------------------
const char set_accnt_rest0=\
#{
  call("crbase::UserUtils:_set_accnt_rest0", @@_c_accnt, @@c_curr, @@debit1, @@debit1);
#}


;> ----------------------------------------------------------------------------
;> __import_accnts_from_1C
;> ----------------------------------------------------------------------------
const char import_accnts_from_1C=\
#{
  (@@_c_accnt == 0)
      ? 0
      : RaiseError(-1, "[@c_accnt_tmp] Счет из 1С уже обработан. Соответствующий счет в АБС - @_necurracc", "");

  $LONG(_nsymbf2,_nsubacc)
    _nsymbf2 = 0;
    _nsubacc = 0;
  $SHORT(_ndep,_nukind)
    _ndep    = @@MainType.cfg_attr;
    _nukind  = @@Depreciation.cfg_attr;

  $MONEY(_rest0,_rest0_rur)
    _rest0     = @@debit1 - @@credit1;
    _rest0_rur = @@_rest0;


  _coll_ext  = Auth.obj_by_name("<null>", "DB_Coll");

; -------------------------------------
; создание счета
; -------------------------------------
  _c_accnt = call("crbase::UserUtils:_insert_new_accnt", @@c_curr, @@c_branch, @@_c_naccnt, @@_nsymbf2, @@_ndep, @@_nukind, @@_nsubacc,
                                                         @@access, @@name, @@oaccnt, "", "", @@_rest0, @@_rest0_rur, @@accnt_obj, @@_coll_ext);

; -------------------------------------
; обновляем ссылку на реальный счет
; -------------------------------------
  _coll_update  = Auth.obj_by_name("<null>", "DB_Coll");
    @_coll_update.ClearNames();
    @_coll_update.AssignVarLong("c_accnt", @@_c_accnt);
  @THIS.DoUpdateForColl(@@_coll_update);
  Auth.delete_obj_by_name(@@_coll_update);

; -------------------------------------
; если есть информация о контрагенте - добавляем счет к нему 
; (в зависимости от а/п будет свой тип)
; -------------------------------------
  call("crbase::UserUtils:_refresh_accnt_on_contractor", @@_c_accnt, @@c_contractor, @@NPL.type);
#}

;> ----------------------------------------------------------------------------
;> __refresh_accnts_on_contractor
;> ----------------------------------------------------------------------------
const char refresh_accnts_on_contractor=\
#{
  (@@_c_accnt == 0)
      ? RaiseError(-1, "[@c_accnt_tmp] Счет еще не проимортирован в АБС ", "")
      : 0;

  call("crbase::UserUtils:_refresh_accnt_on_contractor", @@_c_accnt, @@c_contractor, @@NPL.type);
#}



; -----------------------------------------------------------------------------
; Все пользователи Юнибанка, которые не входят в филилал/фонд (входной параметр)
; (используется для добавления пользователей в филиал)
; -----------------------------------------------------------------------------
[UK_Users_Available_For_Branch]
const char main_class=DB_Ksrpt
const char ks_keys=c_user,c_branch
const char mode=sr
const char read_access=any
const char cursor_type=scroll
const char base_attrs=c_branch
const char attrs=\
#{","
  c_user   int
  c_branch int
#}

const char foreigns=\
#{";"
  Users:c_user
#}

const char pipe_subobj=\
#{
  $LONG(_today) _today = Otoday();

  SQL delete from @_rpt_table;
  SQL
    insert into @_rpt_table (c_user, c_branch)
      select distinct u.c_user, @c_branch
      from users u
      where
        @_today between u.open_day and u.delete_day
        and not exists (
                        select *
                        from $uk_users_branches x
                        where
                          x.c_branch = @c_branch and
                          x.c_user = u.c_user
                       );

  SQL create unique index idx_@{_rpt_table}_0 on @_rpt_table (c_user, c_branch);
  SQL update statistics high for table @_rpt_table (c_user, c_branch);
#}

;> ----------------------------------------------------------------------------
;> refs
;    настройки программы
;> ----------------------------------------------------------------------------

; -----------------------------------------------------------------------------
; параметры настройки 
;   c_branch: BRANCH_CONS - общие для всех
;                         - персонально для проекта
; -----------------------------------------------------------------------------
[UK_REF_Settings]
const char main_class=DB_Kstat
const char read_access=any
const char update_access=PLACE_UK_SETTINGS
const char insert_access=PLACE_UK_SETTINGS
const char delete_access=PLACE_UK_SETTINGS
const char mode=sidur
const char ks_table=$uk_ref_settings
const char ks_keys=setting_param,c_branch
const char history=change:prev_change/next_change
const char ks_where=$BRANCH_EXT_WHERE_OBJ
const char ks_defaults=\
#{";"
  setting_type:0
  setting_param:0
  c_branch:@BranchSelect.c_branch
  value_s:
  value_i:0
  value_m:0
  value_d:
  prev_change:@today
  next_change:$DayMax
#}

const char foreigns=\
#{";"
  Branch:c_branch
  BranchAll:c_branch
  Param($CURCFG::UK_Abbrs_SettingParams):setting_param(type)
  Type($CURCFG::UK_Abbrs_SettingTypes):setting_type(type)
#}

const char synonyms=\
#{";"
  _value[160]=?/setting_param,c_branch,Type.cfg_attr/call("$CURCFG::cmds:get_setting_attr", @setting_param, @c_branch, @Type.cfg_attr)
#}

; -----------------------------------------------------------------------------
; общие настроечные счета для проектов (ук/фонды)
; -----------------------------------------------------------------------------
[UK_REF_SettingsAccnts]
const char main_class=DB_Kstat
const char mode=sidur
const char read_access=any
const char update_access=PLACE_UK_SETTINGS
const char insert_access=PLACE_UK_SETTINGS
const char delete_access=PLACE_UK_SETTINGS
const char ks_table=$uk_ref_settings_accnts
const char ks_keys=accnt_type,c_branch
const char history=change:prev_change/next_change
const char ks_where=$BRANCH_WHERE_OBJ
const char query_defaults=\
#{";"
  prev_change:@today
  next_change:$DayMax
#}

const char ks_defaults=\
#{";"
  accnt_type:0
  c_branch:@BranchSelect.c_branch
  c_accnt:0
  c_curr:$CURR_ROUBLE
#}

const char foreigns=\
#{";"
  Branch:c_branch
  BranchAll:c_branch
  Type($CURCFG::UK_Abbrs_AccntSettingTypes):accnt_type(type)
  Accnt:c_accnt
  Curr:c_curr
  AccntCurr:c_accnt,c_curr
#}

const char pipe_pre_insert=\
#{
  (@@c_branch == $BRANCH_CONS)
      ? RaiseError(-1, "Проект 'ВСЕ' только для просмотра! Для него нельзя настроить счет!", "")
      : 0;
#}


; -----------------------------------------------------------------------------
;  набор типов распоряжений для видов договоров (справочник)
;   order_limit  - кол-во распоряжений текущего типа для для этого вида договоров 
;                  (0 - без ограничений)
;   cfg_spc_code - код spc-функции, который нужно выполнить над договором, чтобы создать распоряжение
; -----------------------------------------------------------------------------
[UK_REF_DogKinds_OrderTypes]
const char main_class=DB_Kstat
const char mode=sidur
const char read_access=any
const char update_access=PLACE_UK_SETTINGS
const char insert_access=PLACE_UK_SETTINGS
const char delete_access=PLACE_UK_SETTINGS
const char ks_table=$uk_ref_dogkinds_ordertypes
const char ks_keys=dog_kind,order_type,cfg_spc_code
const char ks_defaults=\
#{";"
  dog_kind:0
  order_type:0
  order_limit:0
  cfg_spc_code:0
#}

const char foreigns=\
#{";"
  DogKind($CURCFG::UK_Abbrs_DogovorKinds):dog_kind(type)
  OrderType($CURCFG::UK_Abbrs_OrderTypes):order_type(type)
  Operation($CURCFG::UK_Abbrs_Spc_OrdersCreate):cfg_spc_code(type)
#}


[UK_REF_DogKinds_OrderTypes_With_Restriction]
const char main_class=DB_Ksrpt
const char read_access=any
const char ks_keys=dog_kind,order_type,cfg_spc_code
const char cursor_type=scroll
const char base_attrs=dog_kind,c_contractor,c_employee
const char attrs=\
#{","
  order_type   int
;
  dog_kind     int
  cfg_spc_code int
; доп. параметры для ограничений (список, возможно, будет увеличиваться)
  c_contractor int
  c_employee   int
#}

const char foreigns=\
#{";"
  OrderType($CURCFG::UK_Abbrs_OrderTypes):order_type(type)
  Operation($CURCFG::UK_Abbrs_Spc_OrdersCreate):cfg_spc_code(type)
#}


const char pipe_subobj=\
#{
  SQL create unique index idx_@{_rpt_table}_0 on @_rpt_table (dog_kind, order_type, cfg_spc_code);

; -------------------------------------
; 1) все типы распоряжения, "доступные" для текущего вида договора (без ограничений)
; -------------------------------------
  SQL
    insert into @_rpt_table (order_type, dog_kind, cfg_spc_code, c_contractor, c_employee)
      select d.order_type, d.dog_kind, d.cfg_spc_code, @c_contractor, @c_employee
      from $uk_ref_dogkinds_ordertypes d
      where d.dog_kind = @dog_kind;
  SQL update statistics high for table @_rpt_table (dog_kind, order_type, cfg_spc_code);

; -------------------------------------
; 2) пытаемся для каждого типа вызвать соответствующий ему pipe с проверкой на ограничение
;    (если "да", то добавляем к списку)
; -------------------------------------
  $LONG(_order_type)
  $CHAR(_restriction_pipe_name)
  $CHAR(_restricted_order_types)
    _restricted_order_types = "0";

  CURSOR
    select t.order_type, nvl(a.cfg_attr, "") into ?_order_type, ?_restriction_pipe_name
    from @_rpt_table t
      join $uk_ref_abbrs a on a.type = t.order_type
    : call("$CURCFG::$CURSEC:_check_for_restriction", @@_order_type, @@_restriction_pipe_name, @@c_contractor, @@c_employee);
     

  SQL delete from @_rpt_table where order_type in (@_restricted_order_types);
  SQL update statistics high for table @_rpt_table (order_type);
#}

const char _check_for_restriction_parms=_order_type,_restriction_pipe_name,_c_contractor,_c_employee
const char _check_for_restriction=\
#{
  (@@_restriction_pipe_name == "")
      ? return(0)
      : 0;

  $LONG(_is_restrict)
  _is_restrict = call("$CURCFG::$CURSEC:@{_restriction_pipe_name}", @@_c_contractor, @@_c_employee);

; -------------------------------------
; если до этого момента не вышли - значит ограничение сработало => добавляем тип к списку 
; -------------------------------------
  joinstr(",", @@_restricted_order_types, string(@@_order_type));
#}


; -----------------------------------------------------------------------------
; схема проводок для типов распоряжений
;   !!! все аттрибуты типизированны !!!
;   !!! объектные аттрибуты хранятся в поле sabbr в подобъектах UK_Abbrs_...!!!

;   _comment = call("credit::Bank_Cmds:KernFormat", @@pattern, "|k:" + @@client_shname +
;                                    "|c:" + string(@@crid) +
;                                    "|o:" + string(@@c_order) +
;                                    "|d:" + rfmtdate(@@dog_date,"dd.mm.yyyy") +
;                                    "|p:" + rfmtdate(@@op_day,"dd.mm.yyyy")
;                                    );
;  Восстановление резерва по договору [#c] от [#d] с клиентом [#k] на основании распоряжения N[#o] от [#p]
; -----------------------------------------------------------------------------
[UK_REF_Schema]
const char main_class=DB_Kstat
const char read_access=any
const char update_access=PLACE_UK_SETTINGS
const char insert_access=PLACE_UK_SETTINGS
const char delete_access=PLACE_UK_SETTINGS
const char mode=sidur
const char ks_table=$uk_ref_schema
const char ks_keys=c_schema
const char history=change:prev_change/next_change
const char drop_condition=order_type;number;shname;isum_type;prov_type;accnt_type_d;accnt_type_c;comment_type;
const char query_defaults=\
#{";"
  prev_change:@today
  next_change:$DayMax
#}

const char ks_defaults=\
#{";"
  c_schema:0
  number:0
  order_type:0
  shname:
  isum_type:0
  accnt_type_d:0
  accnt_type_c:0
  prov_type:$SCHEMA_PROV_MEM
  comment_type:$SCHEMA_COMMENT_CUSTOM
#}

const char foreigns=\
#{";"
  OrderType($CURCFG::UK_Abbrs_OrderTypes):order_type(type)
  IsumType($CURCFG::UK_Abbrs_SchemaIsums):isum_type(type)
  ProvType($CURCFG::UK_Abbrs_SchemaProvs):prov_type(type)
  AccntType_D($CURCFG::UK_Abbrs_SchemaAccnts):accnt_type_d(type)
  AccntType_C($CURCFG::UK_Abbrs_SchemaAccnts):accnt_type_c(type)
  CommentType($CURCFG::UK_Abbrs_SchemaComments):comment_type(type)
#}

;--------------------------------------------------
; validate
char kernel_history=\
#{
  New:            VldAdd(pc_schema=0,
                         day1=prev_change,pday1=0,day2=next_change);
  Change:         VldAdd(pc_schema=OLD.c_schema,
                         day1=prev_change,pday1=0,day2=next_change);
  RollbackChange: VldAdd(pc_schema=c_schema,
                         day1=OLD.prev_change,pday1=0,day2=OLD.next_change);
  RollbackDelete: VldAdd(pc_schema=c_schema,
                         day1=OLD.next_change,pday1=1,day2=next_change);
#}
char VldAdd=\
#{
  return(0);

  day1=date(@@day1+@@pday1);

  KernCheckClientRange( @@day1, @@day2, @@c_schema );

; запрещаем изменять клиента
  (@@pc_schema == 0)
      ? 0
      : (@@pc_schema != @@c_schema)
        ? RaiseError( ${errop4gl:::ERR_ClientNoClientChange}, "", "" )
        : 0;
#}


const char pipe_pre_insert=\
#{
  IO.c_schema = long(@@order_type * 100 + @@number);
#}

const char pipe_pre_update=\
#{
  IO.c_schema = long(@@order_type * 100 + @@number);
#}


; -----------------------------------------------------------------------------
; распределение пользователей по филиалам
; -----------------------------------------------------------------------------
[UK_REF_UsersBranches]
const char main_class=DB_Kstat
const char read_access=any
const char mode=sr
const char ks_table=$uk_ref_users_branches
const char ks_keys=c_user,c_branch,delete_day
const char ks_defaults=\
#{";"
  c_user:0
  c_branch:@BranchSelect.c_branch
  user_mode:$USER_MODE_FULL
  open_day:@today
  delete_day:$DayMax
#}

const char foreigns=\
#{";"
  Users:c_user
  Branch:c_branch
  BranchAll:c_branch
#}

; -----------------------------------------------------------------------------
; расширение информации по видам амортизации
; -----------------------------------------------------------------------------
[UK_REF_Depreciations]
const char main_class=DB_Kstat
const char read_access=any
const char mode=sr
const char ks_table=$uk_ref_depreciations
const char ks_keys=type
const char ks_defaults=\
#{";"
  months_count:1
#}

; -----------------------------------------------------------------------------
; виды измерений номерклатур для "Запасов"
; -----------------------------------------------------------------------------
[UK_REF_Measures]
const char main_class=DB_Kstat
const char read_access=any
const char update_access=PLACE_UK_SETTINGS
const char insert_access=PLACE_UK_SETTINGS
const char delete_access=PLACE_UK_SETTINGS
const char mode=sidur
const char ks_table=$uk_ref_measures
const char ks_keys=c_measure
const char serial=c_measure
const char ks_defaults=\
#{";"
  code:0
  shname:
#}

const char synonyms=\
#{";"
  _name[20]=!([code]) [name]
#}


; -----------------------------------------------------------------------------
; справочник номенклатур "Запасов"
; -----------------------------------------------------------------------------
[UK_REF_Items]
const char main_class=DB_Kstat
const char read_access=any
const char update_access=PLACE_UK_SETTINGS
const char insert_access=PLACE_UK_SETTINGS
const char delete_access=PLACE_UK_SETTINGS
const char mode=sidur
const char ks_table=$uk_ref_items
const char ks_keys=c_item
const char serial=c_item
const char ks_defaults=\
#{";"
  c_measure:0
  c_item_group:0
  item_number:
  name:
#}

const char foreigns=\
#{";"
  ItemGroup($CURCFG::UK_REF_Item_Groups):c_item_group
  Measure($CURCFG::UK_REF_Measures):c_measure
#}

; -----------------------------------------------------------------------------
; группировки "Запасов"
; -----------------------------------------------------------------------------
[UK_REF_Item_Groups]
const char main_class=DB_Kstat
const char read_access=any
const char update_access=PLACE_UK_SETTINGS
const char insert_access=PLACE_UK_SETTINGS
const char delete_access=PLACE_UK_SETTINGS
const char mode=sidur
const char ks_table=$uk_ref_item_groups
const char ks_keys=c_item_group
const char serial=c_item_group
const char ks_defaults=\
#{";"
  c_accnt:0
  c_accnt_exp:0
  shname:
#}

const char foreigns=\
#{";"
  Accnt:c_accnt
  AccntExp(Accnt):c_accnt_exp(c_accnt)
#}


; -----------------------------------------------------------------------------
; виды атрибутов с оборотами
; -----------------------------------------------------------------------------
[UK_REF_TurnField_Kinds]
const char main_class=DB_Kstat
const char read_access=any
const char update_access=PLACE_NORIGHT
const char insert_access=PLACE_NORIGHT
const char delete_access=PLACE_NORIGHT
const char mode=sidur
const char ks_table=$uk_ref_turn_field_kinds
const char ks_keys=c_turn_field
const char serial=c_turn_field

const char ks_defaults=\
#{";"
  shname:
  turn_attr:
  order_sub_table:
  order_sub_param_field:
#}

const char synonyms=\
#{";"
  _full_info[160]=![shname] ([turn_attr])_[order_sub_table]:[order_sub_param_field]
#}


; -----------------------------------------------------------------------------
; правила для пересчета остатков и параметров
; (все будет в типизированных таблицах, т.к. это будет проще масштабировать и поддерживать)
;    entity_type          - вид сущности по которой пересчитываем параметр (employee|etc)
;    calc_param_type      - 
;    c_turn_field         -
;    order_type           -
;    order_sub_param_type -
; -----------------------------------------------------------------------------
[UK_REF_Rules_For_Recalc]
const char main_class=DB_Kstat
const char read_access=any
const char update_access=PLACE_NORIGHT
const char insert_access=PLACE_NORIGHT
const char delete_access=PLACE_NORIGHT
const char mode=sidur
const char ks_table=$uk_ref_calc_params_rules
const char ks_keys=c_rule_calc
const char serial=c_rule_calc
;const char ks_keys=entity_type,calc_param_type,period_kind,order_type,order_sub_param_type
const char ks_defaults=\
#{";"
  entity_type:0
  calc_param_type:0
  period_kind:0
  c_turn_field:0
  order_type:0
  order_sub_param_type:0
#}

const char foreigns=\
#{";"
  TurnFieldKind($CURCFG::UK_REF_TurnField_Kinds):c_turn_field
  CalcEntity($CURCFG::UK_Abbrs_CalcEntity):entity_type(type)
  PeriodKind($CURCFG::UK_Abbrs_Period_Kinds):period_kind(type)
  CalcParam($CURCFG::UK_Abbrs_CalcParams):calc_param_type(type)
  OrderType($CURCFG::UK_Abbrs_OrderTypes):order_type(type)
  OrderParam($CURCFG::UK_Abbrs_ParamTypes):order_sub_param_type(type)
#}


; -----------------------------------------------------------------------------
; правила для вычисления инициирующих сумм в псевдораспоряжениях
; -----------------------------------------------------------------------------
[UK_REF_Rules_For_ResetIsums]
const char main_class=DB_Kstat
const char read_access=any
const char update_access=PLACE_NORIGHT
const char insert_access=PLACE_NORIGHT
const char delete_access=PLACE_NORIGHT
const char mode=sidur
const char ks_table=$uk_ref_calc_resetisums_rules
const char ks_keys=c_rule_reset_isum
const char serial=c_rule_reset_isum
const char ks_defaults=\
#{";"
  resetisum_type:0
  order_type:0
  order_isum_type:0
#}

const char foreigns=\
#{";"
  OrderResetIsumType($CURCFG::UK_Abbrs_SchemaResetIsums):order_isum_type(type)
  OrderType($CURCFG::UK_Abbrs_OrderTypes):order_type(type)
  OrderIsumType($CURCFG::UK_Abbrs_SchemaIsums):order_isum_type(type)
#}

; -----------------------------------------------------------------------------
; правила для вычисления инициирующих параметров в псевдораспоряжениях
; -----------------------------------------------------------------------------
[UK_REF_Rules_For_ResetParams]
const char main_class=DB_Kstat
const char read_access=any
const char update_access=PLACE_NORIGHT
const char insert_access=PLACE_NORIGHT
const char delete_access=PLACE_NORIGHT
const char mode=sidur
const char ks_table=$uk_ref_calc_resetparams_rules
const char ks_keys=c_rule_reset_param
const char serial=c_rule_reset_param
const char ks_defaults=\
#{";"
  resetparam_type:0
  order_type:0
  order_param_type:0
#}

const char foreigns=\
#{";"
  OrderResetParamType($CURCFG::UK_Abbrs_ResetParamTypes):resetparam_type(type)
  OrderType($CURCFG::UK_Abbrs_OrderTypes):order_type(type)
  OrderParam($CURCFG::UK_Abbrs_ParamTypes):order_param_type(type)
#}



;> ============================================================================
;> imports
;> ============================================================================
[UK_Import_Def]
const char main_class=DB_Kstat
const char read_access=any
const char update_access=PLACE_UK_ORDERS
const char insert_access=PLACE_UK_ORDERS
const char delete_access=PLACE_UK_ORDERS
const char mode=sidur
const char ks_table=$uk_import_def
const char ks_keys=c_import
const char serial=c_import
const char ks_defaults=\
#{";"
  c_dogovor:0
  c_order:0
  import_type:$IMPORT_TYPE_STOCKS
  c_user:@CurrUser.c_user
  time_import:@@current
  file_name:
  op_day_1c:0
  op_day_to_contr:0
  number_1c:0
  count_items:0
  isum_total:0
#}

const char foreigns=\
#{";"
  Users:c_user
  Order($CURCFG::UK_Orders):c_order
#}

const char slave_refs=\
#{";"
  Data_Stocks($CURCFG::UK_Import_Data_Stocks):c_import
#}

const char synonyms=\
#{";"
  _year[LONG]=?/op_day_1c/long(rfmtdate(@op_day_1c, "yyyy"))
#}

const char spc_codes=\
#{";"
  $spc_ordercreate_stocks_purchase (<@_create_stocks_purchase (c_import,c_dogovor,_c_order=Order.c_order,_op_day=Order.op_day,isum_total,number_1c,op_day_1c,op_day_to_contr)>):#P_create_stocks_purchase_parms
;
  $spc_uk_orders_set_state_ENTERED       (<Order.$spc_uk_orders_set_state_ENTERED>)
  $spc_uk_orders_printed                 (<Order.$spc_uk_orders_printed>)
  $spc_uk_orders_performed_full          (<Order.$spc_uk_orders_performed_full>)
  $spc_uk_orders_performed_full_rollback (<Order.$spc_uk_orders_performed_full_rollback>)
  $spc_uk_orders_rollback                (<Order.$spc_uk_orders_rollback>)
  $spc_uk_orders_delete                  (<Order.$spc_uk_orders_delete>)
#}

;> ----------------------------------------------------------------------------
;> __pipe_pre_insert
;> ----------------------------------------------------------------------------
const char pipe_pre_insert=\
#{
  $LONG(_cnt)
  SQL select count(*) into ?_cnt from $uk_import_def where file_name = '@file_name';
  (@@_cnt == 0)
      ? 0
      : RaiseError(-1, "Файл с именем [" + @@file_name + "] уже был проимпортирован ранее!", "");
#}

;> ----------------------------------------------------------------------------
;> __pipe_pre_delete
;> ----------------------------------------------------------------------------
const char pipe_pre_delete=\
#{
  (@@Order.c_order == 0)
      ? 0
      : RaiseError(-1, "Данный 'импорт' уже был обработан! Удалите распоряжение N" + string(@@Order.c_order) + " от " + rfmtdate(@@Order.op_day, "dd.mm.yyyy"), "");
#}


;> ----------------------------------------------------------------------------
;> __create_stocks_purchase
;     _op_day_to_contr - дата проводки 
;     _comment         - 
;> ----------------------------------------------------------------------------
const char _create_stocks_purchase_parms=\
#{";"
  _op_day_to_contr:Дата проводки по р/с#Tdate_t
  _comment:Комментарий#Tstring_t
#}
const char _create_stocks_purchase=\
#{
  $LONG(_cnt)
; -------------------------------------
; 0. проверки
; -------------------------------------
  SQL
    select count(*) into ?_cnt
    from $uk_import_data_stocks
    where
      c_import = @c_import and
      nvl(item_number, '') = '';

  (@@_cnt == 0)
      ? 0
      : RaiseError(-1, "В списке номенклатур есть @_cnt элементов с пустым номером!", "");
; -------------------------------------
  SQL
    select count(*) into ?_cnt
    from $uk_import_data_stocks
    where
      c_import = @c_import and
      nvl(c_item, 0) = 0;

  (@@_cnt == 0)
      ? 0
      : RaiseError(-1, "В списке номенклатур есть @_cnt элементов, которых нет в справочнике номенклатур!", "");
; -------------------------------------
  SQL
    select count(*) into ?_cnt
    from $uk_import_data_stocks
    where
      c_import = @c_import and
      nvl(c_item_group, 0) = 0;

  (@@_cnt == 0)
      ? 0
      : RaiseError(-1, "В списке номенклатур есть @_cnt элементов, у которых не определена номерклатурная группа!", "");
; -------------------------------------
  (@@_c_order == 0)
      ? 0
      : RaiseError(-1, "Распоряжение по этому требованию-накладной уже было создано [@_c_order от " + rfmtdate(@@_op_day, "dd.mm.yyyy") + "] !", "");

; -------------------------------------
; 1.1 создаем распоряжение
; -------------------------------------
  _ext_coll = Auth.obj_by_name("<null>", "DB_Coll");
  _coll_params = Auth.obj_by_name("<null>", "DB_Coll");
    @_coll_params.AssignVarString("_ext_coll",    @@_ext_coll);
    @_coll_params.AssignVarDate  ("_op_day",      @@op_day_1c);
    @_coll_params.AssignVarString("_demand_bill", @@number_1c);
    @_coll_params.AssignVarString("_comment",     @@_comment);

  $CURCFG::UK_Dogovors_All.SetKeyLong("c_dogovor", @@c_dogovor);
  $CURCFG::UK_Dogovors_All.DoSpc($spc_ordercreate_stocks_purchase, @@_coll_params);

; id созданного распоряжения возвращается через внешнюю коллекцию
  $LONG(__c_order)
  @_ext_coll.SomeVarsToColl("__c_order", CURRENT.get_name(), "__c_order");
  
; -------------------------------------
; сохраняем c_order в текущей записи
; -------------------------------------
  _coll_upd=Auth.obj_by_name("<null>", "DB_Coll");
  CURRENT.SomeVarsToColl("__c_order", @@_coll_upd, "c_order");
  @THIS.DoUpdateForColl(@@_coll_upd);
  Auth.delete_obj_by_name(@@_coll_upd);


; -------------------------------------
  $LONG(_c_branch)
    StdEnv.GetVarLong("BranchSelect.c_branch", "_c_branch");

  $LONG(_c_item_group,_c_item,_quantity)
  $MONEY(_isum,_cost)


  $MONEY(_tax_nds,_isum_total_nds)
    _tax_nds        = call("$CURCFG::cmds:get_setting_attr", $SETTING_PARAM_TAX_NDS,  @@_c_branch, "value_m");
    _isum_total_nds = @@isum_total - round(@@isum_total / (1 + @_tax_nds * 0.01), 2);

; -------------------------------------
; 1.2 вставляем 3 общих суммы (нужны для контроля за возможной ошибкой округления)
; -------------------------------------
  call("$CURCFG::cmds_orders:add_isum_to_order", @@__c_order, 0, $SCHEMA_ISUM_STOCKS_PURCHASE_TOTAL,       @@isum_total,                      long(@@_op_day_to_contr));
  call("$CURCFG::cmds_orders:add_isum_to_order", @@__c_order, 0, $SCHEMA_ISUM_STOCKS_PURCHASE_TOTAL_NDS,   @@_isum_total_nds,                 0                       );
  call("$CURCFG::cmds_orders:add_isum_to_order", @@__c_order, 0, $SCHEMA_ISUM_STOCKS_PURCHASE_TOTAL_CLEAR, @@isum_total - @@_isum_total_nds,  0                       );

; -------------------------------------
; 1.3 вставляем все номенклатуры (для отчетности и т.д.)
; -------------------------------------
  CURSOR
    select c_item, cost, SUM(quantity), SUM(isum) into ?_c_item, ?_cost, ?_quantity, ?_isum
    from $uk_import_data_stocks
    where
      c_import = @c_import
    group by c_item, cost
  : call("$CURCFG::cmds_orders:add_item_to_order_sql", @@__c_order, @@_c_item, @@_quantity, @@_isum, @@_cost);

; -------------------------------------
; 1.4 принудительный пересчет всех сумм на основании номенклатур (т.к. номенклатуры вставляли не через объекты)
; -------------------------------------
  call("$CURCFG::UK_Orders_Items:_refresh_order_isums_by_items", @@__c_order);

; -------------------------------------
;  RaiseError(-1, "success", "");  
; -------------------------------------
#}

;> ----------------------------------------------------------------------------
;> __recalc_summary_attrs
;> ----------------------------------------------------------------------------
const char _recalc_summary_attrs_parms=_c_import
const char _recalc_summary_attrs=\
#{
  $LONG(_count_items)
  $MONEY(_isum_total)
    _count_items  = 0;
    _isum_total   = 0;

  SQL select count(*) into ?_count_items  from $uk_import_data_stocks where c_import = @_c_import;
  (@@_count_items == 0)
      ? 0
      : ExecutePipe("SQL select sum(isum) into ?_isum_total  from $uk_import_data_stocks where c_import = @_c_import;");

  
  _coll_import_def_update = Auth.obj_by_name("<null>", "DB_Coll");
    CURRENT.SomeVarsToColl("_count_items,_isum_total", @@_coll_import_def_update, "count_items,isum_total");
  $CURCFG::UK_Import_Def.SetKeyLong("c_import", @@_c_import);
  $CURCFG::UK_Import_Def.DoUpdateForColl(@@_coll_import_def_update);

  Auth.delete_obj_by_name(@@_coll_import_def_update);
#}


[UK_Import_Data_Stocks]
const char main_class=DB_Kstat
const char read_access=any
const char update_access=PLACE_UK_ORDERS
const char insert_access=PLACE_UK_ORDERS
const char delete_access=PLACE_UK_ORDERS
const char mode=sidur
const char ks_table=$uk_import_data_stocks
const char ks_keys=c_record
const char serial=c_record
const char ks_defaults=\
#{";"
  c_import:0
; -----------------
  name:
  item_number:
  measure_code:0
  measure_shname:
  quantity:0
  cost:0
  isum:0
; -----------------
  c_item:0
  c_measure:0
  c_item_group:0
#}

const char foreigns=\
#{";"
  Import($CURCFG::UK_Import_Def):c_import
  Measure($CURCFG::UK_REF_Measures):measure_code(code)
  Item($CURCFG::UK_REF_Items):c_item
#}

;> ----------------------------------------------------------------------------
;> __pipe_post_insert
;> ----------------------------------------------------------------------------
const char pipe_post_insert=\
#{
  call("$CURCFG::UK_Import_Def:_recalc_summary_attrs", @@c_import);
#}

;> ----------------------------------------------------------------------------
;> __pipe_post_update
;> ----------------------------------------------------------------------------
const char pipe_post_update=\
#{
  (@@Import.Order.c_order == 0)
      ? 0
      : RaiseError(-1, "Данный 'импорт' уже был обработан! Удалите распоряжение N" + string(@@Import.Order.c_order) + " от " + rfmtdate(@@Import.Order.op_day, "dd.mm.yyyy"), "");

  
  call("$CURCFG::UK_Import_Def:_recalc_summary_attrs", @@c_import);

; -------------------------------------
; меняем группу у номенклатурного элемента
; -------------------------------------
  _coll_update  = Auth.obj_by_name("<null>", "DB_Coll");
    @_coll_update.ClearNames();
    @_coll_update.AssignVarLong("c_item_group",     @@c_item_group);

  $CURCFG::UK_REF_Items.SetKeyLong("c_item", @@c_item);
  $CURCFG::UK_REF_Items.DoUpdateForColl(@@_coll_update);

  Auth.delete_obj_by_name(@@_coll_update);

; -------------------------------------
; обновляем все такие же номенклатры в проимпортированных списках
; -------------------------------------
  SQL update $uk_import_data_stocks set c_item_group = @c_item_group where c_item = @c_item and nvl(c_item_group, 0) = 0;
#}

;> ----------------------------------------------------------------------------
;> __pipe_pre_insert
;> ----------------------------------------------------------------------------
const char pipe_pre_insert=\
#{
  (@@Import.Order.c_order == 0)
      ? 0
      : RaiseError(-1, "Данный 'импорт' уже был обработан! Удалите распоряжение N" + string(@@Import.Order.c_order) + " от " + rfmtdate(@@Import.Order.op_day, "dd.mm.yyyy"), "");

  $LONG(_cnt)

; -------------------------------------
; 1) проверяем ед. измерения
; -------------------------------------
  $LONG(_c_measure)
    _c_measure = 0;
  SQL select count(*) into ?_cnt from $uk_ref_measures where code = @measure_code;
  (@@_cnt == 0)
      ? (_c_measure = call("$CURCFG::$CURSEC:_create_measure", @@measure_code, @@measure_shname))
      : ExecutePipe("SQL select c_measure into ?_c_measure from $uk_ref_measures where code = @measure_code;");
  IO.c_measure = @@_c_measure;


; -------------------------------------
; 2) проверяем номенклатурный номер + группу
; -------------------------------------
  $LONG(_c_item,_c_item_group)
    _c_item_group = 0;
  SQL select count(*) into ?_cnt from $uk_ref_items where item_number = '@item_number';
  (@@_cnt == 0)
      ? (_c_item = call("$CURCFG::$CURSEC:_create_item", @@item_number, @@name, @@_c_measure))
      : ExecutePipe("SQL select c_item, c_item_group into ?_c_item, ?_c_item_group from $uk_ref_items where item_number = '@item_number';");
  IO.c_item       = @@_c_item;
  IO.c_item_group = @@_c_item_group;
#}

;> ----------------------------------------------------------------------------
;> __create_measure
;> ----------------------------------------------------------------------------
const char _create_measure_parms=_code,_shname
const char _create_measure=\
#{
  $LONG(_c_measure_new)

  _coll_insert  = Auth.obj_by_name("<null>", "DB_Coll");
    @_coll_insert.ClearNames();
    @_coll_insert.AssignVarLong("code",     @@_code);
    @_coll_insert.AssignVarString("shname", @@_shname);
  $CURCFG::UK_REF_Measures.DoInsertForColl(@@_coll_insert);
  $CURCFG::UK_REF_Measures.GetKeyLong("c_measure", "_c_measure_new");

  Auth.delete_obj_by_name(@@_coll_insert);

  return(@@_c_measure_new);
#}

;> ----------------------------------------------------------------------------
;> __create_item
;> ----------------------------------------------------------------------------
const char _create_item_parms=_item_number,_name,_c_measure
const char _create_item=\
#{
  $LONG(_c_item_new)

  _coll_insert  = Auth.obj_by_name("<null>", "DB_Coll");
    @_coll_insert.ClearNames();
    @_coll_insert.AssignVarLong("c_measure",     @@_c_measure);
    @_coll_insert.AssignVarString("item_number", @@_item_number);
    @_coll_insert.AssignVarString("name",        @@_name);
  $CURCFG::UK_REF_Items.DoInsertForColl(@@_coll_insert);
  $CURCFG::UK_REF_Items.GetKeyLong("c_item", "_c_item_new");


  Auth.delete_obj_by_name(@@_coll_insert);

  return(@@_c_item_new);
#}


;> ============================================================================
;> accnts
;> ============================================================================
[AccntCurr_OPL]
const char main_class=DB_Kstat
const char read_access=any
const char update_access=PLACE_ACCNT
const char insert_access=PLACE_ACCNT
const char delete_access=PLACE_ACCNT
const char mode=sidur
const char ks_table=$uk_accnts_multi_opl
const char ks_keys=c_accnt,c_curr
const char ks_defaults=\
#{";"
  c_accnt:0
  c_curr:0
  c_branch:@BranchSelect.c_branch
  oaccnt:0
  necurracc:
  comment:
  rest0:0
  rest0_rur:0
#}




;> ============================================================================
;> contractors
;> ============================================================================
template [UK_Contractors_Tpl]
const char main_class=DB_Kstat
const char read_access=any
const char mode=sidur
const char insert_access=PLACE_UK_CONTRACTOR
const char update_access=PLACE_UK_CONTRACTOR
const char delete_access=PLACE_UK_CONTRACTOR
const char cursor_type=scroll


[UK_Contractors_Def] default: $CURCFG::UK_Contractors_Tpl
const char ks_table=$uk_contractors_def
const char ks_keys=c_contractor
const char serial=c_contractor
const char history=open:open_day/delete_day
const char ks_where=$BRANCH_WHERE_OBJ
const char ks_order=shname
const char query_defaults=\
#{";"
  open_day:@today
  delete_day:$DayMax
#}
const char ks_defaults=\
#{";"
  c_branch:@BranchSelect.c_branch
  shname:
  name:
  abbr:
  kind:$CONTRACTOR_KIND_GOODS
#}

; -----------------------------------------------
const char rfc_modifiers=\
#{";"
  Orders:d
  AccntA_Goods:d
  AccntP_Goods:d
  AccntA_Service:d
  AccntP_Service:d
  AccntA_Others:d
  AccntP_Others:d
#}

; -----------------------------------------------
const char synonyms=\
#{
  _accnt_contractor_a[LONG] = kind(
                                    $CONTRACTOR_KIND_GOODS:   AccntA_Goods.c_accnt,
                                    $CONTRACTOR_KIND_SERVICE: AccntA_Service.c_accnt,
                                    $CONTRACTOR_KIND_OTHERS:  AccntA_Others.c_accnt,
                                                              '$_FALSE'
                                  );
  _accnt_contractor_p[LONG] = kind(
                                    $CONTRACTOR_KIND_GOODS:   AccntP_Goods.c_accnt,
                                    $CONTRACTOR_KIND_SERVICE: AccntP_Service.c_accnt,
                                    $CONTRACTOR_KIND_OTHERS:  AccntP_Others.c_accnt,
                                                              '$_FALSE'
                                  );
  _ncurracc_a[20] = kind(
                                    $CONTRACTOR_KIND_GOODS:   AccntA_Goods.Accnt.ncurracc,
                                    $CONTRACTOR_KIND_SERVICE: AccntA_Service.Accnt.ncurracc,
                                    $CONTRACTOR_KIND_OTHERS:  AccntA_Others.Accnt.ncurracc,
                                                              ''
                        );
  _ncurracc_p[20] = kind(
                                    $CONTRACTOR_KIND_GOODS:   AccntP_Goods.Accnt.ncurracc,
                                    $CONTRACTOR_KIND_SERVICE: AccntP_Service.Accnt.ncurracc,
                                    $CONTRACTOR_KIND_OTHERS:  AccntP_Others.Accnt.ncurracc,
                                                              ''
                        );
#}

; -----------------------------------------------
const char foreigns=\
#{";"
  Branch:c_branch
  BranchAll:c_branch
  Kind($CURCFG::UK_Abbrs_Cotractors_Kinds):kind(type)
#}

; -----------------------------------------------
const char slaves=\
#{";"
  Corp($CURCFG::UK_Contractors_Corp):c_contractor
  BankDetails($CURCFG::UK_Contractors_BankDetails):c_contractor
;
  AccntA_Goods($CURCFG::UK_Contractors_Accnts):c_contractor,'$ACCNTCONTRACTOR_TYPE_ACTIVE_GOODS'(accnt_type)
  AccntP_Goods($CURCFG::UK_Contractors_Accnts):c_contractor,'$ACCNTCONTRACTOR_TYPE_PASSIVE_GOODS'(accnt_type)
  AccntA_Service($CURCFG::UK_Contractors_Accnts):c_contractor,'$ACCNTCONTRACTOR_TYPE_ACTIVE_SERVICE'(accnt_type)
  AccntP_Service($CURCFG::UK_Contractors_Accnts):c_contractor,'$ACCNTCONTRACTOR_TYPE_PASSIVE_SERVICE'(accnt_type)
  AccntA_Others($CURCFG::UK_Contractors_Accnts):c_contractor,'$ACCNTCONTRACTOR_TYPE_ACTIVE_OTHERS'(accnt_type)
  AccntP_Others($CURCFG::UK_Contractors_Accnts):c_contractor,'$ACCNTCONTRACTOR_TYPE_PASSIVE_OTHERS'(accnt_type)
#}

; -----------------------------------------------
const char slave_refs=\
#{";"
  Orders($CURCFG::UK_Orders_Def):c_contractor
#}

; -----------------------------------------------
const char references=\
#{";"
  Chiefs($CURCFG::UK_Contractors_Chiefs):c_contractor
  Accnts($CURCFG::UK_Contractors_Accnts):c_contractor
#}

; -----------------------------------------------
const char spc_codes=\
#{";"
  $spc_get_tunning_info (<@get_tunning_info (shname,Corp.name,_accnt_contractor_a,_accnt_contractor_p)>):#Pget_tunning_info_parms
  $spc_contractor_rollback (<@_contractor_rollback (c_contractor)>)
  $spc_entity_rollback (<$spc_entity_rollback_all_orders + $spc_contractor_rollback>)
;
  $spc_entity_delete_all_orders (<Orders.$spc_uk_orders_delete>);
  $spc_entity_rollback_all_orders (<Orders.$spc_uk_orders_rollback>);
#}

;> ------------------------------------------------
;> __get_tunning_info
;    получение аттрибутов объекта и сохранение их во внешней коллекции
;    для использования в Delphi
;> ------------------------------------------------
const char get_tunning_info_parms=\
#{";"
  ext_coll_name:Имя внешней коллекции#Tstring_t
#}

const char get_tunning_info=\
#{
  $CHAR(ncurracc_a,ncurracc_p)
  
  -SQL select ncurracc into ?ncurracc_a from accnts_def where c_accnt = @_accnt_contractor_a;
  -SQL select ncurracc into ?ncurracc_p from accnts_def where c_accnt = @_accnt_contractor_p;
  
  ncurracc_a = isnull(@@ncurracc_a) ? "" : @@ncurracc_a;
  ncurracc_p = isnull(@@ncurracc_p) ? "" : @@ncurracc_p;

  @ext_coll_name.RenewVarsFromColl(CURRENT.get_name());
#}

;> ------------------------------------------------
;> __contractor_rollback
;> ------------------------------------------------
const char _contractor_rollback=\
#{
  call("$CURCFG::cmds_orders:_check_for_existing_orders", "c_contractor", @@c_contractor, "контрагента");

; -------------------------------------
; проверка на наличие счетов, связанных с контрагентом
; -------------------------------------
  $LONG(_cnt)
  SQL
    select count(*) into ?_cnt
    from $uk_contractors_accnts ca
      join accnts_def a on a.c_accnt = ca.c_accnt
    where
      ca.c_contractor = @c_contractor;

  (@@_cnt == 0)
      ? 0
      : RaiseError(-1, "К контрагенту привязаны счета [@_cnt шт.]. Сначала необходимо ""отвязать"" их!", "");

; -------------------------------------
  SQL delete from $uk_contractors_corp         where c_contractor = @c_contractor;
  SQL delete from $uk_contractors_bank_details where c_contractor = @c_contractor;
  SQL delete from $uk_contractors_chiefs       where c_contractor = @c_contractor;
  SQL delete from $uk_contractors_accnts       where c_contractor = @c_contractor;
  SQL delete from $uk_contractors_def          where c_contractor = @c_contractor;
#}



[UK_Contractors_BankDetails] default: $CURCFG::UK_Contractors_Tpl
const char ks_table=$uk_contractors_bank_details
const char ks_keys=c_contractor
const char history=change:prev_change/next_change
const char query_defaults=\
#{";"
  prev_change:@today
  next_change:$DayMax
#}

const char masters=\
#{";"
  BankDetails($CURCFG::UK_BankDetails):c_bank_detail
#}


[UK_Contractors_Corp] default: $CURCFG::UK_Contractors_Tpl
const char ks_table=$uk_contractors_corp
const char ks_keys=c_contractor
const char history=change:prev_change/next_change
const char ks_defaults=\
#{";"
  inn:
  ogrn:
  address:
  prev_change:@today
  next_change:$DayMax
#}


[UK_Contractors_Chiefs] default: $CURCFG::UK_Contractors_Tpl
const char ks_table=$uk_contractors_chiefs
const char ks_keys=c_contractor,type_chief
const char history=change:prev_change/next_change
const char ks_defaults=\
#{";"
  name:
  phone:
  type_chief:$CHIEF_TYPE_CEO
  prev_change:@today
  next_change:$DayMax
#}

const char foreigns=\
#{";"
  Type($CURCFG::UK_Abbrs_ChiefTypes):type_chief(type)
#}


[UK_Contractors_Accnts] default: $CURCFG::UK_Contractors_Tpl
const char ks_table=$uk_contractors_accnts
const char ks_keys=c_contractor,accnt_type
const char history=change:prev_change/next_change
const char drop_condition=*
const char query_defaults=\
#{";"
  prev_change:@today
  next_change:$DayMax
#}
const char ks_defaults=\
#{";"
  c_contractor:0
  accnt_type:$ACCNTCONTRACTOR_TYPE_RS
  c_accnt:0
  prev_change:@today
  next_change:$DayMax
#}

const char foreigns=\
#{";"
  Contractor($CURCFG::UK_Contractors_Def):c_contractor
  Type($CURCFG::UK_Abbrs_AccntContractorTypes):accnt_type(type)
  Accnt:c_accnt
#}

[UK_Contractors_Accnts_For_Branch]
const char main_class=DB_Kscurs
const char parent_kstat=$CURCFG::UK_Contractors_Accnts
const char ks_where=@BranchSelect.c_branch in ($BRANCH_CONS, [Contractor.c_branch])

;> ============================================================================
;> employees
;> ============================================================================
[UK_Employees_Def] default: $CURCFG::UK_Contractors_Tpl
const char ks_table=$uk_employees_def
const char ks_keys=c_employee
const char serial=c_employee
const char history=open:open_day/delete_day
const char ks_where=$BRANCH_WHERE_OBJ
const char ks_order=shname
const char query_defaults=\
#{";"
  open_day:@today
  delete_day:$DayMax
#}
const char ks_defaults=\
#{";"
  c_branch:@BranchSelect.c_branch
  name:
  shname:
  abbr:
  inn:
  snils:
  photo:
  code:0
#}

; -----------------------------------------------
const char rfc_modifiers=\
#{";"
  WorkInfo:d
  BankDetails:d
  Orders:d
  OrdersAll:d
#}

;> ----------------------------------------------------------------------------
;> __synonyms
;> ----------------------------------------------------------------------------
const char synonyms=\
#{";"
  _salary[MONEY]=?/Isum_Salary_Today.isum/                (isnull(@Isum_Salary_Today.isum)          ? 0 : @Isum_Salary_Today.isum)
  _for_child_fss[MONEY]=?/Isum_ForChild_FSS_Today.isum/   (isnull(@Isum_ForChild_FSS_Today.isum)    ? 0 : @Isum_ForChild_FSS_Today.isum)
  _ndfl_reduction[MONEY]=?/Isum_NDFL_Reduction_Today.isum/(isnull(@Isum_NDFL_Reduction_Today.isum)  ? 0 : @Isum_NDFL_Reduction_Today.isum)
#}

;> ----------------------------------------------------------------------------
;> __foreigns
;> ----------------------------------------------------------------------------
const char foreigns=\
#{";"
  Branch:c_branch
;
  Isum_Salary_Today($CURCFG::UK_Employees_IsumsDay):c_employee,'$ISUMEMPLOYEE_TYPE_SALARY_GROSS'(isum_type),@today(#today)
  Isum_ForChild_FSS_Today($CURCFG::UK_Employees_IsumsDay):c_employee,'$ISUMEMPLOYEE_TYPE_CHILD_FSS'(isum_type),@today(#today)
  Isum_NDFL_Reduction_Today($CURCFG::UK_Employees_IsumsDay):c_employee,'$ISUMEMPLOYEE_TYPE_NDFL_REDUCTION'(isum_type),@today(#today)
;
  AccntRequirements($CURCFG::UK_Employees_Accnts_Actual):c_employee,'$ACCNTEMPLOYEE_TYPE_REQUIREMENTS'(accnt_type)
  AccntSalary($CURCFG::UK_Employees_Accnts_Actual):c_employee,'$ACCNTEMPLOYEE_TYPE_SALARY'(accnt_type)
  AccntAssistance($CURCFG::UK_Employees_Accnts_Actual):c_employee,'$ACCNTEMPLOYEE_TYPE_ASSISTANCE'(accnt_type)
  AccntAccountable($CURCFG::UK_Employees_Accnts_Actual):c_employee,'$ACCNTEMPLOYEE_TYPE_ACCOUNTABLE'(accnt_type)
  AccntInsuranse_PFR($CURCFG::UK_Employees_Accnts_Actual):c_employee,'$ACCNTEMPLOYEE_TYPE_INSURANCE_PFR'(accnt_type)
  AccntInsuranse_OMS($CURCFG::UK_Employees_Accnts_Actual):c_employee,'$ACCNTEMPLOYEE_TYPE_INSURANCE_OMS'(accnt_type)
  AccntInsuranse_FSS($CURCFG::UK_Employees_Accnts_Actual):c_employee,'$ACCNTEMPLOYEE_TYPE_INSURANCE_FSS'(accnt_type)
  AccntInsuranse_FSS_ACC($CURCFG::UK_Employees_Accnts_Actual):c_employee,'$ACCNTEMPLOYEE_TYPE_INSURANCE_FSS_ACC'(accnt_type)
; ---------------------------
; ежегодные параметры
; ---------------------------
  PY_Days_Worked($CURCFG::UK_Employees_Calc_Params):c_employee,'$CALC_PARAM_EMPLOYEE_DAYS_WORKED'(calc_param_type),'$PERIOD_KIND_YEAR'(period_kind)
  PY_Days_Illness($CURCFG::UK_Employees_Calc_Params):c_employee,'$CALC_PARAM_EMPLOYEE_DAYS_ILLNESS'(calc_param_type),'$PERIOD_KIND_YEAR'(period_kind)
  PY_Days_Vacation($CURCFG::UK_Employees_Calc_Params):c_employee,'$CALC_PARAM_EMPLOYEE_DAYS_VACATION'(calc_param_type),'$PERIOD_KIND_YEAR'(period_kind)
;
  MY_Payment($CURCFG::UK_Employees_Calc_Isums):c_employee,'$CALC_PARAM_EMPLOYEE_PAIM'(calc_param_type),'$PERIOD_KIND_YEAR'(period_kind)
  MY_PaymentSalary($CURCFG::UK_Employees_Calc_Isums):c_employee,'$CALC_PARAM_EMPLOYEE_PAIM_SALARY'(calc_param_type),'$PERIOD_KIND_YEAR'(period_kind)
  MY_PaymentIllness($CURCFG::UK_Employees_Calc_Isums):c_employee,'$CALC_PARAM_EMPLOYEE_PAIM_ILLNESS'(calc_param_type),'$PERIOD_KIND_YEAR'(period_kind)
  MY_PaymentVacation($CURCFG::UK_Employees_Calc_Isums):c_employee,'$CALC_PARAM_EMPLOYEE_PAIM_VACATION'(calc_param_type),'$PERIOD_KIND_YEAR'(period_kind)
  MY_NDFL($CURCFG::UK_Employees_Calc_Isums):c_employee,'$CALC_PARAM_EMPLOYEE_NDFL'(calc_param_type),'$PERIOD_KIND_YEAR'(period_kind)
  MY_Ins_FSS($CURCFG::UK_Employees_Calc_Isums):c_employee,'$CALC_PARAM_EMPLOYEE_INSURANCE_FSS'(calc_param_type),'$PERIOD_KIND_YEAR'(period_kind)
  MY_Ins_FSS_ACC($CURCFG::UK_Employees_Calc_Isums):c_employee,'$CALC_PARAM_EMPLOYEE_INSURANCE_FSS_ACC'(calc_param_type),'$PERIOD_KIND_YEAR'(period_kind)
  MY_Ins_OMS($CURCFG::UK_Employees_Calc_Isums):c_employee,'$CALC_PARAM_EMPLOYEE_INSURANCE_OMS'(calc_param_type),'$PERIOD_KIND_YEAR'(period_kind)
; ---------------------------
; глобальные параметры
; ---------------------------
  PG_Days_Worked($CURCFG::UK_Employees_Calc_Params):c_employee,'$CALC_PARAM_EMPLOYEE_DAYS_WORKED'(calc_param_type),'$PERIOD_KIND_GLOBAL'(period_kind)
  PG_Days_Illness($CURCFG::UK_Employees_Calc_Params):c_employee,'$CALC_PARAM_EMPLOYEE_DAYS_ILLNESS'(calc_param_type),'$PERIOD_KIND_GLOBAL'(period_kind)
  PG_Days_Vacation($CURCFG::UK_Employees_Calc_Params):c_employee,'$CALC_PARAM_EMPLOYEE_DAYS_VACATION'(calc_param_type),'$PERIOD_KIND_GLOBAL'(period_kind)
;
  MG_Payment($CURCFG::UK_Employees_Calc_Isums):c_employee,'$CALC_PARAM_EMPLOYEE_PAIM'(calc_param_type),'$PERIOD_KIND_GLOBAL'(period_kind)
  MG_PaymentSalary($CURCFG::UK_Employees_Calc_Isums):c_employee,'$CALC_PARAM_EMPLOYEE_PAIM_SALARY'(calc_param_type),'$PERIOD_KIND_GLOBAL'(period_kind)
  MG_PaymentIllness($CURCFG::UK_Employees_Calc_Isums):c_employee,'$CALC_PARAM_EMPLOYEE_PAIM_ILLNESS'(calc_param_type),'$PERIOD_KIND_GLOBAL'(period_kind)
  MG_PaymentVacation($CURCFG::UK_Employees_Calc_Isums):c_employee,'$CALC_PARAM_EMPLOYEE_PAIM_VACATION'(calc_param_type),'$PERIOD_KIND_GLOBAL'(period_kind)
  MG_NDFL($CURCFG::UK_Employees_Calc_Isums):c_employee,'$CALC_PARAM_EMPLOYEE_NDFL'(calc_param_type),'$PERIOD_KIND_GLOBAL'(period_kind)
  MG_Ins_FSS($CURCFG::UK_Employees_Calc_Isums):c_employee,'$CALC_PARAM_EMPLOYEE_INSURANCE_FSS'(calc_param_type),'$PERIOD_KIND_GLOBAL'(period_kind)
  MG_Ins_FSS_ACC($CURCFG::UK_Employees_Calc_Isums):c_employee,'$CALC_PARAM_EMPLOYEE_INSURANCE_FSS_ACC'(calc_param_type),'$PERIOD_KIND_GLOBAL'(period_kind)
  MG_Ins_OMS($CURCFG::UK_Employees_Calc_Isums):c_employee,'$CALC_PARAM_EMPLOYEE_INSURANCE_OMS'(calc_param_type),'$PERIOD_KIND_GLOBAL'(period_kind)
#}

const char outer_slaves=\
#{";"
  WorkInfo($CURCFG::UK_Employees_WorkInfo):c_employee
  BankDetails($CURCFG::UK_Employees_BankDetails):c_employee
#}

const char slave_refs=\
#{";"
  Orders($CURCFG::UK_Orders_WithOutPseudo_WithOutDeleted):c_employee
  OrdersAll($CURCFG::UK_Orders_WithOutPseudo):c_employee
#}

const char refs_x1=\
#{";"
  DogLabour($CURCFG::UK_Dogovors_All):c_employee,'$DOG_KIND_LABOUR'(dog_kind)
#}

const char references=\
#{";"
  Accnts($CURCFG::UK_Employees_Accnts):c_employee
  Isum_Salary_History($CURCFG::UK_Employees_Isums):c_employee,'$ISUMEMPLOYEE_TYPE_SALARY_GROSS'(isum_type)
  Isum_ForChild_FSS_History($CURCFG::UK_Employees_Isums):c_employee,'$ISUMEMPLOYEE_TYPE_CHILD_FSS'(isum_type)
  Isum_NDFL_Reduction_History($CURCFG::UK_Employees_Isums):c_employee,'$ISUMEMPLOYEE_TYPE_NDFL_REDUCTION'(isum_type)
  Isum_PFR_Reduction_History($CURCFG::UK_Employees_Isums):c_employee,'$ISUMEMPLOYEE_TYPE_PFR_DEDUCTION'(isum_type)
#}

;> ----------------------------------------------------------------------------
;> __spc_codes
;> ----------------------------------------------------------------------------
const char spc_codes=\
#{
  $spc_employee_accnts_create   (<@_employee_accnts_create (c_employee,c_branch,name,shname,code)>);
  $spc_employee_accnts_rollback (<@_employee_accnts_rollback (c_employee)>);
  $spc_set_isum_with_history (<@_employee_set_isum_with_history (c_employee)>):#P_employee_set_isum_with_history_parms;
  $spc_get_tunning_info (<@get_tunning_info (shname,name)>):#Pget_tunning_info_parms;
  $spc_get_paid_isum_of_year_before (<@_get_paid_isum_of_year_before (c_employee)>):#P_get_paid_isum_of_year_before_parms;
  $spc_get_rests_on_accnts (<@_get_rests_on_accnts (c_employee)>):#P_get_rests_on_accnts_parms;
  $spc_get_insurance_isums (<@_get_insurance_isums (c_employee)>):#P_get_insurance_isums_parms;
;
  $spc_ordercreate_employee_salary_adv (<@_employee_salary_adv (
                                                                 c_branch,c_employee,
                                                                 _c_dogovor_labour=DogLabour.c_dogovor,_dog_labour_date0=DogLabour.date0,
                                                                 shname
                                                               )
                                       >):#P_employee_salary_adv_parms;
  $spc_ordercreate_employee_salary_pri (<@_employee_salary_pri (
                                                                 c_branch,c_employee,
                                                                 _c_dogovor_labour=DogLabour.c_dogovor,_dog_labour_date0=DogLabour.date0,
                                                                 _salary_today=Isum_Salary_Today.isum,
                                                                 shname
                                                               )
                                       >):#P_employee_salary_pri_parms;
;
  $spc_ordercreate_employee_vacation_paid   (<@_employee_vacation_paid   (c_branch,c_employee,_c_dogovor_labour=DogLabour.c_dogovor,shname) >):#P_employee_vacation_paid_parms;
  $spc_ordercreate_employee_vacation_accept (<@_employee_vacation_accept (c_branch,c_employee,_c_dogovor_labour=DogLabour.c_dogovor,shname) >):#P_employee_vacation_accept_parms;
  $spc_ordercreate_employee_reserv_increase (<@_employee_vacation_reserv (c_branch,c_employee,_c_dogovor_labour=DogLabour.c_dogovor,shname,_order_type=$ORDER_TYPE_EMPLOYEE_RESERV_INCREASE) >):#P_employee_vacation_reserv_parms;
  $spc_ordercreate_employee_reserv_decrease (<@_employee_vacation_reserv (c_branch,c_employee,_c_dogovor_labour=DogLabour.c_dogovor,shname,_order_type=$ORDER_TYPE_EMPLOYEE_RESERV_DECREASE) >):#P_employee_vacation_reserv_parms;
;
  $spc_ordercreate_employee_pay_fin_help    (<@_employee_pay_fin_help    (c_branch,c_employee,_c_dogovor_labour=DogLabour.c_dogovor,shname) >):#P_employee_pay_fin_help_parms;
  $spc_ordercreate_employee_pay_extra_money  (<@_employee_pay_extra_money (c_branch,c_employee,_c_dogovor_labour=DogLabour.c_dogovor,shname,_order_type=$ORDER_TYPE_EMPLOYEE_EXTRA_MONEY) >):#P_employee_pay_extra_money_parms;
  $spc_ordercreate_employee_pay_extra_money_wo_funds (<@_employee_pay_extra_money (c_branch,c_employee,_c_dogovor_labour=DogLabour.c_dogovor,shname,_order_type=$ORDER_TYPE_EMPLOYEE_EXTRA_MONEY_WO_FUNDS)>):#P_employee_pay_extra_money_parms;
;
  $spc_ordercreate_employee_illness         (<@_employee_illness         (c_branch,c_employee,_c_dogovor_labour=DogLabour.c_dogovor,shname) >):#P_employee_illness_parms;
;
  $spc_employee_rollback (<@_employee_rollback (c_employee)>);
  $spc_entity_rollback (<$spc_entity_rollback_all_orders + $spc_employee_rollback>);
  $spc_entity_delete_all_orders (<Orders.$spc_uk_orders_delete>);
  $spc_entity_rollback_all_orders (<Orders.$spc_uk_orders_rollback>);
#}

;> ----------------------------------------------------------------------------
;> __pipe_pre_delete
;> ----------------------------------------------------------------------------
const char pipe_pre_delete=\
#{
  call("$CURCFG::cmds_orders:_check_for_existing_orders", "c_employee", @@c_employee, "сотрудника");
#}

;> ----------------------------------------------------------------------------
;> __pipe_pre_insert
;> ----------------------------------------------------------------------------
const char pipe_pre_insert=\
#{
  (@@code == 0)
      ? RaiseError(-1, "Внутренний код сотрудника в 1C должен быть отличен от нуля!", "")
      : 0;

  $LONG(_cnt)
  SQL select count(*) into ?_cnt from $uk_employees_def where code = @code and c_employee <> @c_employee;
  (@@_cnt == 0)
      ? 0
      : RaiseError(-1, "Внутренний код [@{code}] уже задействован у другого сотрудника!", "");
#}

;> ----------------------------------------------------------------------------
;> __pipe_pre_update
;> ----------------------------------------------------------------------------
const char pipe_pre_update=\
#{
  (@@code == 0)
      ? RaiseError(-1, "Внутренний код сотрудника в 1C должен быть отличен от нуля!", "")
      : 0;

  $LONG(_cnt)
  SQL select count(*) into ?_cnt from $uk_employees_def where code = @code and c_employee <> @c_employee;
  (@@_cnt == 0)
      ? 0
      : RaiseError(-1, "Внутренний код [@{code}] уже задействован у другого сотрудника!", "");
#}


;> ----------------------------------------------------------------------------
;> __pipe_post_insert
;> ----------------------------------------------------------------------------
const char pipe_post_insert=\
#{
  _coll_dummy_order  = Auth.obj_by_name("<null>", "DB_Coll");

; -------------------------------------
; сразу вставляем псевдораспоряжения на первые числа годов для сброса остатков
; ( !
;    исходим из того, что 01 января всегда будет выходным днем и
;    каких либо еще значимых распоряжений в этот день не случится
; ) !
; -------------------------------------
  $LONG(_cfdoy)
  CURSOR
    select cfdoy into ?_cfdoy
    from $utl_year_dates
    where
      cfdoy > $DATE_START
    order by cfdoy
  : call("$CURCFG::$CURSEC:insert_annual_dummy_orders_for_employee", @@c_employee, @@_cfdoy);

  Auth.delete_obj_by_name(@@_coll_dummy_order);
#}

;> ----------------------------------------------------------------------------
;> __insert_annual_dummy_orders_for_employee
;> ----------------------------------------------------------------------------
const char insert_annual_dummy_orders_for_employee_parms=_c_employee,_op_day
const char insert_annual_dummy_orders_for_employee=\
#{
    @_coll_dummy_order.ClearNames();
    @_coll_dummy_order.AssignVarLong("order_type", $ORDER_TYPE_DUMMY_EMPLOYEE_INIT);
    @_coll_dummy_order.AssignVarLong("state",      $ORDER_STATE_PERFORMED);
    @_coll_dummy_order.AssignVarLong("op_day",     @@_op_day);
    @_coll_dummy_order.AssignVarLong("c_employee", @@_c_employee);
  $CURCFG::UK_Orders.DoInsertForColl(@@_coll_dummy_order);

  $LONG(_c_order)
  $CURCFG::UK_Orders.GetKeyLong("c_order", "_c_order");

  call("$CURCFG::$CURSEC:_insert_isum_into_order_forced", @@_c_order, $SCHEMA_ISUM_LABOUR_PAYM_SALARY_GROSS_RESET);
  call("$CURCFG::$CURSEC:_insert_isum_into_order_forced", @@_c_order, $SCHEMA_ISUM_LABOUR_PAYM_ILLNESS_GROSS_RESET);
  call("$CURCFG::$CURSEC:_insert_isum_into_order_forced", @@_c_order, $SCHEMA_ISUM_LABOUR_PAYM_VACATION_GROSS_RESET);
  call("$CURCFG::$CURSEC:_insert_isum_into_order_forced", @@_c_order, $SCHEMA_ISUM_LABOUR_NDFL_RESET);
  call("$CURCFG::$CURSEC:_insert_isum_into_order_forced", @@_c_order, $SCHEMA_ISUM_LABOUR_PAYM_SALARY_NET_RESET);
  call("$CURCFG::$CURSEC:_insert_isum_into_order_forced", @@_c_order, $SCHEMA_ISUM_LABOUR_PAYM_ILLNESS_NET_RESET);
  call("$CURCFG::$CURSEC:_insert_isum_into_order_forced", @@_c_order, $SCHEMA_ISUM_LABOUR_PAYM_VACATION_NET_RESET);
  call("$CURCFG::$CURSEC:_insert_isum_into_order_forced", @@_c_order, $SCHEMA_ISUM_LABOUR_INSURANCE_PFR_RESET);
  call("$CURCFG::$CURSEC:_insert_isum_into_order_forced", @@_c_order, $SCHEMA_ISUM_LABOUR_INSURANCE_FSS_RESET);
  call("$CURCFG::$CURSEC:_insert_isum_into_order_forced", @@_c_order, $SCHEMA_ISUM_LABOUR_INSURANCE_FSS_ACC_RESET);
  call("$CURCFG::$CURSEC:_insert_isum_into_order_forced", @@_c_order, $SCHEMA_ISUM_LABOUR_INSURANCE_OMS_RESET);

  call("$CURCFG::$CURSEC:_insert_param_into_order_forced", @@_c_order, $ORDER_PARAM_COUNT_DAYS_OF_PAIMENT_RESET);
  call("$CURCFG::$CURSEC:_insert_param_into_order_forced", @@_c_order, $ORDER_PARAM_COUNT_DAYS_OF_ILLNESS_RESET);
  call("$CURCFG::$CURSEC:_insert_param_into_order_forced", @@_c_order, $ORDER_PARAM_COUNT_DAYS_OF_VACATION_RESET);
#}

;> ----------------------------------------------------------------------------
;> __insert_isum_into_order_forced
;> ----------------------------------------------------------------------------
const char _insert_isum_into_order_forced_parms=_c_order,_isum_type
const char _insert_isum_into_order_forced=\
#{
  SQL insert into $uk_orders_isums (c_order, isum_type, isum, c_item_group) values (@_c_order, @_isum_type, 0, 0);
#}

;> ----------------------------------------------------------------------------
;> __insert_param_into_order_forced
;> ----------------------------------------------------------------------------
const char _insert_param_into_order_forced_parms=_c_order,_param_type
const char _insert_param_into_order_forced=\
#{
  SQL insert into $uk_orders_params (c_order, param_type, param_value_i) values (@_c_order, @_param_type, 0);
#}

;> ----------------------------------------------------------------------------
;> __employee_accnts_create
;> ----------------------------------------------------------------------------
const char _employee_accnts_create=\
#{
  $LONG(_accnt_type)
  $LONG(_op_day)
  $CHAR(_sabbr)

  $LONG(_default_naccnt)
  $SHORT(_default_ndep)
  $CHAR(_default_oaccnt)

  _op_day                     = Otoday();
  _coll_employee_accnt_keys   = Auth.obj_by_name("<null>", "DB_Coll");
  _coll_employee_accnt_values = Auth.obj_by_name("<null>", "DB_Coll");

; -------------------------------------
; строка в формате: БС|NDEP|OACCNT (например: 60335|9|69.03.1)
; -------------------------------------
  CURSOR
    SELECT a.type, 
           a.cfg_attr[1,5], a.cfg_attr[7,7], a.cfg_attr[9,20],
           a.sabbr
      into ?_accnt_type, 
           ?_default_naccnt, ?_default_ndep, ?_default_oaccnt
           ?_sabbr
    FROM $uk_ref_abbrs a
    WHERE
      a.abbr matches 'ACCNTEMPLOYEE_TYPE_*'
    ORDER BY a.type
    : call("$CURCFG::$CURSEC:_employee_create_one_accnt", @@c_employee, @@_accnt_type, @@_default_naccnt, @@_default_ndep, @@_default_oaccnt, @@_sabbr, @@shname, @@c_branch, @@_op_day, @@code);

  Auth.delete_obj_by_name(@@_coll_employee_accnt_values);
  Auth.delete_obj_by_name(@@_coll_employee_accnt_keys);
#}

;> ----------------------------------------------
;> __employee_create_one_accnt
;> ----------------------------------------------
const char _employee_create_one_accnt_parms=_c_employee,_accnt_type,_default_naccnt,_default_ndep,_default_oaccnt,_sabbr,_shname,_c_branch,_op_day,_code
const char _employee_create_one_accnt=\
#{
; -------------------------------------
; проверка на наличие "живого" счета данного типа у контрагента
; (если да - то просто выходим безо всяких ошибок)
; -------------------------------------
  $LONG(_cnt)
  SQL
    select count(*) into ?_cnt
    from $uk_employees_accnts ea
      join accnts_def a on a.c_accnt = ea.c_accnt
    where
      ea.c_employee = @_c_employee and
      ea.accnt_type = @_accnt_type;

  (@@_cnt == 0)
      ? 0
      : return(0);


; -------------------------------------
; БС для оплаты и вознаграждений один для всех
; -------------------------------------
  $LONG(_c_naccnt_employee)
  SQL select c_naccnt into ?_c_naccnt_employee from npl_accnt2 where naccnt = @_default_naccnt;
  
; -------------------------------------
; создаем лицевой счет
; -------------------------------------
  $CHAR(_accnt_name)
    _accnt_name = "[" + @@_shname + "] " + @@_sabbr;
    _coll_employee_ext  = Auth.obj_by_name("<null>", "DB_Coll");

  $LONG(_c_accnt)
    _c_accnt  = call("crbase::UserUtils:_insert_new_accnt", $CURR_ROUBLE, @@_c_branch, @@_c_naccnt_employee, 0, @@_default_ndep, 0, @@_code,
                                                            0, @@_accnt_name, @@_default_oaccnt, @@_default_oaccnt, "", 0, 0, "AccntNormal", @@_coll_employee_ext);

  Auth.delete_obj_by_name(@@_coll_employee_ext);

; -------------------------------------
; добавляем его к сотруднику
; -------------------------------------
  SQL
    select count(*) into ?_cnt
    from $uk_employees_accnts ea
    where
      ea.c_employee = @_c_employee and
      ea.accnt_type = @_accnt_type;

  (@@_cnt == 0)
      ? call("$CURCFG::$CURSEC:_insert_employee_accnt", @@_c_employee, @@_accnt_type, @@_c_accnt, @@_op_day)
      : call("$CURCFG::$CURSEC:_update_employee_accnt", @@_c_employee, @@_accnt_type, @@_c_accnt);
#}

;> ----------------------------------------------------------------------------
;> __insert_employee_accnt
;> ----------------------------------------------------------------------------
const char _insert_employee_accnt_parms=_c_employee,_accnt_type,_c_accnt,_op_day
const char _insert_employee_accnt=\
#{
  @_coll_employee_accnt_values.ClearNames();
    @_coll_employee_accnt_values.AssignVarLong("c_employee",  @@_c_employee);
    @_coll_employee_accnt_values.AssignVarLong("accnt_type",  @@_accnt_type);
    @_coll_employee_accnt_values.AssignVarLong("c_accnt",     @@_c_accnt);
;    @_coll_employee_accnt_values.AssignVarLong("prev_change", @@_op_day);
;    @_coll_employee_accnt_values.AssignVarLong("next_change", $DayMax);
  $CURCFG::UK_Employees_Accnts.DoInsertForColl(@@_coll_employee_accnt_values);
#}

;> ----------------------------------------------------------------------------
;> __update_employee_accnt
;> ----------------------------------------------------------------------------
const char _update_employee_accnt_parms=_c_employee,_accnt_type,_c_accnt
const char _update_employee_accnt=\
#{
  @_coll_employee_accnt_keys.ClearNames();
    @_coll_employee_accnt_keys.AssignVarLong("c_employee", @@_c_employee);
    @_coll_employee_accnt_keys.AssignVarLong("accnt_type", @@_accnt_type);
  @_coll_employee_accnt_values.ClearNames();
    @_coll_employee_accnt_values.AssignVarLong("c_accnt",    @@_c_accnt);

  $CURCFG::UK_Employees_Accnts_Actual.KeysFromCollection(@@_coll_employee_accnt_keys);
  $CURCFG::UK_Employees_Accnts_Actual.DoUpdateForColl(@@_coll_employee_accnt_values);
#}


;> ----------------------------------------------------------------------------
;> __employee_accnts_rollback
;> ----------------------------------------------------------------------------
const char _employee_accnts_rollback=\
#{
  $LONG(_c_accnt,_accnt_type)

  _coll_employee_accnt_keys   = Auth.obj_by_name("<null>", "DB_Coll");
  _coll_employee_accnt_values = Auth.obj_by_name("<null>", "DB_Coll");

  CURSOR
    SELECT ea.accnt_type, NVL(a.c_accnt, 0) into ?_accnt_type, ?_c_accnt
    FROM $uk_employees_accnts ea
      LEFT JOIN accnts_def a ON a.c_accnt = ea.c_accnt
    WHERE
      ea.c_employee = @c_employee
    : call("$CURCFG::$CURSEC:_employee_rollback_one_accnt", @@c_employee, @@_accnt_type, @@_c_accnt); 

  Auth.delete_obj_by_name(@@_coll_employee_accnt_values);
  Auth.delete_obj_by_name(@@_coll_employee_accnt_keys);
#}

;> ----------------------------------------------------------------------------
;> __employee_rollback_one_accnt
;> ----------------------------------------------------------------------------
const char _employee_rollback_one_accnt_parms=_c_employee,_accnt_type,_c_accnt
const char _employee_rollback_one_accnt=\
#{
; -------------------------------------
; сначала чистим ссылку на счет (независимо от наличия самого счета в АБС)
; -------------------------------------
  call("$CURCFG::$CURSEC:_update_employee_accnt", @@_c_employee, @@_accnt_type, 0);

  (@@_c_accnt == 0)
      ? return(0)
      : 0;

  Accnt.SetKeyLong("c_accnt", @@_c_accnt);
  Accnt.DoSpc($spcRollbackInsert, "<null>");
#}

;> ----------------------------------------------------------------------------
;> __get_tunning_info
;    получение аттрибутов объекта и сохранение их во внешней коллекции
;    для использования в Delphi
;> ----------------------------------------------------------------------------
const char get_tunning_info_parms=\
#{";"
  ext_coll_name:Имя внешней коллекции#Tstring_t
#}

const char get_tunning_info=\
#{
; -------------------------------------
; сохраняем все текущие известные переменные (параметры) во внешнюю коллекцию
; -------------------------------------
  @ext_coll_name.RenewVarsFromColl(CURRENT.get_name());
#}


;> ----------------------------------------------------------------------------
;> __get_insurance_isums
;    вычисление сумм для страховых перечислений
;> ----------------------------------------------------------------------------
const char _get_insurance_isums_parms=\
#{";"
  _isum:Сумма отпускных#Tmoney_t
  _isum_paid_before:Сумма выплаченная в этом году#Tmoney_t
  _ext_coll_name:Имя внешней коллекции#Tstring_t
#}

const char _get_insurance_isums=\
#{
  $MONEY(_tax_fss_acc,_tax_ffoms)
    _tax_fss_acc = call("$CURCFG::cmds:get_setting_attr", $SETTING_PARAM_INS_FSSACC_TAX, $BRANCH_OUR, "value_m");
    _tax_ffoms   = call("$CURCFG::cmds:get_setting_attr", $SETTING_PARAM_INS_OMS_TAX,    $BRANCH_OUR, "value_m");

  $MONEY(_insurance_pfr,_insurance_fss,_insurance_fss_acc,_insurance_ffoms)
    _insurance_pfr     = call("$CURCFG::cmds:_calc_complicated_ensuranse_isum", @@_isum, @@_isum_paid_before, $SETTING_PARAM_INS_PFR_ISUM_BASE, $SETTING_PARAM_INS_PFR_TAX_BASE, $SETTING_PARAM_INS_PFR_TAX_EXTRA);
    _insurance_fss     = call("$CURCFG::cmds:_calc_complicated_ensuranse_isum", @@_isum, @@_isum_paid_before, $SETTING_PARAM_INS_FSS_ISUM_BASE, $SETTING_PARAM_INS_FSS_TAX_BASE, $SETTING_PARAM_INS_FSS_TAX_EXTRA);
    _insurance_fss_acc = round(@@_isum * @@_tax_fss_acc * 0.01, 2);
    _insurance_ffoms   = round(@@_isum * @@_tax_ffoms   * 0.01, 2);

; -------------------------------------
; сохраняем все текущие известные переменные (параметры) во внешнюю коллекцию
; -------------------------------------
  @_ext_coll_name.RenewVarsFromColl(CURRENT.get_name());
#}

;> ----------------------------------------------------------------------------
;> __get_rests_on_accnts
;    вычисление суммы, выплаченной работнику с начала года
;> ----------------------------------------------------------------------------
const char _get_rests_on_accnts_parms=\
#{";"
  _op_day:Опер. день#Tdate_t
  _ext_coll_name:Имя внешней коллекции#Tstring_t
#}

const char _get_rests_on_accnts=\
#{
  $LONG(__op_day)
  $MONEY(_rest_60305,_rest_60335_pfr,_rest_60335_fss,_rest_60335_fss_acc,_rest_60335_oms)
    __op_day = long(@@_op_day);

    _rest_60305         = call("$CURCFG::$CURSEC:_get_rest_on_accnt_typed", @@c_employee, @@__op_day, $ACCNTEMPLOYEE_TYPE_SALARY,            "credit2");
    _rest_60335_pfr     = call("$CURCFG::$CURSEC:_get_rest_on_accnt_typed", @@c_employee, @@__op_day, $ACCNTEMPLOYEE_TYPE_INSURANCE_PFR,     "credit2");
    _rest_60335_fss     = call("$CURCFG::$CURSEC:_get_rest_on_accnt_typed", @@c_employee, @@__op_day, $ACCNTEMPLOYEE_TYPE_INSURANCE_FSS,     "credit2");
    _rest_60335_fss_acc = call("$CURCFG::$CURSEC:_get_rest_on_accnt_typed", @@c_employee, @@__op_day, $ACCNTEMPLOYEE_TYPE_INSURANCE_FSS_ACC, "credit2");
    _rest_60335_oms     = call("$CURCFG::$CURSEC:_get_rest_on_accnt_typed", @@c_employee, @@__op_day, $ACCNTEMPLOYEE_TYPE_INSURANCE_OMS,     "credit2");

; -------------------------------------
; сохраняем все текущие известные переменные (параметры) во внешнюю коллекцию
; -------------------------------------
  @_ext_coll_name.RenewVarsFromColl(CURRENT.get_name());
#}


;> ----------------------------------------------------------------------------
;> __get_rest_on_accnt_typed
;> ----------------------------------------------------------------------------

const char _get_rest_on_accnt_typed_parms=_c_employee,__op_day,_accnt_type,_fld_rest
const char _get_rest_on_accnt_typed=\
#{
  $MONEY(__rest2)
  
  -SQL
    select t.@{_fld_rest} into ?__rest2
    from $uk_employees_accnts e
      join turnovers t on
                          t.c_accnt = e.c_accnt and
                          t.c_curr  = $CURR_ROUBLE and
                          t.op_day  = @__op_day
    where
      e.c_employee = @_c_employee and
      e.accnt_type = @_accnt_type and
      @__op_day between e.prev_change and e.next_change;
  __rest2 = isnull(@@__rest2) ? 0 : @@__rest2;

  return(@@__rest2);
#}

;> ----------------------------------------------------------------------------
;> __get_paid_isum_of_year_before
;    вычисление суммы, выплаченной работнику с начала года
;    (!! когда заработает автоматический пересчет остатков она станет не нужна !!)
;> ----------------------------------------------------------------------------
const char _get_paid_isum_of_year_before_parms=\
#{";"
  _op_day:Опер. день#Tdate_t
  _ext_coll_name:Имя внешней коллекции#Tstring_t
#}

const char _get_paid_isum_of_year_before=\
#{
  $MONEY(_isum_paid_before)
    _isum_paid_before = call("$CURCFG::$CURSEC:_calc_paid_isum_of_period_before", long(@@_op_day), @@c_employee, "cfdoy");
  

; -------------------------------------
; сохраняем все текущие известные переменные (параметры) во внешнюю коллекцию
; -------------------------------------
  @_ext_coll_name.RenewVarsFromColl(CURRENT.get_name());
#}


;> ----------------------------------------------------------------------------
;> __calc_paid_isum_of_period_before
;> ----------------------------------------------------------------------------
const char _calc_paid_isum_of_period_before_parms=_op_day,_c_employee,_cld_const
const char _calc_paid_isum_of_period_before=\
#{
; "cfdoy"
  $LONG(_date0,_date1)
    _date0 = CldGetLimit(@@_op_day, @@_cld_const);
    _date1 = long(@@_op_day);

; -------------------------------------
; суммы по заработной плате, отпуску, доп.заработку
; -------------------------------------
  $MONEY(__isum_paid_pri, __isum_paid_vacation, __isum_extra, __isum_extra2)
    __isum_paid_pri      = call("$CURCFG::$CURSEC:_get_sum_for_employee_for_period", @@_c_employee, @@_date0, @@_date1, $ORDER_TYPE_EMPLOYEE_SALARY_PRI,            $SCHEMA_ISUM_LABOUR_PAYMENT_GROSS);
    __isum_paid_vacation = call("$CURCFG::$CURSEC:_get_sum_for_employee_for_period", @@_c_employee, @@_date0, @@_date1, $ORDER_TYPE_EMPLOYEE_VACATION_ACCEPT,       $SCHEMA_ISUM_LABOUR_PAYMENT_GROSS);
    __isum_extra         = call("$CURCFG::$CURSEC:_get_sum_for_employee_for_period", @@_c_employee, @@_date0, @@_date1, $ORDER_TYPE_EMPLOYEE_EXTRA_MONEY,           $SCHEMA_ISUM_LABOUR_PAYMENT_GROSS);
    __isum_extra2        = call("$CURCFG::$CURSEC:_get_sum_for_employee_for_period", @@_c_employee, @@_date0, @@_date1, $ORDER_TYPE_EMPLOYEE_EXTRA_MONEY_WO_FUNDS,  $SCHEMA_ISUM_LABOUR_PAYMENT_GROSS);

  return(@@__isum_paid_pri + @@__isum_paid_vacation + @@__isum_extra + @@__isum_extra2)
#}

;> ----------------------------------------------
;> __get_sum_for_employee_for_period
;> ----------------------------------------------
const char _get_sum_for_employee_for_period_parms=_c_employee,_date0,_date1,_order_types,_isum_type
const char _get_sum_for_employee_for_period=\
#{
  $MONEY(_isum_out)
  _isum_out = 0;

  -SQL
    select sum(s.isum) into ?_isum_out
    from $uk_orders_def o
      join $uk_orders_isums s on s.c_order = o.c_order and s.isum_type = @_isum_type
    where
      o.c_employee = @_c_employee and
      o.op_day between @_date0 and @_date1 and
      o.order_type IN (@_order_types) and
      o.state not in ($ORDER_STATE_DELETED);

  _isum_out = isnull(@@_isum_out) ? 0 : @@_isum_out;

  return(@@_isum_out);
#}

;> ----------------------------------------------
;> __employee_rollback
;> ----------------------------------------------
const char _employee_rollback=\
#{
; -------------------------------------
; проверка на наличие счетов, связанных с работником
; -------------------------------------
  $LONG(_cnt)
  SQL
    select count(*) into ?_cnt
    from $uk_employees_accnts ea
      join accnts_def a on a.c_accnt = ea.c_accnt
    where
      ea.c_employee = @c_employee;

  (@@_cnt == 0)
      ? 0
      : RaiseError(-1, "К работнику привязаны счета [@_cnt шт.]. Сначала необходимо ""отвязать"" их!", "");

; -------------------------------------
  SQL delete from $uk_employees_work_info    where c_employee = @c_employee;
  SQL delete from $uk_employees_bank_details where c_employee = @c_employee;
  SQL delete from $uk_calc_params_employees  where c_employee = @c_employee;
  SQL delete from $uk_calc_isums_employees   where c_employee = @c_employee;
  SQL delete from $uk_employees_accnts       where c_employee = @c_employee;
  SQL delete from $uk_employees_def          where c_employee = @c_employee;
#}

;> ----------------------------------------------------------------------------
;> __employee_set_isum_with_history
;> ----------------------------------------------------------------------------
const char _employee_set_isum_with_history_parms=_isum,_date0,_date1,_isum_type
const char _employee_set_isum_with_history=\
#{
  call("crbase::cmds:_set_isum_with_history", "$uk_employees_isums", "c_employee", @@c_employee, @@_isum_type, @@_isum, long(@@_date0), long(@@_date1));
#}

;> ----------------------------------------------------------------------------
;> __employee_vacation_reserv
;    начисление резерва в начале года по предстоящим отпускам работника
;> ----------------------------------------------------------------------------
const char _employee_vacation_reserv_parms=\
#{";"
  _op_day:Дата#Tdate_t
  _isum_60305:Сумма#Tmoney_t
  _insurance_pfr:Сумма#Tmoney_t
  _insurance_fss:Сумма#Tmoney_t
  _insurance_fss_acc:Сумма#Tmoney_t
  _insurance_oms:Сумма#Tmoney_t
#}

const char _employee_vacation_reserv=\
#{
  (@@_c_dogovor_labour == 0)
      ? RaiseError(-1, "С сотрудником [" + string(@@shname) + "] не заключен трудовой договор!", "")
      : 0;

; -------------------------------------
; 3. создаем распоряжение
; -------------------------------------
  _coll_insert  = Auth.obj_by_name("<null>", "DB_Coll");
    @_coll_insert.ClearNames();
    @_coll_insert.AssignVarLong("order_type",           @@_order_type);
    @_coll_insert.AssignVarLong("c_curr",               $CURR_ROUBLE);
    @_coll_insert.AssignVarLong("c_employee",           @@c_employee);
    @_coll_insert.AssignVarLong("c_dogovor",            @@_c_dogovor_labour);
    @_coll_insert.AssignVarDate("op_day",               @@_op_day);

    @_coll_insert.SetVarMoney("ISum_LbrPaymentGROSS.isum",   @@_isum_60305);
    @_coll_insert.SetVarMoney("ISum_LbrIns_PFR.isum",        @@_insurance_pfr);
    @_coll_insert.SetVarMoney("ISum_LbrIns_FSS.isum",        @@_insurance_fss);
    @_coll_insert.SetVarMoney("ISum_LbrIns_FSS_ACC.isum",    @@_insurance_fss_acc);
    @_coll_insert.SetVarMoney("ISum_LbrIns_OMS.isum",        @@_insurance_oms);
  $CURCFG::UK_Orders.DoInsertForColl(@@_coll_insert);

  Auth.delete_obj_by_name(@@_coll_insert);
#}



;> ----------------------------------------------------------------------------
;> __employee_vacation_paid
;    фактическая выплата работнику отпуска
;> ----------------------------------------------------------------------------
const char _employee_vacation_paid_parms=\
#{";"
  _op_day:Дата выплаты#Tdate_t
  _date0:Начало отпуска#Tdate_t
  _date1:Окончание отпуска#Tdate_t
  _isum_vacation:Сумма (gross)#Tmoney_t
#}

const char _employee_vacation_paid=\
#{
  (@@_c_dogovor_labour == 0)
      ? RaiseError(-1, "С сотрудником [" + string(@@shname) + "] не заключен трудовой договор!", "")
      : 0;

; -------------------------------------
; проверка на существование распоряжения на закрытие общих счетов 60335 (перечисления в фонды)
; его нужно создавать самым последним
; -------------------------------------
  $LONG(_cfdom,_cldom)
    _cfdom = CldGetLimit(@@_op_day, "cfdom");
    _cldom = CldGetLimit(@@_op_day, "cldom");
  call("$CURCFG::cmds_orders:_check_orders_on_unique", $ORDER_TYPE_EMPLOYEE_PAYMENT_TO_FUNDS, @@_cfdom, @@_cldom, 0, 0,            0, 0, $_TRUE);
  call("$CURCFG::cmds_orders:_check_orders_on_unique", $ORDER_TYPE_EMPLOYEE_CHECK_60335,      @@_cfdom, @@_cldom, 0, @@c_employee, 0, 0, $_TRUE);

; -------------------------------------
; сумма вычета (на детей)
; -------------------------------------
  $MONEY(_ndfl_reduction)
  -SQL
    select isum into ?_ndfl_reduction
    from $uk_employees_isums
    where
      c_employee = @c_employee and
      isum_type  = $ISUMEMPLOYEE_TYPE_NDFL_REDUCTION and
      @_cldom between prev_change and next_change;
  _ndfl_reduction = isnull(@@_ndfl_reduction) ? 0 : @@_ndfl_reduction;



; -------------------------------------
; остаток на счете 60305 (начисленный ранее резерв) не может быть превышен (=> уйти в в дебет),
; поэтому возможную разницу добираем с 60306
; -------------------------------------
  $MONEY(_rest2_60305,_isum_overpay_vacation)
    _rest_60305             = call("$CURCFG::$CURSEC:_get_rest_on_accnt_typed", @@c_employee, long(@@_op_day), $ACCNTEMPLOYEE_TYPE_SALARY, "credit2");
    _isum_overpay_vacation  = (@@_isum_vacation > @@_rest_60305) ? (@@_isum_vacation - @@_rest_60305) : 0;

; -------------------------------------
; выделяем НДФЛ
; -------------------------------------
  $MONEY(_tax_ndfl,_isum_ndfl)
    _tax_ndfl   = call("$CURCFG::cmds:get_setting_attr", $SETTING_PARAM_TAX_NDFL,  @@c_branch, "value_m");
    _isum_ndfl  = round((@@_isum_vacation - @@_ndfl_reduction) * @@_tax_ndfl * 0.01, 0);
; -------------------------------------
; 1. создаем распоряжение
; -------------------------------------
  _coll_insert  = Auth.obj_by_name("<null>", "DB_Coll");
    @_coll_insert.ClearNames();
    @_coll_insert.AssignVarLong("order_type",                               $ORDER_TYPE_EMPLOYEE_VACATION_PAID);
    @_coll_insert.AssignVarLong("c_curr",                                   $CURR_ROUBLE                      );
    @_coll_insert.AssignVarLong("c_employee",                               @@c_employee                      );
    @_coll_insert.AssignVarLong("c_dogovor",                                @@_c_dogovor_labour               );
    @_coll_insert.AssignVarDate("op_day",                                   @@_op_day                         );
    @_coll_insert.SetVarMoney("ISum_LbrPaymentGROSS.isum",               @@_isum_vacation                  );
    @_coll_insert.SetVarMoney("ISum_LbrNDFL.isum",                       @@_isum_ndfl                      );
    @_coll_insert.SetVarMoney("ISum_LbrPaymentNET_FULL.isum",            @@_isum_vacation - @@_isum_ndfl   );
    @_coll_insert.SetVarMoney("ISum_LbrOverpay_VacationReserv.isum",     @@_isum_overpay_vacation          );
;
    @_coll_insert.AssignVarDate("Param_LabourVacationStart.param_value_d",  @@_date0                          );
    @_coll_insert.AssignVarDate("Param_LabourVacationFinish.param_value_d", @@_date1                          );
    
  $CURCFG::UK_Orders.DoInsertForColl(@@_coll_insert);

  Auth.delete_obj_by_name(@@_coll_insert);

  $LONG(_c_order)
  $CURCFG::UK_Orders.GetKeyLong("c_order", "_c_order");

  return(@@_c_order)
#}

;> ----------------------------------------------------------------------------
;> __employee_vacation_accept
;    выплата работнику отпуска
;> ----------------------------------------------------------------------------
const char _employee_vacation_accept_parms=\
#{";"
  _year:Год#Tlong_t
  _month:Месяц#Tlong_t
#}

const char _employee_vacation_accept=\
#{
  (@@_c_dogovor_labour == 0)
      ? RaiseError(-1, "С сотрудником [" + string(@@shname) + "] не заключен трудовой договор!", "")
      : 0;

; =====================================
; (vars) начало/окончание месяца
; =====================================
  $LONG(_cfdom,_cldom,_ldom)
    _cfdom    = rmdyjul(@@_month,  1, @@_year);
    _cldom    = CldGetLimit(@@_cfdom, "cldom");
    _ldom     = CldGetLimit(@@_cfdom, "ldom");


; -------------------------------------
; проверка на существование распоряжения на закрытие общих счетов 60335 (перечисления в фонды)
; его нужно создавать самым последним
; -------------------------------------
  call("$CURCFG::cmds_orders:_check_orders_on_unique", $ORDER_TYPE_EMPLOYEE_PAYMENT_TO_FUNDS, @@_cfdom, @@_cldom, 0, 0,            0, 0, $_TRUE);
  call("$CURCFG::cmds_orders:_check_orders_on_unique", $ORDER_TYPE_EMPLOYEE_CHECK_60335,      @@_cfdom, @@_cldom, 0, @@c_employee, 0, 0, $_TRUE);

; -------------------------------------
; 0. проверяем на наличие распоряжения на выплату отпускных, если не было - просто выходим без ошибок
; -------------------------------------
  $LONG(_quantity_vacation)
  _quantity_vacation = call("$CURCFG::cmds_orders:_check_orders_on_unique", $ORDER_TYPE_EMPLOYEE_VACATION_PAID, @@_cfdom, @@_cldom, 0, @@c_employee, 0, 0, $_FALSE);

  (@@_quantity_vacation == 0)
      ? return(0)
      : 0;

; -------------------------------------
; 1) считаем все отпускные выплаты и сопутствующие суммы за месяц
; -------------------------------------
  $MONEY(_full_vacation_gross,_full_vacation_net,_full_vacation_ndfl)
    _full_vacation_gross  = call("$CURCFG::$CURSEC:_calc_employee_vacation_isums", @@c_employee, @@_cfdom, @@_cldom, $SCHEMA_ISUM_LABOUR_PAYMENT_GROSS);
    _full_vacation_net    = call("$CURCFG::$CURSEC:_calc_employee_vacation_isums", @@c_employee, @@_cfdom, @@_cldom, $SCHEMA_ISUM_LABOUR_PAYMENT_NET_FULL);
    _full_vacation_ndfl   = call("$CURCFG::$CURSEC:_calc_employee_vacation_isums", @@c_employee, @@_cfdom, @@_cldom, $SCHEMA_ISUM_LABOUR_NDFL);

; -------------------------------------
; 2) считаем суммы страховых отчислений
; -------------------------------------
  $MONEY(_tax_fss_acc,_tax_ffoms)
    _tax_fss_acc = call("$CURCFG::cmds:get_setting_attr", $SETTING_PARAM_INS_FSSACC_TAX, $BRANCH_OUR, "value_m");
    _tax_ffoms   = call("$CURCFG::cmds:get_setting_attr", $SETTING_PARAM_INS_OMS_TAX,    $BRANCH_OUR, "value_m");

; -------------------------------------
; !!! 
; когда будет пересчет остатков, подставлять сюда итоговую сумму за год!
  $MONEY(_total_payments_year)
    _total_payments_year = call("$CURCFG::$CURSEC:_calc_paid_isum_of_period_before", @@_ldom, @@c_employee, "cfdoy");

; !!!
; -------------------------------------

  $MONEY(_insurance_pfr,_insurance_fss,_insurance_fss_acc,_insurance_ffoms)
    _insurance_pfr     = call("$CURCFG::cmds:_calc_complicated_ensuranse_isum", @@_full_vacation_gross, @@_total_payments_year, $SETTING_PARAM_INS_PFR_ISUM_BASE, $SETTING_PARAM_INS_PFR_TAX_BASE, $SETTING_PARAM_INS_PFR_TAX_EXTRA);
    _insurance_fss     = call("$CURCFG::cmds:_calc_complicated_ensuranse_isum", @@_full_vacation_gross, @@_total_payments_year, $SETTING_PARAM_INS_FSS_ISUM_BASE, $SETTING_PARAM_INS_FSS_TAX_BASE, $SETTING_PARAM_INS_FSS_TAX_EXTRA);
    _insurance_fss_acc = round(@@_full_vacation_gross * @@_tax_fss_acc * 0.01, 2);
    _insurance_ffoms   = round(@@_full_vacation_gross * @@_tax_ffoms   * 0.01, 2);


; -------------------------------------
; сумма переплаты по отпуску (когда резерва не хватило)
; ее необходимо начислить на расходы и закрыть счет 60306 (требование по работнику)
; -------------------------------------
  $MONEY(_isum_overpay_vacation)
    _isum_overpay_vacation = call("$CURCFG::$CURSEC:_get_employee_isum_from_order", @@c_employee, $ORDER_TYPE_EMPLOYEE_VACATION_PAID, $SCHEMA_ISUM_LABOUR_OVERPAY_VACATION, @@_cfdom, @@_cldom);


; -------------------------------------
; 3. создаем распоряжение
; -------------------------------------
  _coll_insert  = Auth.obj_by_name("<null>", "DB_Coll");
    @_coll_insert.ClearNames();
    @_coll_insert.AssignVarLong("order_type",                               $ORDER_TYPE_EMPLOYEE_VACATION_ACCEPT);
    @_coll_insert.AssignVarLong("c_curr",                                   $CURR_ROUBLE);
    @_coll_insert.AssignVarLong("c_employee",                               @@c_employee);
    @_coll_insert.AssignVarLong("c_dogovor",                                @@_c_dogovor_labour);
    @_coll_insert.AssignVarDate("op_day",                                   @@_ldom);
    
    @_coll_insert.SetVarMoney("ISum_LbrPaymentGROSS.isum",               @@_full_vacation_gross);
    @_coll_insert.SetVarMoney("ISum_LbrPaymentNET_FULL.isum",            @@_full_vacation_net);
    @_coll_insert.SetVarMoney("ISum_LbrNDFL.isum",                       @@_full_vacation_ndfl);

    @_coll_insert.SetVarMoney("ISum_LbrIns_PFR.isum",              @@_insurance_pfr);
    @_coll_insert.SetVarMoney("ISum_LbrIns_FSS.isum",              @@_insurance_fss);
    @_coll_insert.SetVarMoney("ISum_LbrIns_FSS_ACC.isum",          @@_insurance_fss_acc);
    @_coll_insert.SetVarMoney("ISum_LbrIns_OMS.isum",              @@_insurance_ffoms);

    @_coll_insert.SetVarMoney("ISum_LbrOverpay_VacationReserv.isum",     @@_isum_overpay_vacation          );

  $CURCFG::UK_Orders.DoInsertForColl(@@_coll_insert);

  Auth.delete_obj_by_name(@@_coll_insert);

  $LONG(_c_order)
  $CURCFG::UK_Orders.GetKeyLong("c_order", "_c_order");

  return(@@_c_order)
#}


;> ----------------------------------------------------------------------------
;> __employee_salary_adv
;    выплата работнику аванса (середина месяца)
;> ----------------------------------------------------------------------------
const char _employee_salary_adv_parms=\
#{";"
  _year:Год#Tlong_t
  _month:Месяц#Tlong_t
#}

const char _employee_salary_adv=\
#{
  (@@_c_dogovor_labour == 0)
      ? RaiseError(-1, "С сотрудником [" + string(@@shname) + "] не заключен трудовой договор!", "")
      : 0;

; =====================================
; (vars) начало/окончание месяца/день выплаты аванса
; =====================================
  $LONG(_cfdom,_cldom,_day_of_advance)
    _cfdom = rmdyjul(@@_month,  1, @@_year);
    _cldom = CldGetLimit(@@_cfdom, "cldom");
    _day_of_advance = call("$CURCFG::cmds:get_setting_attr", $SETTING_PARAM_ADVANCE_DAY,  @@c_branch, "value_i");

; -------------------------------------
; проверка на существование распоряжения на закрытие общих счетов 60335 (перечисления в фонды)
; его нужно создавать самым последним
; -------------------------------------
  call("$CURCFG::cmds_orders:_check_orders_on_unique", $ORDER_TYPE_EMPLOYEE_PAYMENT_TO_FUNDS, @@_cfdom, @@_cldom, 0, 0,            0, 0, $_TRUE);
  call("$CURCFG::cmds_orders:_check_orders_on_unique", $ORDER_TYPE_EMPLOYEE_CHECK_60335,      @@_cfdom, @@_cldom, 0, @@c_employee, 0, 0, $_TRUE);


; -------------------------------------
; проверка на уникальность (распоряжение на аванс может быть только одно за месяц!)
; в случае наличия - просто выходим
; -------------------------------------
  $LONG(_quantity_adv)
  _quantity_adv = call("$CURCFG::cmds_orders:_check_orders_on_unique", $ORDER_TYPE_EMPLOYEE_SALARY_ADV, @@_cfdom, @@_cldom, 0, @@c_employee, 0, 0, $_FALSE);

  (@@_quantity_adv == 0)
      ? 0
      : return(0);


; =====================================
; 1. определяем дату выплаты аванса
; =====================================

  $LONG(_date_advance,_count_w_advance)
  $CHAR(_clddays_calendar,_clddays_calendar_adv,_clddays_employee)
    _clddays_calendar     = call("dbores::BranchSelect:_get_cld_days_global",   @@_year, @@_month);
    _clddays_employee     = call("dbores::BranchSelect:_get_cld_days_employee", @@_year, @@_month, @@c_employee);
    _count_w_advance      = call("crbase::cmds:_get_count_of_typed_days_in_clddays", substr(@@_clddays_employee, 0, 15), "$WORK_DAYS_SYMB");

    _clddays_calendar_adv = substr(@@_clddays_calendar, (@@_day_of_advance-1), 1);
    _date_advance         = rmdyjul(@@_month,  @@_day_of_advance, @@_year);
    _date_advance         = (@@_clddays_calendar_adv == "h") ? PeriodPrevDay(@@_date_advance) : @@_date_advance;


; -------------------------------------
; сумма вычета
; -------------------------------------
  $MONEY(_ndfl_reduction)
  -SQL
    select isum into ?_ndfl_reduction
    from $uk_employees_isums
    where
      c_employee = @c_employee and
      isum_type  = $ISUMEMPLOYEE_TYPE_NDFL_REDUCTION and
      @_date_advance between prev_change and next_change;
  _ndfl_reduction = isnull(@@_ndfl_reduction) ? 0 : @@_ndfl_reduction;

; -------------------------------------
; 2. вычисляем сумму аванса и налог с неё
;    вычет по уходу за детьми полностью прменяется к авансовому платежу !!!
; -------------------------------------
  $MONEY(_tax_ndfl,_advance_gross,_advance_ndfl)
    _tax_ndfl      = call("$CURCFG::cmds:get_setting_attr", $SETTING_PARAM_TAX_NDFL,  @@c_branch, "value_m");
    _advance_gross = call("$CURCFG::$CURSEC:_calc_employee_isum_for_work_days", @@c_employee, $ISUMEMPLOYEE_TYPE_SALARY_GROSS,   @@_year, @@_month, 15);
    _advance_ndfl  = (@@_advance_gross == 0)
                            ? 0
                            : round((@@_advance_gross - @@_ndfl_reduction) * @@_tax_ndfl * 0.01, 0);


; -------------------------------------
; 3. создаем распоряжение
; -------------------------------------
  _coll_insert  = Auth.obj_by_name("<null>", "DB_Coll");
    @_coll_insert.ClearNames();
    @_coll_insert.AssignVarLong("order_type",                               $ORDER_TYPE_EMPLOYEE_SALARY_ADV);
    @_coll_insert.AssignVarLong("c_curr",                                   $CURR_ROUBLE);
    @_coll_insert.AssignVarLong("c_employee",                               @@c_employee);
    @_coll_insert.AssignVarLong("c_dogovor",                                @@_c_dogovor_labour);
    @_coll_insert.AssignVarDate("op_day",                                   @@_date_advance);
    @_coll_insert.SetVarMoney("ISum_LbrPaymentNET_ADV.isum",       @@_advance_gross - @@_advance_ndfl);

    @_coll_insert.SetVarLong("Param_Labour_Days_Of_Payment.param_value_i",  @@_count_w_advance);
    
  $CURCFG::UK_Orders.DoInsertForColl(@@_coll_insert);

  Auth.delete_obj_by_name(@@_coll_insert);

  $LONG(_c_order)
  $CURCFG::UK_Orders.GetKeyLong("c_order", "_c_order");

  return(@@_c_order)
#}

;> ----------------------------------------------------------------------------
;> __employee_salary_pri
;    выплата работнику получки (конец месяца)
;> ----------------------------------------------------------------------------
const char _employee_salary_pri_parms=\
#{";"
  _year:Год#Tlong_t
  _month:Месяц#Tlong_t
#}

const char _employee_salary_pri=\
#{
  (@@_c_dogovor_labour == 0)
      ? RaiseError(-1, "С сотрудником [" + string(@@shname) + "] не заключен трудовой договор!", "")
      : 0;

; =====================================
; (vars) начало/окончание месяца/день выплаты аванса
; =====================================
  $LONG(_cfdom,_cldom,_ldom,_date_15)
    _cfdom    = rmdyjul(@@_month,  1, @@_year);
    _cldom    = CldGetLimit(@@_cfdom, "cldom");
    _ldom     = CldGetLimit(@@_cfdom, "ldom");
    _date_15  = rmdyjul(@@_month,  15, @@_year);

  $LONG(_day_cldom,_month_cldom,_year_cldom)
    rjulmdy(@@_cldom, "_month_cldom", "_day_cldom", "_year_cldom");

  $LONG(_day_ldom,_month_ldom,_year_ldom)
    rjulmdy(@@_ldom, "_month_ldom", "_day_ldom", "_year_ldom");


; -------------------------------------
; проверка на существование распоряжения на закрытие общих счетов 60335 (перечисления в фонды)
; его нужно создавать самым последним
; -------------------------------------
  call("$CURCFG::cmds_orders:_check_orders_on_unique", $ORDER_TYPE_EMPLOYEE_PAYMENT_TO_FUNDS, @@_cfdom, @@_cldom, 0, 0,            0, 0, $_TRUE);
  call("$CURCFG::cmds_orders:_check_orders_on_unique", $ORDER_TYPE_EMPLOYEE_CHECK_60335,      @@_cfdom, @@_cldom, 0, @@c_employee, 0, 0, $_TRUE);


; -------------------------------------
; 0. проверяем на наличие распоряжения на аванс (при условии, что работник работал до 15-ого числа)
; -------------------------------------
  $LONG(_is_raise_error)
  $LONG(_quantity_adv)
    _is_raise_error = ((@@_dog_labour_date0 > @@_date_15) || (@@_salary_today == 0)) ? $_FALSE : $_TRUE;
    _quantity_adv   = call("$CURCFG::cmds_orders:_check_orders_on_unique", $ORDER_TYPE_EMPLOYEE_SALARY_ADV, @@_cfdom, @@_cldom, 0, @@c_employee, 0, 1, @@_is_raise_error);


; -------------------------------------
; 0. проверяем на наличие распоряжения на получку, если было - то просто выходим без ошибок
; -------------------------------------
  $LONG(_quantity_pri)
    _quantity_pri = call("$CURCFG::cmds_orders:_check_orders_on_unique", $ORDER_TYPE_EMPLOYEE_SALARY_PRI, @@_cfdom, @@_cldom, 0, @@c_employee, 0, 0, $_FALSE);

  (@@_quantity_pri == 0)
      ? 0
      : return(0);


; -------------------------------------
; сумма вычета
; -------------------------------------
  $MONEY(_ndfl_reduction)
  -SQL
    select isum into ?_ndfl_reduction
    from $uk_employees_isums
    where
      c_employee = @c_employee and
      isum_type  = $ISUMEMPLOYEE_TYPE_NDFL_REDUCTION and
      @_ldom between prev_change and next_change;
  _ndfl_reduction = isnull(@@_ndfl_reduction) ? 0 : @@_ndfl_reduction;

; -------------------------------------
; сумма перечисления в ПФР (раз в год)
; -------------------------------------
  $MONEY(_pfr_deduction)
  -SQL
    select isum into ?_pfr_deduction
    from $uk_employees_isums
    where
      c_employee = @c_employee and
      isum_type  = $ISUMEMPLOYEE_TYPE_PFR_DEDUCTION and
      @_ldom between prev_change and next_change;
  _pfr_deduction = isnull(@@_pfr_deduction) ? 0 : @@_pfr_deduction ;


; -------------------------------------
; 1) считаем основные суммы по авансу/получке: 
;             - полную з/п за месяц (gross) + налог с неё => чистую сумму в месяц
;             - фактически перечисленную сумму аванса     => чистую сумму за вторую половину
;             - учитываем вычет по уходу за ребенком (при условии, что не было авансового платежа, 
;                                                     т.к. вычет учитывается только один раз в месяц и полностью!!! )
; -------------------------------------
  $MONEY(_before_payments_month,_before_ndfl_month)
  $MONEY(_tax_ndfl,_full_gross,_full_ndfl,_full_net,_advance_net,_pri_net)
    _tax_ndfl             = call("$CURCFG::cmds:get_setting_attr", $SETTING_PARAM_TAX_NDFL,  @@c_branch, "value_m");
    _full_gross           = call("$CURCFG::$CURSEC:_calc_employee_isum_for_work_days", @@c_employee, $ISUMEMPLOYEE_TYPE_SALARY_GROSS, @@_year, @@_month, @@_day_cldom);

; -------------------------------------
; доп. суммы и налоги, уже выплаченные в текущем месяце
; (нужно т.к. НДФЛ считается по итоговой(!) сумме за месяц, иначе м.б. ошибки округления от одного рубля)
; -------------------------------------
    _before_payments_month = call("$CURCFG::$CURSEC:_calc_paid_isum_of_period_before", @@_ldom, @@c_employee, "cfdom");
    _before_ndfl_month     = call("$CURCFG::$CURSEC:_get_sum_for_employee_for_period", @@c_employee, @@_cfdom, @@_cldom, 
                                                                                       "$ORDER_TYPE_EMPLOYEE_VACATION_PAID,$ORDER_TYPE_EMPLOYEE_EXTRA_MONEY,$ORDER_TYPE_EMPLOYEE_EXTRA_MONEY_WO_FUNDS",
                                                                                       $SCHEMA_ISUM_LABOUR_NDFL);
; -------------------------------------
; !!! 
; -------------------------------------
    _full_ndfl             = round((@@_before_payments_month + @@_full_gross - @@_ndfl_reduction) * @@_tax_ndfl * 0.01, 0) - @@_before_ndfl_month;

    _full_net       = @@_full_gross - @@_full_ndfl - @@_pfr_deduction;
    _advance_net    = call("$CURCFG::$CURSEC:_get_employee_isum_from_order", @@c_employee, $ORDER_TYPE_EMPLOYEE_SALARY_ADV, $SCHEMA_ISUM_LABOUR_PAYMENT_NET_ADV, @@_cfdom, @@_cldom);
    _pri_net        = @@_full_net - @@_advance_net;

  $CHAR(_clddays_employee)
  $LONG(_count_w_pri)
    _clddays_employee = call("dbores::BranchSelect:_get_cld_days_employee", @@_year, @@_month, @@c_employee);
    _count_w_pri = call("crbase::cmds:_get_count_of_typed_days_in_clddays", substr(@@_clddays_employee, 15, (@@_day_cldom - 15)), "$WORK_DAYS_SYMB");

; -------------------------------------
; 2) считаем суммы страховых отчислений
; -------------------------------------
  $MONEY(_tax_fss_acc,_tax_ffoms)
    _tax_fss_acc = call("$CURCFG::cmds:get_setting_attr", $SETTING_PARAM_INS_FSSACC_TAX, $BRANCH_OUR, "value_m");
    _tax_ffoms   = call("$CURCFG::cmds:get_setting_attr", $SETTING_PARAM_INS_OMS_TAX,    $BRANCH_OUR, "value_m");

; -------------------------------------
; !!! 
; когда будет пересчет остатков, подставлять сюда итоговую сумму за год!
; -------------------------------------
  $MONEY(_total_payments_year)
    _total_payments_year  = call("$CURCFG::$CURSEC:_calc_paid_isum_of_period_before", @@_ldom, @@c_employee, "cfdoy");

  $MONEY(_insurance_pfr,_insurance_fss,_insurance_fss_acc,_insurance_ffoms)
    _insurance_pfr     = call("$CURCFG::cmds:_calc_complicated_ensuranse_isum", @@_full_gross, @@_total_payments_year, $SETTING_PARAM_INS_PFR_ISUM_BASE, $SETTING_PARAM_INS_PFR_TAX_BASE, $SETTING_PARAM_INS_PFR_TAX_EXTRA);
    _insurance_fss     = call("$CURCFG::cmds:_calc_complicated_ensuranse_isum", @@_full_gross, @@_total_payments_year, $SETTING_PARAM_INS_FSS_ISUM_BASE, $SETTING_PARAM_INS_FSS_TAX_BASE, $SETTING_PARAM_INS_FSS_TAX_EXTRA);
    _insurance_fss_acc = round(@@_full_gross * @@_tax_fss_acc * 0.01, 2);
    _insurance_ffoms   = round(@@_full_gross * @@_tax_ffoms   * 0.01, 2);

; -------------------------------------
; 3. создаем распоряжение
; -------------------------------------
  _coll_insert  = Auth.obj_by_name("<null>", "DB_Coll");
  @_coll_insert.ClearNames();
    @_coll_insert.AssignVarLong("order_type",                               $ORDER_TYPE_EMPLOYEE_SALARY_PRI);
    @_coll_insert.AssignVarLong("c_curr",                                   $CURR_ROUBLE);
    @_coll_insert.AssignVarLong("c_employee",                               @@c_employee);
    @_coll_insert.AssignVarLong("c_dogovor",                                @@_c_dogovor_labour);
    @_coll_insert.AssignVarDate("op_day",                                   @@_ldom);
    
    @_coll_insert.SetVarMoney("ISum_LbrPaymentGROSS.isum",         @@_full_gross);
    @_coll_insert.SetVarMoney("ISum_LbrPaymentNET_ADV.isum",       @@_advance_net);
    @_coll_insert.SetVarMoney("ISum_LbrNDFL.isum",                 @@_full_ndfl);
    @_coll_insert.SetVarMoney("ISum_LbrPaymentNET_PRI.isum",       @@_pri_net);
    @_coll_insert.SetVarMoney("ISum_LbrPFR_Deduction.isum",        @@_pfr_deduction);

    @_coll_insert.SetVarMoney("ISum_LbrIns_PFR.isum",        @@_insurance_pfr);
    @_coll_insert.SetVarMoney("ISum_LbrIns_FSS.isum",        @@_insurance_fss);
    @_coll_insert.SetVarMoney("ISum_LbrIns_FSS_ACC.isum",    @@_insurance_fss_acc);
    @_coll_insert.SetVarMoney("ISum_LbrIns_OMS.isum",        @@_insurance_ffoms);

    @_coll_insert.SetVarLong("Param_Labour_Days_Of_Payment.param_value_i",  @@_count_w_pri);
    
; -------------------------------------
; вставляем, только если сумма больше нуля 
; -------------------------------------
  (@@_full_gross == 0)
      ? 0
      : $CURCFG::UK_Orders.DoInsertForColl(@@_coll_insert);

  Auth.delete_obj_by_name(@@_coll_insert);


; -------------------------------------
; 0. проверяем на наличие распоряжения на детские выплаты, если было - то просто выходим без ошибок
; -------------------------------------
  $LONG(_quantity_child)
    _quantity_child = call("$CURCFG::cmds_orders:_check_orders_on_unique", $ORDER_TYPE_EMPLOYEE_CHILD_PAYMENT, @@_cfdom, @@_cldom, 0, @@c_employee, 0, 0, $_FALSE);

  (@@_quantity_child == 0)
      ? 0
      : return(0);


; -------------------------------------
; сразу пытаемся сформировать распоряжение для декретчиц
; -------------------------------------
  $MONEY(_child_payment_firm,_child_payment_fss,_child_payment_fss_to_order,_child_payment)
    _child_payment_firm         = call("$CURCFG::cmds:get_setting_attr", $SETTING_PARAM_CHILD_ISUM_FIRM,  @@c_branch, "value_m");
    _child_payment_fss          = call("$CURCFG::$CURSEC:_calc_employee_isum_for_calendar_days", @@c_employee, $ISUMEMPLOYEE_TYPE_CHILD_FSS, @@_year, @@_month, @@_day_cldom);

; трюк для декретчиц (чтобы не вводить новые состояния и суммы), когда выплаты фсс заканчиваются -
; делать сумму отрицательной - тогда будет распоряжение только  суммой от фирмы (т.к. проверка на ноль)
    _child_payment_fss_to_order = (@@_child_payment_fss < 0) ? 0 : @@_child_payment_fss;

  _coll_insert  = Auth.obj_by_name("<null>", "DB_Coll");
  @_coll_insert.ClearNames();
    @_coll_insert.AssignVarLong("order_type",                               $ORDER_TYPE_EMPLOYEE_CHILD_PAYMENT);
    @_coll_insert.AssignVarLong("c_curr",                                   $CURR_ROUBLE);
    @_coll_insert.AssignVarLong("c_employee",                               @@c_employee);
    @_coll_insert.AssignVarLong("c_dogovor",                                @@_c_dogovor_labour);
    @_coll_insert.AssignVarDate("op_day",                                   @@_ldom);
    
    @_coll_insert.SetVarMoney("ISum_Lbr_Child_Fss.isum",           @@_child_payment_fss_to_order);
    @_coll_insert.SetVarMoney("ISum_Lbr_Child_Firm.isum",          @@_child_payment_firm);
    @_coll_insert.SetVarMoney("ISum_Lbr_Child_Summary.isum",       @@_child_payment_firm + @@_child_payment_fss_to_order);
; -------------------------------------
; вставляем, только если сумма больше нуля 
; -------------------------------------
  (@@_child_payment_fss == 0)
      ? 0
      : $CURCFG::UK_Orders.DoInsertForColl(@@_coll_insert);

  Auth.delete_obj_by_name(@@_coll_insert);
#}


;> ----------------------------------------------------------------------------
;> __get_employee_isum_from_order
;    находим сумму аванса по работнику из распоряжения
;> ----------------------------------------------------------------------------
const char _get_employee_isum_from_order_parms=_c_employee,_order_type,_isum_type,_date0,_date1
const char _get_employee_isum_from_order=\
#{
  -SQL drop table tmp_orders_search;
  SQL
     select o.c_order 
     from $uk_orders_def o
     where
       o.c_employee = @_c_employee and
       o.order_type = @_order_type and
       o.state      > $ORDER_STATE_DELETED and
       o.op_day between @_date0 and @_date1
     into temp tmp_orders_search with no log;
  SQL create unique index idx_tmp_orders_search_0 on tmp_orders_search (c_order);
  SQL update statistics high for table tmp_orders_search (c_order);

; -------------------------------------
; сумма может быть нулевой (отсутствовать запись), например у декретниц
; -------------------------------------
  $MONEY(_isum_search)
  SQL
    select nvl(s.isum, 0) into ?_isum_search
    from tmp_orders_search t
      left join $uk_orders_isums s on s.c_order = t.c_order and s.isum_type = @_isum_type;

  SQL drop table tmp_orders_search; 
  
  return(@@_isum_search);
#}



;> ----------------------------------------------------------------------------
;> __calc_employee_isum_for_work_days
;    вычисление суммы з/п по работнику за месяц
;    (_day2 определяет посл. день периода: 15-аванс/cldom-полную за месяц)
;    (!!! на основании рабочих дней !!!)
;> ----------------------------------------------------------------------------
const char _calc_employee_isum_for_work_days_parms=_c_employee,_isum_type,_year,_month,_day2
const char _calc_employee_isum_for_work_days=\
#{
; -------------------------------------
; количество рабочих дней в календарном  месяце
; -------------------------------------
  $CHAR(_clddays_global)
  $LONG(_count_w_month)
    _clddays_global   = call("dbores::BranchSelect:_get_cld_days_global", @@_year, @@_month);
    _count_w_month    = call("crbase::cmds:_get_count_of_typed_days_in_clddays", @@_clddays_global, "$WORK_DAYS_SYMB");


; -------------------------------------
; т.к. з/п может меняться в течение месяца считаем за каждый день авансового периода
; -------------------------------------


; ---------------------------
; производственный календарь работника (м.б. отпуска и больничные)
; ---------------------------
  $CHAR(_clddays_employee)
    _clddays_employee = call("dbores::BranchSelect:_get_cld_days_employee", @@_year, @@_month, @@_c_employee);
    _clddays_employee = substr(@@_clddays_employee, 0, @@_day2);

  $DEC(__employee_isum)
    __employee_isum = 0;

; ---------------------------
; цикл по каждому дню месяца
; (для осуществления цикла - трюк с таблицей с первыми датами годов)
; ---------------------------
  $LONG(_day)
  CURSOR
    select year(y.cfdoy) - 2000 into ?_day
    from $utl_year_dates y
    where
      y.cfdoy between "01.01.2001" and "01.01.20@{_day2}"
    : call("$CURCFG::$CURSEC:_calc_one_day_in_cld_days", @@_c_employee, @@_isum_type, @@_clddays_employee, @@_day, @@_month, @@_year, @@_count_w_month, "w");

  return(round(@@__employee_isum, 2));
#}

;> ----------------------------------------------------------------------------
;> __calc_employee_isum_for_calendar_days
;    вычисление суммы по работнику за календарный месяц
;> ----------------------------------------------------------------------------
const char _calc_employee_isum_for_calendar_days_parms=_c_employee,_isum_type,_year,_month,_day2
const char _calc_employee_isum_for_calendar_days=\
#{
; -------------------------------------
; количество рабочих дней в календарном  месяце
; -------------------------------------
  $CHAR(_clddays_global)
  $LONG(_count_days_month)
    _clddays_global = call("dbores::BranchSelect:_get_cld_days_global", @@_year, @@_month);
    _count_days_month = strlen(@@_clddays_global);


; -------------------------------------
; т.к. сумма может меняться в течение периода считаем за каждый день авансового периода
; -------------------------------------


  $DEC(__employee_isum)
    __employee_isum = 0;

; ---------------------------
; цикл по каждому дню месяца
; (для осуществления цикла - трюк с таблицей с первыми датами годов)
; ---------------------------
  $LONG(_day)
  CURSOR
    select year(y.cfdoy) - 2000 into ?_day
    from $utl_year_dates y
    where
      y.cfdoy between "01.01.2001" and "01.01.20@{_day2}"
    : call("$CURCFG::$CURSEC:_calc_one_day_in_cld_days", @@_c_employee, @@_isum_type, @@_clddays_global, @@_day, @@_month, @@_year, @@_count_days_month, "*");

  return(round(@@__employee_isum, 2));
#}


;> ----------------------------------------------------------------------------
;> __calc_one_day_in_cld_days
;    вычисление суммы аванса по работнику
;> ----------------------------------------------------------------------------
const char _calc_one_day_in_cld_days_parms=__c_employee,__isum_type,__clddays,__day,__month,__year,__count_w,__letter
const char _calc_one_day_in_cld_days=\
#{
  $CHAR(__day_letter)
  $LONG(__op_day)
    __day_letter = substr(@@__clddays, (@@__day-1), 1);
    __op_day     = rmdyjul(@@__month,  @@__day, @@__year);

 
; -------------------------------------
; сумма оклада на одну дату (с большой точностью, чтобы не было ошибки округления)
; -------------------------------------
  $MONEY(__isum_today)
  
  -SQL
    select e.isum into ?__isum_today
    from $uk_employees_def d
      join $uk_employees_isums e on
                                    e.c_employee = d.c_employee and
                                    e.isum_type  = @__isum_type and
                                    @__op_day between e.prev_change and e.next_change
    where
      d.c_employee = @__c_employee;
  __isum_today = isnull(@@__isum_today) ? 0 : @@__isum_today;

; -------------------------------------
; сумма за один день
; (если на входе "*" - то прибавляем всегда)
; -------------------------------------
  $DEC(__isum_for_one_day)
    __isum_for_one_day = (@@__letter     == "*")        ? round(@@__isum_today / @@__count_w, 6) : 0;
    __isum_for_one_day = (@@__day_letter == @@__letter) ? round(@@__isum_today / @@__count_w, 6) : @@__isum_for_one_day;

  __employee_isum = @@__employee_isum + @@__isum_for_one_day;
#}


;> ----------------------------------------------------------------------------
;> __calc_employee_vacation_isums
;    вычисление суммы аванса по работнику
;> ----------------------------------------------------------------------------
const char _calc_employee_vacation_isums_parms=__c_employee,__date0,__date1,__isum_type
const char _calc_employee_vacation_isums=\
#{
  $MONEY(__isum_vacation)

  -SQL
    select sum(s.isum) into ?__isum_vacation
    from $uk_orders_def o
      join $uk_orders_isums s on s.c_order = o.c_order and s.isum_type = @__isum_type
    where
      o.c_employee = @__c_employee and
      o.op_day between @__date0 and @__date1 and
      o.order_type  = $ORDER_TYPE_EMPLOYEE_VACATION_PAID and
      o.state not in ($ORDER_STATE_DELETED);
  __isum_vacation = isnull(@@__isum_vacation) ? 0 : @@__isum_vacation;

  return(@@__isum_vacation);
#}

;> ----------------------------------------------------------------------------
;> __employee_pay_fin_help
;    материальная помощь (без налогов и отчислений)
;> ----------------------------------------------------------------------------
const char _employee_pay_fin_help_parms=\
#{";"
  _op_day:Дата#Tdate_t
  _isum_extra:Сумма#Tmoney_t
#}

const char _employee_pay_fin_help=\
#{
  (@@_c_dogovor_labour == 0)
      ? RaiseError(-1, "С сотрудником [" + string(@@shname) + "] не заключен трудовой договор!", "")
      : 0;

; -------------------------------------
; создаем распоряжение
; -------------------------------------
  _coll_insert  = Auth.obj_by_name("<null>", "DB_Coll");
    @_coll_insert.ClearNames();
    @_coll_insert.AssignVarLong("order_type",                           $ORDER_TYPE_EMPLOYEE_FIN_HELP);
    @_coll_insert.AssignVarLong("c_curr",                               $CURR_ROUBLE);
    @_coll_insert.AssignVarLong("c_employee",                           @@c_employee);
    @_coll_insert.AssignVarLong("c_dogovor",                            @@_c_dogovor_labour);
    @_coll_insert.AssignVarDate("op_day",                               @@_op_day);
    @_coll_insert.SetVarMoney("ISum_LbrPaymentNET_FULL.isum",  @@_isum_extra);
  $CURCFG::UK_Orders.DoInsertForColl(@@_coll_insert);
  Auth.delete_obj_by_name(@@_coll_insert);
#}

;> ----------------------------------------------------------------------------
;> __employee_pay_extra_money
;    начисление резерва в начале года по предстоящим отпускам работника
;> ----------------------------------------------------------------------------
const char _employee_pay_extra_money_parms=\
#{";"
  _op_day:Дата#Tdate_t
  _isum_extra:Сумма#Tmoney_t
#}

const char _employee_pay_extra_money=\
#{
  (@@_c_dogovor_labour == 0)
      ? RaiseError(-1, "С сотрудником [" + string(@@shname) + "] не заключен трудовой договор!", "")
      : 0;


; -------------------------------------
  $MONEY(_tax_ndfl,_full_ndfl,_full_net)
    _tax_ndfl       = call("$CURCFG::cmds:get_setting_attr", $SETTING_PARAM_TAX_NDFL,  @@c_branch, "value_m");
    _full_ndfl      = round(@@_isum_extra * @@_tax_ndfl * 0.01, 0);
    _full_net       = @@_isum_extra - @@_full_ndfl;

; -------------------------------------
; 2) считаем суммы страховых отчислений
; -------------------------------------
  $MONEY(_tax_fss_acc,_tax_ffoms)
    _tax_fss_acc = call("$CURCFG::cmds:get_setting_attr", $SETTING_PARAM_INS_FSSACC_TAX, $BRANCH_OUR, "value_m");
    _tax_ffoms   = call("$CURCFG::cmds:get_setting_attr", $SETTING_PARAM_INS_OMS_TAX,    $BRANCH_OUR, "value_m");

; -------------------------------------
; !!! 
; когда будет пересчет остатков, подставлять сюда итоговую сумму за год!
; -------------------------------------
  $MONEY(_total_payments_year)
    _total_payments_year = call("$CURCFG::$CURSEC:_calc_paid_isum_of_period_before", long(@@_op_day), @@c_employee, "cfdoy");

  $MONEY(_insurance_pfr,_insurance_fss,_insurance_fss_acc,_insurance_ffoms)
    _insurance_pfr     = call("$CURCFG::cmds:_calc_complicated_ensuranse_isum", @@_isum_extra, @@_total_payments_year, $SETTING_PARAM_INS_PFR_ISUM_BASE, $SETTING_PARAM_INS_PFR_TAX_BASE, $SETTING_PARAM_INS_PFR_TAX_EXTRA);
    _insurance_fss     = call("$CURCFG::cmds:_calc_complicated_ensuranse_isum", @@_isum_extra, @@_total_payments_year, $SETTING_PARAM_INS_FSS_ISUM_BASE, $SETTING_PARAM_INS_FSS_TAX_BASE, $SETTING_PARAM_INS_FSS_TAX_EXTRA);
    _insurance_fss_acc = round(@@_isum_extra * @@_tax_fss_acc * 0.01, 2);
    _insurance_ffoms   = round(@@_isum_extra * @@_tax_ffoms   * 0.01, 2);

; -------------------------------------
; 3. создаем распоряжение
; -------------------------------------
  _coll_insert  = Auth.obj_by_name("<null>", "DB_Coll");
  @_coll_insert.ClearNames();
    @_coll_insert.AssignVarLong("order_type",                         @@_order_type);
    @_coll_insert.AssignVarLong("c_curr",                             $CURR_ROUBLE);
    @_coll_insert.AssignVarLong("c_employee",                         @@c_employee);
    @_coll_insert.AssignVarLong("c_dogovor",                          @@_c_dogovor_labour);
    @_coll_insert.AssignVarDate("op_day",                             @@_op_day);
    
    @_coll_insert.SetVarMoney("ISum_LbrPaymentGROSS.isum",         @@_isum_extra);
    @_coll_insert.SetVarMoney("ISum_LbrNDFL.isum",                 @@_full_ndfl);
    @_coll_insert.SetVarMoney("ISum_LbrPaymentNET_FULL.isum",      @@_full_net);

    (@@_order_type==$ORDER_TYPE_EMPLOYEE_EXTRA_MONEY) ? @_coll_insert.SetVarMoney("ISum_LbrIns_PFR.isum",      @@_insurance_pfr)     : 0;
    (@@_order_type==$ORDER_TYPE_EMPLOYEE_EXTRA_MONEY) ? @_coll_insert.SetVarMoney("ISum_LbrIns_FSS.isum",      @@_insurance_fss)     : 0;
    (@@_order_type==$ORDER_TYPE_EMPLOYEE_EXTRA_MONEY) ? @_coll_insert.SetVarMoney("ISum_LbrIns_FSS_ACC.isum",  @@_insurance_fss_acc) : 0;
    (@@_order_type==$ORDER_TYPE_EMPLOYEE_EXTRA_MONEY) ? @_coll_insert.SetVarMoney("ISum_LbrIns_OMS.isum",      @@_insurance_ffoms)   : 0;

; -------------------------------------
; вставляем, только если сумма больше нуля 
; -------------------------------------
  (@@_isum_extra == 0)
      ? 0
      : $CURCFG::UK_Orders.DoInsertForColl(@@_coll_insert);

  Auth.delete_obj_by_name(@@_coll_insert);
#}

;> ----------------------------------------------------------------------------
;> __employee_illness
;    выплата работнику больничного
;> ----------------------------------------------------------------------------
const char _employee_illness_parms=\
#{";"
  _op_day:Дата выплаты#Tdate_t
  _date0:Начало больничного#Tdate_t
  _date1:Окончание больничного#Tdate_t
  _isum_fss:Сумма за счет ФСС#Tmoney_t
  _isum_firm:Сумма за счет фирмы#Tmoney_t
#}

const char _employee_illness=\
#{
  (@@_c_dogovor_labour == 0)
      ? RaiseError(-1, "С сотрудником [" + string(@@shname) + "] не заключен трудовой договор!", "")
      : 0;

; -------------------------------------
; проверка на существование распоряжения на закрытие общих счетов 60335 (перечисления в фонды)
; его нужно создавать самым последним
; -------------------------------------
  $LONG(_cfdom,_cldom)
    _cfdom = CldGetLimit(@@_op_day, "cfdom");
    _cldom = CldGetLimit(@@_op_day, "cldom");
  call("$CURCFG::cmds_orders:_check_orders_on_unique", $ORDER_TYPE_EMPLOYEE_PAYMENT_TO_FUNDS, @@_cfdom, @@_cldom, 0, 0,            0, 0, $_TRUE);
  call("$CURCFG::cmds_orders:_check_orders_on_unique", $ORDER_TYPE_EMPLOYEE_CHECK_60335,      @@_cfdom, @@_cldom, 0, @@c_employee, 0, 0, $_TRUE);

  $MONEY(_isum_illness,_tax_ndfl,_isum_ndfl)
    _isum_illness = @@_isum_fss + @@_isum_firm;
    _tax_ndfl     = call("$CURCFG::cmds:get_setting_attr", $SETTING_PARAM_TAX_NDFL,  @@c_branch, "value_m");
    _isum_ndfl    = round(@@_isum_illness * @@_tax_ndfl * 0.01, 0);

; -------------------------------------
; создаем распоряжение
; -------------------------------------
  _coll_insert  = Auth.obj_by_name("<null>", "DB_Coll");
    @_coll_insert.ClearNames();
    @_coll_insert.AssignVarLong("order_type",                               $ORDER_TYPE_EMPLOYEE_ILLNESS);
    @_coll_insert.AssignVarLong("c_curr",                                   $CURR_ROUBLE);
    @_coll_insert.AssignVarLong("c_employee",                               @@c_employee);
    @_coll_insert.AssignVarLong("c_dogovor",                                @@_c_dogovor_labour);
    @_coll_insert.AssignVarDate("op_day",                                   @@_op_day);
    @_coll_insert.SetVarMoney("ISum_Lbr_Illness_Fss.isum",         @@_isum_fss);
    @_coll_insert.SetVarMoney("ISum_Lbr_Illness_Firm.isum",        @@_isum_firm);
    @_coll_insert.SetVarMoney("ISum_LbrNDFL.isum",                 @@_isum_ndfl);
    @_coll_insert.SetVarMoney("ISum_LbrPaymentNET_FULL.isum",      @@_isum_illness - @@_isum_ndfl);
    @_coll_insert.SetVarMoney("ISum_LbrPaymentGROSS.isum",         @@_isum_illness);
    @_coll_insert.AssignVarDate("Param_LabourIllnessStart.param_value_d",   @@_date0);
    @_coll_insert.AssignVarDate("Param_LabourIllnessFinish.param_value_d",  @@_date1);
    
  $CURCFG::UK_Orders.DoInsertForColl(@@_coll_insert);

  Auth.delete_obj_by_name(@@_coll_insert);

  $LONG(_c_order)
  $CURCFG::UK_Orders.GetKeyLong("c_order", "_c_order");

  return(@@_c_order)
#}



[UK_Employees_WorkInfo] default: $CURCFG::UK_Contractors_Tpl
const char ks_table=$uk_employees_work_info
const char ks_keys=c_employee
const char history=change:prev_change/next_change
const char query_defaults=\
#{";"
  prev_change:@today
  next_change:$DayMax
#}
const char ks_defaults=\
#{";"
  c_firm:0
  pers_number:0
  c_department:0
  position:0
#}

const char foreigns=\
#{";"
  Firm($CURCFG::UK_Abbrs_Firms):c_firm(type)
  Department($CURCFG::UK_Abbrs_Departments):c_department(type)
#}


[UK_Employees_BankDetails] default: $CURCFG::UK_Contractors_Tpl
const char ks_table=$uk_employees_bank_details
const char ks_keys=c_employee
const char history=change:prev_change/next_change
const char query_defaults=\
#{";"
  prev_change:@today
  next_change:$DayMax
#}

const char masters=\
#{";"
  BankDetails($CURCFG::UK_BankDetails):c_bank_detail
#}

[UK_Employees_Accnts] default: $CURCFG::UK_Contractors_Tpl
const char ks_table=$uk_employees_accnts
const char ks_keys=c_employee,accnt_type,prev_change
const char ks_defaults=\
#{";"
  c_employee:0
  accnt_type:0
  c_accnt:0
  prev_change:@today
  next_change:$DayMax
#}

const char foreigns=\
#{";"
  Employee($CURCFG::UK_Employees_Def):c_employee
  Type($CURCFG::UK_Abbrs_AccntEmployeeTypes):accnt_type(type)
; -------------------------------------
;  Accnt:c_accnt
  Accnt(AccntDay):c_accnt,prev_change(#today)
#}

[UK_Employees_Accnts_For_Branch]
const char main_class=DB_Kscurs
const char parent_kstat=$CURCFG::UK_Employees_Accnts_Actual
const char ks_where=@BranchSelect.c_branch in ($BRANCH_CONS, [Employee.c_branch])

[UK_Employees_Accnts_Actual]
const char main_class=DB_Kscurs
const char parent_kstat=$CURCFG::UK_Employees_Accnts
const char history=change:prev_change/next_change
const char ks_keys=c_employee,accnt_type
const char query_defaults=\
#{";"
  prev_change:@today
  next_change:$DayMax
#}


[UK_Employees_Isums] default: $CURCFG::UK_Contractors_Tpl
const char ks_table=$uk_employees_isums
char ks_keys=c_employee,isum_type,next_change
const char ks_defaults=\
#{";"
  c_employee:0
  isum_type:0
  isum:0
  prev_change:@today
  next_change:$DayMax
#}

const char foreigns=\
#{";"
  IsumType($CURCFG::UK_Abbrs_IsumEmployeeTypes):isum_type(type)
#}

[UK_Employees_IsumsDay] default: $CURCFG::UK_Employees_Isums
const char ks_keys=c_employee,isum_type,#today
const char pseudo_keys=\
#{
  today/next_change:#today between [prev_change] and [next_change];
#}





[UK_Employees_Calc_Isums] default: $CURCFG::UK_Contractors_Tpl
const char ks_table=$uk_calc_isums_employees
const char ks_keys=c_employee,calc_param_type,period_kind
const char history=change:prev_change/next_change
const char query_defaults=\
#{";"
  prev_change:@today
  next_change:$DayMax
#}
const char ks_defaults=\
#{";"
  c_employee:0
  calc_param_type:0
  period_kind:0
  isum1:0
  turn_inc:0
  turn_dec:0
  isum2:0
#}

const char foreigns=\
#{";"
  PeriodKind($CURCFG::UK_Abbrs_Period_Kinds):period_kind(type)
  ParamType($CURCFG::UK_Abbrs_CalcParams):calc_param_type(type)
#}

[UK_Employees_Calc_Params] default: $CURCFG::UK_Contractors_Tpl
const char ks_table=$uk_calc_params_employees
const char ks_keys=c_employee,calc_param_type,period_kind
const char history=change:prev_change/next_change
const char query_defaults=\
#{";"
  prev_change:@today
  next_change:$DayMax
#}
const char ks_defaults=\
#{";"
  c_employee:0
  calc_param_type:0
  period_kind:0
  param1:0
  turn_inc:0
  turn_dec:0
  param2:0
#}

const char foreigns=\
#{";"
  PeriodKind($CURCFG::UK_Abbrs_Period_Kinds):period_kind(type)
  ParamType($CURCFG::UK_Abbrs_CalcParams):calc_param_type(type)
#}


[UK_Employees_Calendar] default: $CURCFG::UK_Contractors_Tpl
const char ks_table=$uk_employees_calendar
const char ks_keys=c_employee,cldyear,cldmonth
const char cursor_type=scroll


;> ============================================================================
;> __bank_details
;    реквизиты для внешних платежей (контрагентам и сотрудникам)
;> ============================================================================
[UK_BankDetails] default: $CURCFG::UK_Contractors_Tpl
const char ks_table=$uk_bank_details
const char ks_keys=c_bank_detail
const char serial=c_bank_detail
const char ks_defaults=\
#{";"
  comment:
  necurracc:
  card_number:
  c_bank:0
#}

const char foreigns=\
#{";"
  BankAttr:c_bank
#}


;> ============================================================================
;> dogovors
;> ============================================================================

[cmds_dogovors]
const char check_count_dog_orders_by_order_type_parms=_c_dogovor,_order_type,_order_limit
const char check_count_dog_orders_by_order_type=\
#{
  (@@_c_dogovor == 0)   ? return(0) : 0;
  (@@_order_limit == 0) ? return(0) : 0;

; -------------------------------------
; текущее количество неудаленных распоряжений
; (данного типа у данного договора)
; -------------------------------------
  $LONG(_count_dog_orders)
  SQL
    select count(*) into ?_count_dog_orders
    from $uk_orders_def
    where
      order_type = @_order_type and
      c_dogovor  = @_c_dogovor and
      state not in ($ORDER_STATE_DELETED);

  (@@_count_dog_orders < @@_order_limit)
      ? return(0)
      : 0;

; -------------------------------------
; выводим сообщение об ошибке
; -------------------------------------
  RaiseError(-1, "[@_c_dogovor] По текущему договору уже созданно @_count_dog_orders шт. распоряжений данного типа!", "");
#}

[UK_Dogovors_EMPTY]
const char main_class=DB_Kscurs
const char parent_kstat=$CURCFG::UK_Dogovors_All
const char ks_where=[dog_kind]=$DOG_KIND_EMPTY

[UK_Dogovors_OS]
const char main_class=DB_Kscurs
const char parent_kstat=$CURCFG::UK_Dogovors_All
const char ks_where=[dog_kind]=$DOG_KIND_OS


[UK_Dogovors_MBP]
const char main_class=DB_Kscurs
const char parent_kstat=$CURCFG::UK_Dogovors_All
const char ks_where=[dog_kind]=$DOG_KIND_MBP

; -----------------------------------------------------------------------------
; трудовые договора вынесены в отдельную форму
; -----------------------------------------------------------------------------
[UK_Dogovors_Labour]
const char main_class=DB_Kscurs
const char parent_kstat=$CURCFG::UK_Dogovors_All
const char ks_where=[dog_kind] in ($DOG_KIND_LABOUR, $DOG_KIND_LABOUR_ACCOUNTABLE)

[UK_Dogovors_NA]
const char main_class=DB_Kscurs
const char parent_kstat=$CURCFG::UK_Dogovors_All
const char ks_where=[dog_kind]=$DOG_KIND_NA

[UK_Dogovors_Deposits]
const char main_class=DB_Kscurs
const char parent_kstat=$CURCFG::UK_Dogovors_All
const char ks_where=[dog_kind]=$DOG_KIND_DEPOSITS

[UK_Dogovors_Funds]
const char main_class=DB_Kscurs
const char parent_kstat=$CURCFG::UK_Dogovors_All
const char ks_where=[dog_kind]=$DOG_KIND_FUNDS


[UK_Dogovors_Contractors]
const char main_class=DB_Kscurs
const char parent_kstat=$CURCFG::UK_Dogovors_All
const char ks_where=[dog_kind]=$DOG_KIND_CONTRACTORS

[UK_Dogovors_Contractors_RBP]
const char main_class=DB_Kscurs
const char parent_kstat=$CURCFG::UK_Dogovors_All
const char ks_where=[dog_kind]=$DOG_KIND_CONTRACTORS_RBP



[UK_Dogovors_All]
const char main_class=DB_Kstat
const char read_access=any
const char mode=sidur
const char insert_access=PLACE_UK_CONTRACTOR
const char update_access=PLACE_UK_CONTRACTOR
const char delete_access=PLACE_UK_CONTRACTOR
const char ks_table=$uk_dogovors_def
const char ks_keys=c_dogovor
const char serial=c_dogovor
const char ks_where=$BRANCH_WHERE_OBJ
const char cursor_type=scroll

const char ks_defaults=\
#{";"
  c_dogovor:0
  c_branch:@BranchSelect.c_branch
  c_contractor:0
  c_employee:0
  c_curr:$CURR_ROUBLE
  dog_kind:0
  shname:
  comment:
  date0:@today
  date1:$DayMax
#}

; -----------------------------------------------
const char rfc_modifiers=\
#{";"
  Orders:d
  OrdersAll:d
#}

; -----------------------------------------------
const char foreigns=\
#{";"
  Branch:c_branch
  BranchAll:c_branch
  Curr:c_curr
  Kind($CURCFG::UK_Abbrs_DogovorKinds):dog_kind(type)
  Contractor($CURCFG::UK_Contractors_Def):c_contractor
  Employee($CURCFG::UK_Employees_Def):c_employee
  AccntCurr_OS_Main(AccntCurr):Accnt_OS_Main.c_accnt(c_accnt),c_curr
; счета на просмотр
  Accnt_PrimaryAll($CURCFG::UK_Dogovors_AccntsAll):c_dogovor,'$ACCNTDOG_TYPE_PRIMARY'(accnt_type)
  Accnt_Funds_SettleAll($CURCFG::UK_Dogovors_AccntsAll):c_dogovor,'$ACCNTDOG_TYPE_FUNDS_SETTLE'(accnt_type)
;
  Accnt_OS_InvestAll($CURCFG::UK_Dogovors_AccntsAll):c_dogovor,'$ACCNTDOG_TYPE_OS_INVEST'(accnt_type)
  Accnt_OS_MainAll($CURCFG::UK_Dogovors_AccntsAll):c_dogovor,'$ACCNTDOG_TYPE_OS_MAIN'(accnt_type)
  Accnt_OS_DepreciationAll($CURCFG::UK_Dogovors_AccntsAll):c_dogovor,'$ACCNTDOG_TYPE_OS_DEPRECIATION'(accnt_type)
  Accnt_OS_CancelAll($CURCFG::UK_Dogovors_AccntsAll):c_dogovor,'$ACCNTDOG_TYPE_OS_CANCEL'(accnt_type)
  Accnt_Dep_MainAll($CURCFG::UK_Dogovors_AccntsAll):c_dogovor,'$ACCNTDOG_TYPE_DEPOSIT_MAIN'(accnt_type)
  Accnt_Dep_Int_CalcedAll($CURCFG::UK_Dogovors_AccntsAll):c_dogovor,'$ACCNTDOG_TYPE_DEPOSIT_INT_CALCED'(accnt_type)
  Accnt_Dep_Int_PaidAll($CURCFG::UK_Dogovors_AccntsAll):c_dogovor,'$ACCNTDOG_TYPE_DEPOSIT_INT_PAID'(accnt_type)
#}

; -----------------------------------------------
const char slaves=\
#{";"
; счета
  Accnt_Primary($CURCFG::UK_Dogovors_Accnts):c_dogovor,'$ACCNTDOG_TYPE_PRIMARY'(accnt_type)
  Accnt_Exp($CURCFG::UK_Dogovors_Accnts):c_dogovor,'$ACCNTDOG_TYPE_EXPENSE'(accnt_type)
  Accnt_Funds_Settle($CURCFG::UK_Dogovors_Accnts):c_dogovor,'$ACCNTDOG_TYPE_FUNDS_SETTLE'(accnt_type)
;
  Accnt_OS_Invest($CURCFG::UK_Dogovors_Accnts):c_dogovor,'$ACCNTDOG_TYPE_OS_INVEST'(accnt_type)
  Accnt_OS_Main($CURCFG::UK_Dogovors_Accnts):c_dogovor,'$ACCNTDOG_TYPE_OS_MAIN'(accnt_type)
  Accnt_OS_Depreciation($CURCFG::UK_Dogovors_Accnts):c_dogovor,'$ACCNTDOG_TYPE_OS_DEPRECIATION'(accnt_type)
  Accnt_OS_Cancel($CURCFG::UK_Dogovors_Accnts):c_dogovor,'$ACCNTDOG_TYPE_OS_CANCEL'(accnt_type)
  Accnt_Dep_Main($CURCFG::UK_Dogovors_Accnts):c_dogovor,'$ACCNTDOG_TYPE_DEPOSIT_MAIN'(accnt_type)
  Accnt_Dep_Int_Calced($CURCFG::UK_Dogovors_Accnts):c_dogovor,'$ACCNTDOG_TYPE_DEPOSIT_INT_CALCED'(accnt_type)
  Accnt_Dep_Int_Paid($CURCFG::UK_Dogovors_Accnts):c_dogovor,'$ACCNTDOG_TYPE_DEPOSIT_INT_PAID'(accnt_type)
; суммы
  ISum_Main($CURCFG::UK_Dogovors_Isums):c_dogovor,'$ISUMDOG_TYPE_MAIN'(isum_type)
  ISum_NDS($CURCFG::UK_Dogovors_Isums):c_dogovor,'$ISUMDOG_TYPE_NDS'(isum_type)
  ISum_Depreciation($CURCFG::UK_Dogovors_Isums):c_dogovor,'$ISUMDOG_TYPE_DEPRECIATION'(isum_type)
  ISum_Salary($CURCFG::UK_Dogovors_Isums):c_dogovor,'$ISUMDOG_TYPE_SALARY'(isum_type)
;
  DepositPercentage($CURCFG::UK_Dogovors_Isums):c_dogovor,'$ISUMDOG_TYPE_DEP_PERCENT'(isum_type)
;
  ISum_Deposit_Int_Summary($CURCFG::UK_Dogovors_Isums):c_dogovor,'$ISUMDOG_TYPE_DEP_INT_SUMMARY'(isum_type)
  ISum_Deposit_Int_LDOM($CURCFG::UK_Dogovors_Isums):c_dogovor,'$ISUMDOG_TYPE_DEP_INT_LDOM'(isum_type)
  ISum_Deposit_Int_Rest($CURCFG::UK_Dogovors_Isums):c_dogovor,'$ISUMDOG_TYPE_DEP_INT_REST'(isum_type)
#}

; -----------------------------------------------
const char outer_slaves=\
#{";"
; параметры
  Param_DepositPeriod($CURCFG::UK_Dogovors_Params):c_dogovor,'$DOGPARAM_DEPOSIT_PERIOD'(param_type)
  Param_CountDepreciations($CURCFG::UK_Dogovors_Params):c_dogovor,'$DOGPARAM_COUNT_DEPRECIATIONS'(param_type)
  Param_EmployeeFirm($CURCFG::UK_Dogovors_Params):c_dogovor,'$DOGPARAM_EMPLOYEE_FIRM'(param_type)
  Param_EmployeeDepartment($CURCFG::UK_Dogovors_Params):c_dogovor,'$DOGPARAM_EMPLOYEE_DEPARTMENT'(param_type)
  Param_RBP_ISum_Per_Day($CURCFG::UK_Dogovors_Params):c_dogovor,'$DOGPARAM_RBP_PER_DAY'(param_type)
#}

; -----------------------------------------------
const char synonyms=\
#{";"
; ---------------------------
; сумма, очищенная от НДС
; ---------------------------
  _isum_clear[MONEY]=?/ISum_Main.isum,ISum_NDS.isum/(@ISum_Main.isum - @ISum_NDS.isum)
  _employee_department[40]==Param_EmployeeDepartment.ParamValue.sabbr
  _ldom[LONG]=?/date0/(CldGetLimit(@date0, "ldom"))
; ---------------------------
; даты, нужные для расчета амортизации 
; ---------------------------
  _cfdom[LONG]=?(CldGetLimit(Otoday(), "cfdom"))
  _first_day[LONG]=?/_cfdom,date0/( (@_cfdom < @date0) ? long(@date0) : long(@_cfdom))
#}


const char slave_refs=\
#{";"
  Orders($CURCFG::UK_Orders):c_dogovor
  OrdersAll($CURCFG::UK_Orders_Def):c_dogovor
  OrdersEntered($CURCFG::UK_OrdersEntered):c_dogovor
#}

const char references=\
#{";"
  AvalableOrdersTypes($CURCFG::UK_REF_DogKinds_OrderTypes_With_Restriction):dog_kind,c_contractor,c_employee
  Accnts($CURCFG::UK_Dogovors_AccntsAll):c_dogovor
#}

;> ----------------------------------------------------------------------------
;> __spc_codes
;> ----------------------------------------------------------------------------
const char spc_codes=\
#{
; -------------------------------------
; простое распоряжение со свободной суммой/датой/счетами
; -------------------------------------
  $spc_ordercreate_simple (<@_simple (c_dogovor,c_curr,c_contractor,c_employee,_order_type='$ORDER_TYPE_SIMPLE')>):#P_simple_parms;

; -------------------------------------
; ПИФы
; -------------------------------------
  $spc_ordercreate_fund_invoice (<@_fund_simple (c_dogovor,c_curr,_order_type='$ORDER_TYPE_FUNDS_INVOICE')>):#P_fund_simple_parms;
  $spc_ordercreate_fund_payment (<@_fund_simple (c_dogovor,c_curr,_order_type='$ORDER_TYPE_FUNDS_PAYMENT')>):#P_fund_simple_parms;
  $spc_ordercreate_fund_settle_tax (<@_fund_settle_tax (c_dogovor,c_curr)>):#P_fund_settle_tax_parms;

; -------------------------------------
; ОС (основные средства)
; -------------------------------------
  $spc_ordercreate_os_init (<
                              @_os_init (
                                          c_dogovor,c_curr,c_contractor,c_employee,order_type='$ORDER_TYPE_OS_INIT',
                                          ISum_Main.isum,ISum_NDS.isum,_isum_clear
                                        )
                           >);
  $spc_ordercreate_os_depreciation (<@_os_depreciation (
                                                         c_dogovor,c_curr,c_contractor,c_employee,order_type='$ORDER_TYPE_OS_DEPRECIATION',
                                                         _isum_depreciation=ISum_Depreciation.isum,
                                                         _isum_main=ISum_Main.isum,
                                                         _debit2_os=AccntCurr_OS_Main.Turnovers.debit2,
                                                         _credit2_depr=Accnt_OS_Depreciation.AccntCurr.Turnovers.credit2,
                                                         date0,months_count=Param_CountDepreciations.param_value
                                                       )
                                   >);
  $spc_ordercreate_os_all_depreciations (<@_os_all_depreciation (
                                                                 c_dogovor,c_curr,c_contractor,c_employee,order_type='$ORDER_TYPE_OS_DEPRECIATION',
                                                                 _isum_main=ISum_Main.isum,
                                                                 _isum_depreciation=ISum_Depreciation.isum,
                                                                 date0,months_count=Param_CountDepreciations.param_value
                                                               )
                                       >);

  $spc_ordercreate_os_cancel  (<@_os_cancel (
                                              c_dogovor,c_curr,c_contractor,c_employee,order_type='$ORDER_TYPE_OS_CANCEL',
                                              ISum_Main.isum

                                            )
                              >);
; -------------------------------------
; НМА (нематериальные активы)
; -------------------------------------
  $spc_ordercreate_nma_depreciation (<@_os_depreciation (
                                                         c_dogovor,c_curr,c_contractor,c_employee,order_type='$ORDER_TYPE_NMA_DEPRECIATION',
                                                         _isum_depreciation=ISum_Depreciation.isum,
                                                         _isum_main=ISum_Main.isum,
                                                         _debit2_os=AccntCurr_OS_Main.Turnovers.debit2,
                                                         _credit2_depr=Accnt_OS_Depreciation.AccntCurr.Turnovers.credit2,
                                                         date0,months_count=Param_CountDepreciations.param_value
                                                        )
                                    >);
  $spc_ordercreate_nma_all_depreciations (<@_os_all_depreciation (
                                                                   c_dogovor,c_curr,c_contractor,c_employee,order_type='$ORDER_TYPE_NMA_DEPRECIATION',
                                                                   _isum_main=ISum_Main.isum,
                                                                   _isum_depreciation=ISum_Depreciation.isum,
                                                                   date0,months_count=Param_CountDepreciations.param_value
                                                                 )
                                         >);

; -------------------------------------
; МБП (запасы)
; -------------------------------------
  $spc_ordercreate_stocks_purchase (<@_stocks_purchase (
                                                         c_dogovor,c_curr,c_contractor,order_type='$ORDER_TYPE_STOCKS_PURCHASE'
                                                       )
                                   >):#P_stocks_purchase_parms;

; -------------------------------------
; Работники (з/п, больничные, отпуска)
; -------------------------------------
  $spc_ordercreate_employee_salary_adv (<@_employee_salary_adv (
                                                                 c_branch,c_dogovor,c_curr,c_employee,order_type='$ORDER_TYPE_EMPLOYEE_SALARY_ADV'
                                                                 Employee.shname
                                                               )
                                       >);
  $spc_ordercreate_employee_salary_pri (<@_employee_salary_pri (
                                                                 c_branch,c_dogovor,c_curr,c_employee,order_type='$ORDER_TYPE_EMPLOYEE_SALARY_PRI'
                                                                 Employee.shname
                                                               )
                                       >);
  $spc_ordercreate_employee_accountable (<@_employee_accountable  (
                                                                    c_branch,c_dogovor,c_curr,c_employee,order_type='$ORDER_TYPE_EMPLOYEE_ACCOUNTABLE',
                                                                    Employee.shname
                                                                  )
                                        >);

; -------------------------------------
; Депозиты
; -------------------------------------
  $spc_ordercreate_deposit_start (<@_deposit_start (
                                                      c_branch, c_dogovor, c_curr, shname,
                                                      date0, date1,
                                                      _isum=ISum_Main.isum,
                                                      _prc=DepositPercentage.isum
                                                    )
                                 >);

  $spc_ordercreate_deposit_int_calc_ldom  (<@_deposit_inc_calc (
                                                                  c_branch, c_dogovor, c_curr, shname,
                                                                  _order_type='$ORDER_TYPE_DEPOSIT_INT_CALC_LDOM',
                                                                  _isum_int_calc=ISum_Deposit_Int_LDOM.isum,
                                                                  _op_day=_ldom,
                                                                  _prc=DepositPercentage.isum
                                                               )
                                          >);

  $spc_ordercreate_deposit_int_calc_finish (<@_deposit_inc_calc (
                                                                  c_branch, c_dogovor, c_curr, shname,
                                                                  _order_type='$ORDER_TYPE_DEPOSIT_INT_CALC_FINISH',
                                                                  _isum_int_calc=ISum_Deposit_Int_Rest.isum,
                                                                  _op_day=date1,
                                                                  _prc=DepositPercentage.isum
                                                                )
                                           >);

  $spc_ordercreate_deposit_finish (<@_deposit_finish (
                                                        c_branch, c_dogovor, c_curr, shname,
                                                        date0, date1,
                                                        _isum=ISum_Main.isum,
                                                        _isum_int_summary=ISum_Deposit_Int_Summary.isum,
                                                        _prc=DepositPercentage.isum
                                                     )
                                  >);
  $spc_ordercreate_deposit_all (<
                                  $spc_ordercreate_deposit_start +
                                  $spc_ordercreate_deposit_int_calc_ldom + $spc_ordercreate_deposit_int_calc_finish +
                                  $spc_ordercreate_deposit_finish
                               >);

; -------------------------------------
; Контрагенты
; -------------------------------------
  $spc_ordercreate_contractor_calc (<@_contractor_calc  (
                                                          c_dogovor, c_contractor, c_curr,
                                                          _isum_default=ISum_Main.isum
                                                        )
                                   >):#P_contractor_calc_parms;

  $spc_ordercreate_contractor_paid (<@_contractor_paid  (
                                                          c_dogovor, c_contractor, c_curr,
                                                          _isum_default=ISum_Main.isum
                                                        )
                                   >):#P_contractor_paid_parms;
  
  $spc_ordercreate_contractor_calc_and_paid (<@_contractor_calc_and_paid  (
                                                                          c_dogovor, c_contractor, c_curr,
                                                                          _isum_default=ISum_Main.isum
                                                                         )
                                            >):#P_contractor_calc_and_paid_parms;
  $spc_ordercreate_contractor_paid_directly (<@_contractor_paid_directly  (
                                                          c_dogovor, c_contractor, c_curr,
                                                          _isum_default=ISum_Main.isum
                                                        )
                                            >):#P_contractor_paid_directly_parms;

  $spc_ordercreate_deferred_charges_init   (<@_deferred_charges_init (
                                                          c_dogovor, c_contractor, c_curr,
                                                          date0,
                                                          _isum_init=ISum_Main.isum
                                                        )
                                            >):#P_deferred_charges_init_parms;
  $spc_ordercreate_deferred_charges_reduce  (<@_deferred_charges_reduce (
                                                          c_dogovor, c_contractor, c_curr,
                                                          date0,date1,
                                                          _rest2=Accnt_Primary.AccntCurr.Turnovers.debit2,
                                                          _isum_init=ISum_Main.isum,
                                                          _isum_per_day=Param_RBP_ISum_Per_Day.param_dec
                                                        )
                                            >):#P_deferred_charges_reduce_parms;
; -------------------------------------
; работа со всеми распоряжениями по договору
; -------------------------------------
  $spc_dogovor_delete_all_orders                  (<Orders.$spc_uk_orders_delete>);
  $spc_dogovor_rollback_all_orders                (<Orders.$spc_uk_orders_rollback>);
  $spc_dogovor_back_to_entered_all_orders         (<Orders.$spc_uk_orders_set_state_ENTERED>);
  $spc_dogovor_back_to_entered_forced_all_orders  (<Orders.$spc_uk_orders_set_state_ENTERED_forced>);
  $spc_dogovor_print_all_orders                   (<Orders.$spc_uk_orders_printed>);
  $spc_dogovor_perform_all_orders                 (<OrdersEntered.$spc_uk_orders_performed_full>);
  $spc_dogovor_rollback_performed_all_orders      (<Orders.$spc_uk_orders_performed_full_rollback>);
#}


;> ----------------------------------------------------------------------------
;> __deferred_charges_init
;> ----------------------------------------------------------------------------
const char _deferred_charges_init_parms=\
#{";"
  _op_day_rs:Дата проводки по р/с#Tdate_t
  _comment:Комментарий#Tstring_t
#}
const char _deferred_charges_init=\
#{
  _coll_insert  = Auth.obj_by_name("<null>", "DB_Coll");
    @_coll_insert.ClearNames();
    @_coll_insert.AssignVarLong("order_type",                          $ORDER_TYPE_DEFERRED_CHARGES_INIT);
    @_coll_insert.AssignVarLong("op_day",                              @@date0        );
    @_coll_insert.AssignVarLong("c_curr",                              @@c_curr       );
    @_coll_insert.AssignVarLong("c_contractor",                        @@c_contractor );
    @_coll_insert.AssignVarLong("c_dogovor",                           @@c_dogovor    );
    @_coll_insert.AssignVarString("Param_CommentCustom.param_value_s", @@_comment     );
    @_coll_insert.SetVarMoney("ISum_Simple.isum",                      @@_isum_init   );
  $CURCFG::UK_Orders.DoInsertForColl(@@_coll_insert);

; -------------------------------------
; получаем id нового распоряжения
; -------------------------------------
  $LONG(_c_order)
  $CURCFG::UK_Orders.GetKeyLong("c_order", "_c_order");


; -------------------------------------
; в проводках в которых фигурирует р/с проекта меняем опер. день
; -------------------------------------
  $LONG(_c_schema)
  CURSOR
    select p.c_schema into ?_c_schema
    from $uk_orders_provs p
      join $uk_ref_schema s on
                                s.c_schema = p.c_schema and
                                p.op_day between s.prev_change and s.next_change and
                                (
                                  s.accnt_type_d = $SCHEMA_ACCNT_BRANCH_RS or
                                  s.accnt_type_c = $SCHEMA_ACCNT_BRANCH_RS
                                )
    where
      p.c_order = @_c_order
    : call("$CURCFG::cmds_orders:_change_prov_operday", @@_c_order, @@_c_schema, 0, @@_op_day_rs);

  Auth.delete_obj_by_name(@@_coll_insert);
#}

;> ----------------------------------------------------------------------------
;> __deferred_charges_reduce
;> ----------------------------------------------------------------------------
const char _deferred_charges_reduce_parms=\
#{";"
  _year:Год#Tlong_t
  _month:Месяц#Tlong_t
  _comment:Комментарий#Tstring_t
#}
const char _deferred_charges_reduce=\
#{
  $LONG(_date0,_date1)
    _date0 = long(@@date0);
    _date1 = long(@@date1);

; -------------------------------------
; вычисляем период, за который будем восстанавливать сумму
; -------------------------------------
  $LONG(_cfdom,_cldom,_ldom)
    _cfdom = rmdyjul(@@_month,  1, @@_year);
    _cldom = CldGetLimit(@@_cfdom, "cldom");
    _ldom  = CldGetLimit(@@_cfdom, "ldom");

; -------------------------------------
; начало периода не может быть раньше даты начала договора
; окончание периода не может быть позже даты окончания договора
; -------------------------------------
    _cfdom = (@@_cfdom < @@_date0) ? @@_date0 : @@_cfdom;
    _cldom = (@@_cldom > @@_date1) ? @@_date1 : @@_cldom;


  call("$CURCFG::cmds_orders:_check_orders_on_unique", $ORDER_TYPE_DEFERRED_CHARGES_REDUCE, @@_cfdom, @@_cldom, 0, 0, @@c_dogovor, 0, $_TRUE);

; -------------------------------------
; дата платежа не может быть позже даты окончания договора
; (дополнительно корректируем на возможное попадание на выходной день) 
; -------------------------------------
    _ldom  = (@@_ldom  > @@_date1) ? @@_date1 : @@_ldom;
    _ldom  = PeriodNextDay(@@_ldom - 1);

; -------------------------------------
  $LONG(_period)
  $MONEY(_isum_period)
    _period       = @@_cldom - @@_cfdom + 1;
    _isum_period  = round(@@_isum_per_day * @@_period, 2);
    _isum_period  = (@@_isum_period > @@_rest2) ? @@_rest2 : @@_isum_period;

  _coll_insert  = Auth.obj_by_name("<null>", "DB_Coll");
    @_coll_insert.ClearNames();
    @_coll_insert.AssignVarLong("order_type",                             $ORDER_TYPE_DEFERRED_CHARGES_REDUCE );
    @_coll_insert.AssignVarLong("op_day",                                 @@_ldom         );
    @_coll_insert.AssignVarLong("c_curr",                                 @@c_curr        );
    @_coll_insert.AssignVarLong("c_contractor",                           @@c_contractor  );
    @_coll_insert.AssignVarLong("c_dogovor",                              @@c_dogovor     );
    @_coll_insert.SetVarMoney("ISum_Simple.isum",                         @@_isum_period  );
    @_coll_insert.AssignVarString("Param_CommentCustom.param_value_s",    @@_comment      );
    @_coll_insert.AssignVarDate("Param_RBP_Period_Start.param_value_d",   @@_cldom        );
    @_coll_insert.AssignVarDate("Param_RBP_Period_Finish.param_value_d",  @@_cfdom        );
  $CURCFG::UK_Orders.DoInsertForColl(@@_coll_insert);

  Auth.delete_obj_by_name(@@_coll_insert);
#}



;> ----------------------------------------------------------------------------
;> __contractor_calc
;    начисление суммы по контрагенту
;> ----------------------------------------------------------------------------
const char _contractor_calc_parms=\
#{";"
  _year:Год#Tlong_t
  _month:Месяц#Tlong_t
  _isum_ext:Сумма#Tmoney_t
  _isum_nds:НДС#Tmoney_t
  _isum_clear:Без НДС#Tmoney_t
  _comment:Комментарий#Tstring_t
#}
const char _contractor_calc=\
#{
; -------------------------------------
; если на вход не пришла сумма, пытаемся взять сумму по-умолчанию
; -------------------------------------
  $MONEY(_isum)
  _isum = (@@_isum_ext == 0) ? @@_isum_default : @@_isum_ext;
  (@@_isum == 0)
      ? RaiseError(-1, "Сумма начисления должна быть отличная от нуля!", "")
      : 0;

  $LONG(_cfdom,_ldom)
    _cfdom = rmdyjul(@@_month,  1, @@_year);
    _ldom  = CldGetLimit(@@_cfdom, "ldom");

  call("$CURCFG::$CURSEC:_create_contractor_order", $ORDER_TYPE_CALCED, @@_isum, @@_isum_nds, @@_isum_clear, @@_ldom, @@_comment);
#}


;> ----------------------------------------------------------------------------
;> __contractor_paid
;    выплата суммы по контрагенту
;> ----------------------------------------------------------------------------
const char _contractor_paid_parms=\
#{";"
  _op_day:Дата выплаты#Tdate_t
  _isum_ext:Сумма#Tmoney_t
  _comment:Комментарий#Tstring_t
#}
const char _contractor_paid=\
#{
; -------------------------------------
; если на вход не пришла сумма, пытаемся взять сумму по-умолчанию
; -------------------------------------
  $MONEY(_isum)
  _isum = (@@_isum_ext == 0) ? @@_isum_default : @@_isum_ext;
  (@@_isum == 0)
      ? RaiseError(-1, "Сумма начисления должна быть отличная от нуля!", "")
      : 0;

  call("$CURCFG::$CURSEC:_create_contractor_order", $ORDER_TYPE_PAYMENT_TO, @@_isum, 0, 0, long(@@_op_day), @@_comment);
#}

;> ----------------------------------------------------------------------------
;> __contractor_paid_directly
;    выплата суммы по контрагенту
;> ----------------------------------------------------------------------------
const char _contractor_paid_directly_parms=\
#{";"
  _op_day:Дата выплаты#Tdate_t
  _isum_ext:Сумма#Tmoney_t
  _comment:Комментарий#Tstring_t
#}
const char _contractor_paid_directly=\
#{
; -------------------------------------
; если на вход не пришла сумма, пытаемся взять сумму по-умолчанию
; -------------------------------------
  $MONEY(_isum)
  _isum = (@@_isum_ext == 0) ? @@_isum_default : @@_isum_ext;
  (@@_isum == 0)
      ? RaiseError(-1, "Сумма начисления должна быть отличная от нуля!", "")
      : 0;

  call("$CURCFG::$CURSEC:_create_contractor_order", $ORDER_TYPE_PAIMENT_DIRECT, @@_isum, 0, 0, long(@@_op_day), @@_comment);
#}


;> ----------------------------------------------------------------------------
;> __contractor_calc_and_paid
;    начисление + выплата суммы по контрагенту
;> ----------------------------------------------------------------------------
const char _contractor_calc_and_paid_parms=\
#{";"
  _op_day:Дата выплаты#Tdate_t
  _isum_ext:Сумма#Tmoney_t
  _isum_nds:НДС#Tmoney_t
  _isum_clear:Без НДС#Tmoney_t
  _comment:Комментарий#Tstring_t
#}
const char _contractor_calc_and_paid=\
#{
; -------------------------------------
; если на вход не пришла сумма, пытаемся взять сумму по-умолчанию
; -------------------------------------
  $MONEY(_isum)
  _isum = (@@_isum_ext == 0) ? @@_isum_default : @@_isum_ext;
  (@@_isum == 0)
      ? RaiseError(-1, "Сумма начисления должна быть отличная от нуля!", "")
      : 0;

  $LONG(_ldom)
    _ldom = CldGetLimit(@@_op_day, "ldom");

  call("$CURCFG::$CURSEC:_create_contractor_order", $ORDER_TYPE_PAYMENT_TO, @@_isum, 0,           0,              long(@@_op_day),  @@_comment);
  call("$CURCFG::$CURSEC:_create_contractor_order", $ORDER_TYPE_CALCED,     @@_isum, @@_isum_nds, @@_isum_clear,  @@_ldom,          @@_comment);
#}



;> ----------------------------------------------------------------------------
;> __create_contractor_order
;> ----------------------------------------------------------------------------
const char _create_contractor_order_parms=_order_type,_isum,_isum_nds,_isum_clear,_op_day,_comment
const char _create_contractor_order=\
#{
  _coll_insert  = Auth.obj_by_name("<null>", "DB_Coll");
    @_coll_insert.ClearNames();
    @_coll_insert.AssignVarLong("order_type",                          @@_order_type  );
    @_coll_insert.AssignVarLong("op_day",                              @@_op_day      );
    @_coll_insert.AssignVarLong("c_curr",                              @@c_curr       );
    @_coll_insert.AssignVarLong("c_contractor",                        @@c_contractor );
    @_coll_insert.AssignVarLong("c_dogovor",                           @@c_dogovor    );
    @_coll_insert.AssignVarString("Param_CommentCustom.param_value_s", @@_comment);
    
    @_coll_insert.SetVarMoney("ISum_Contr_Pay_To.isum",          @@_isum        );
    @_coll_insert.SetVarMoney("ISum_NDS.isum",                   @@_isum_nds    );
    @_coll_insert.SetVarMoney("ISum_Clear.isum",                 @@_isum_clear  );
  $CURCFG::UK_Orders.DoInsertForColl(@@_coll_insert);

  Auth.delete_obj_by_name(@@_coll_insert);
#}


;> ----------------------------------------------------------------------------
;> __simple
;    обычное распоряжение по договору (произвольные счета и сумма)
;> ----------------------------------------------------------------------------
const char _simple_parms=\
#{";"
  _c_accnt_d:Счет дебета#Tlong_t
  _c_accnt_c:Счет кредита#Tlong_t
  _isum:Сумма#Tmoney_t
  _op_day:Опер. день#Tdate_t
  _comment:Назначение платежа#Tstring_t
  _coll_ext:Имя внешней коллекции#Tstring_t
#}
const char _simple=\
#{
  _coll_insert  = Auth.obj_by_name("<null>", "DB_Coll");
  @_coll_insert.ClearNames();
    @_coll_insert.AssignVarLong("order_type",                          @@_order_type);
    @_coll_insert.AssignVarLong("op_day",                              long(@@_op_day));
    @_coll_insert.AssignVarLong("c_curr",                              @@c_curr);
    @_coll_insert.AssignVarLong("c_contractor",                        @@c_contractor);
    @_coll_insert.AssignVarLong("c_dogovor",                           @@c_dogovor);
    @_coll_insert.AssignVarLong("Param_AccntD.param_value_i",          @@_c_accnt_d);
    @_coll_insert.AssignVarLong("Param_AccntC.param_value_i",          @@_c_accnt_c);
    @_coll_insert.AssignVarString("Param_CommentCustom.param_value_s", @@_comment);
  $CURCFG::UK_Orders.DoInsertForColl(@@_coll_insert);
  Auth.delete_obj_by_name(@@_coll_insert);

  $LONG(_c_order)
  $CURCFG::UK_Orders.GetKeyLong("c_order", "_c_order");

  call("$CURCFG::cmds_orders:add_isum_to_order", @@_c_order, 0, $SCHEMA_ISUM_SIMPLE, @@_isum, 0);

  @_coll_ext.RenewVarsFromColl(CURRENT.get_name());
  return(@@_c_order);
#}

;> ----------------------------------------------------------------------------
;> __fund_simple
;    распоряжение по фонду
;    (пока только двух типов: выставление счета фонду и оплата счета фондом)
;> ----------------------------------------------------------------------------
const char _fund_simple_parms=\
#{";"
  _isum:Сумма#Tmoney_t
  _op_day:Опер. день#Tdate_t
#}
const char _fund_simple=\
#{
  $LONG(_ldom,_date)
    _date = long(@@_op_day);
    _ldom  = CldGetLimit(@@_op_day,  "ldom");

  ((@@_order_type == $ORDER_TYPE_FUNDS_INVOICE) && (@@_ldom != @@_date))
      ? RaiseError(-1, "Выставить счет фонду (начисление) можно только в последний рабочий день месяца!", "")
      : 0;

  ((@@_order_type == $ORDER_TYPE_FUNDS_PAYMENT) && (@@_ldom == @@_date))
      ? RaiseError(-1, "Оплата счета фондом невозможна в последний рабочий день месяца!", "")
      : 0;

  
  _coll_insert  = Auth.obj_by_name("<null>", "DB_Coll");
    @_coll_insert.ClearNames();
    @_coll_insert.AssignVarLong("order_type",     @@_order_type );
    @_coll_insert.AssignVarLong("c_curr",         @@c_curr      );
    @_coll_insert.AssignVarLong("c_dogovor",      @@c_dogovor   );
    @_coll_insert.AssignVarLong("op_day",         @@_date       );
    @_coll_insert.SetVarMoney("ISum_Simple.isum", @@_isum       );
  $CURCFG::UK_Orders.DoInsertForColl(@@_coll_insert);

  Auth.delete_obj_by_name(@@_coll_insert);
#}


;> ----------------------------------------------------------------------------
;> __fund_settle_tax
;    распоряжение по фонду: расчеты по НДС
;> ----------------------------------------------------------------------------
const char _fund_settle_tax_parms=\
#{";"
  _isum:Сумма#Tmoney_t
  _tax_kind:Вид налога#Tlong_t
  op_day:Дата поступления#Tdate_t
#}
const char _fund_settle_tax=\
#{
  $LONG(_op_day)
    _op_day = long(@@op_day);

  $CHAR(_isum_postfix)
  _isum_postfix = (@@_tax_kind == $TAXKIND_NDS)       ? "Funds_Tax_NDS" :
                  (@@_tax_kind == $TAXKIND_NDFL)      ? "Funds_Tax_NDFL" :
                  (@@_tax_kind == $TAXKIND_PROPERTY)  ? "Funds_Tax_Property" 
                                                      : RaiseError(-1, "Неизвестный вид налога!", "");
  call("$CURCFG::$CURSEC:_create_order_with_sum", $ORDER_TYPE_FUNDSCALC_RECEIPT,      @@_op_day, @@_isum, @@c_curr, @@c_dogovor, @@_isum_postfix);
  call("$CURCFG::$CURSEC:_create_order_with_sum", $ORDER_TYPE_FUNDSCALC_TAX_CALC,     @@_op_day, @@_isum, @@c_curr, @@c_dogovor, @@_isum_postfix);
  call("$CURCFG::$CURSEC:_create_order_with_sum", $ORDER_TYPE_FUNDSCALC_TAX_TRANSFER, @@_op_day, @@_isum, @@c_curr, @@c_dogovor, @@_isum_postfix);
#}                                                                                                 

;> ----------------------------------------------------------------------------
;> __create_order_with_sum
;> ----------------------------------------------------------------------------
const char _create_order_with_sum_parms=_order_type,_date,_isum,_c_curr,_c_dogovor,_param_isum_postfix
const char _create_order_with_sum=\
#{
  _coll_insert  = Auth.obj_by_name("<null>", "DB_Coll");
    @_coll_insert.ClearNames();
    @_coll_insert.AssignVarLong("order_type",                           @@_order_type);
    @_coll_insert.AssignVarLong("c_curr",                               @@_c_curr    );
    @_coll_insert.AssignVarLong("c_dogovor",                            @@_c_dogovor );
    @_coll_insert.AssignVarLong("op_day",                               @@_date      );
    @_coll_insert.SetVarMoney("ISum_@{_param_isum_postfix}.isum", @@_isum      );
  $CURCFG::UK_Orders.DoInsertForColl(@@_coll_insert);

  Auth.delete_obj_by_name(@@_coll_insert);
#}


;> ----------------------------------------------------------------------------
;> __deposit_start
;    размещение депозита
;> ----------------------------------------------------------------------------
const char _deposit_start=\
#{
  _coll_insert  = Auth.obj_by_name("<null>", "DB_Coll");
    @_coll_insert.ClearNames();
    @_coll_insert.AssignVarLong("order_type",                         $ORDER_TYPE_DEPOSIT_START);
    @_coll_insert.AssignVarLong("c_curr",                             @@c_curr);
    @_coll_insert.AssignVarLong("c_dogovor",                          @@c_dogovor);
    @_coll_insert.AssignVarLong("op_day",                             long(@@date0));
    @_coll_insert.SetVarMoney("ISum_Deposit.isum",              @@_isum);
  $CURCFG::UK_Orders.DoInsertForColl(@@_coll_insert);

  Auth.delete_obj_by_name(@@_coll_insert);
#}

;> ----------------------------------------------------------------------------
;> __deposit_inc_calc
;    начисление процентов
;    (!!)
;> ----------------------------------------------------------------------------
const char _deposit_inc_calc=\
#{
  (@@_isum_int_calc == 0)
      ? return(0)
      : 0;

  _coll_insert  = Auth.obj_by_name("<null>", "DB_Coll");
    @_coll_insert.ClearNames();
    @_coll_insert.AssignVarLong("order_type",                         @@_order_type);
    @_coll_insert.AssignVarLong("c_curr",                             @@c_curr);
    @_coll_insert.AssignVarLong("c_dogovor",                          @@c_dogovor);
    @_coll_insert.AssignVarLong("op_day",                             long(@@_op_day));
    @_coll_insert.SetVarMoney("ISum_Deposit_Int_Calc.isum",     @@_isum_int_calc);
  $CURCFG::UK_Orders.DoInsertForColl(@@_coll_insert);

  Auth.delete_obj_by_name(@@_coll_insert);
#}

;> ----------------------------------------------------------------------------
;> __deposit_finish
;    возврат и закрытие депозита
;> ----------------------------------------------------------------------------
const char _deposit_finish=\
#{
  _coll_insert  = Auth.obj_by_name("<null>", "DB_Coll");
    @_coll_insert.ClearNames();
    @_coll_insert.AssignVarLong("order_type",                         $ORDER_TYPE_DEPOSIT_FINISH);
    @_coll_insert.AssignVarLong("c_curr",                             @@c_curr);
    @_coll_insert.AssignVarLong("c_dogovor",                          @@c_dogovor);
    @_coll_insert.AssignVarLong("op_day",                             long(@@date1));
    @_coll_insert.SetVarMoney("ISum_Deposit.isum",              @@_isum);
    @_coll_insert.SetVarMoney("ISum_Deposit_Int_Payment.isum",  @@_isum_int_summary);
  $CURCFG::UK_Orders.DoInsertForColl(@@_coll_insert);

  Auth.delete_obj_by_name(@@_coll_insert);
#}


;> ----------------------------------------------------------------------------
;> __os_cancel
;    распоряжение на вывод в эксплуатации ОС
;> ----------------------------------------------------------------------------
const char _os_cancel_parms=\
#{";"
  _op_day:Дата списания#Tdate_t
#}
const char _os_cancel=\
#{
  _coll_insert  = Auth.obj_by_name("<null>", "DB_Coll");
    @_coll_insert.ClearNames();
    @_coll_insert.AssignVarLong("order_type",                         @@order_type);
    @_coll_insert.AssignVarLong("op_day",                             long(@@_op_day));
    @_coll_insert.AssignVarLong("c_curr",                             @@c_curr);
    @_coll_insert.AssignVarLong("c_contractor",                       @@c_contractor);
    @_coll_insert.AssignVarLong("c_dogovor",                          @@c_dogovor);
    @_coll_insert.SetVarMoney("ISum_OS_Main.isum",              @@ISum_Main.isum);
  $CURCFG::UK_Orders.DoInsertForColl(@@_coll_insert);

  Auth.delete_obj_by_name(@@_coll_insert);
#}

;> ----------------------------------------------------------------------------
;> __os_init
;    распоряжение на ввод в эксплуатацию Основного Средства
;> ----------------------------------------------------------------------------
const char _os_init=\
#{
  _coll_insert  = Auth.obj_by_name("<null>", "DB_Coll");
    @_coll_insert.ClearNames();
    @_coll_insert.AssignVarLong("order_type",                         @@order_type);
    @_coll_insert.AssignVarLong("c_curr",                             @@c_curr);
    @_coll_insert.AssignVarLong("c_contractor",                       @@c_contractor);
    @_coll_insert.AssignVarLong("c_dogovor",                          @@c_dogovor);
    @_coll_insert.SetVarMoney("ISum_OS_Main.isum",              @@ISum_Main.isum);
    @_coll_insert.SetVarMoney("ISum_OS_NDS.isum",               @@ISum_NDS.isum);
    @_coll_insert.SetVarMoney("ISum_OS_Clear.isum",             @@_isum_clear);
  $CURCFG::UK_Orders.DoInsertForColl(@@_coll_insert);

  Auth.delete_obj_by_name(@@_coll_insert);
#}

;> ----------------------------------------------------------------------------
;> __os_depreciation
;    распоряжение на амортизацию
;> ----------------------------------------------------------------------------
const char _os_depreciation=\
#{
  $LONG(_ldom_date0,_op_day)
    _ldom_date0 = CldGetLimit(@@date0,  "ldom");
    _op_day     = Otoday();

; -------------------------------------
; контроль за количеством распоряжений с амортизацией по текущему договору
; дополнительно - у последнего распоряжения сумма может отличаться 
; (необходимо брать остаток по счету)
; -------------------------------------
;  $LONG(_count_depreciations,_diff_count)
;  SQL
;    select count(*) into ?_count_depreciations
;    from $uk_orders_def o
;    where
;      o.c_dogovor  = @c_dogovor and
;      o.order_type = @order_type and
;      o.state not in ($ORDER_STATE_DELETED);
;
;  _diff_count = @@months_count - @@_count_depreciations;
;  (@@_diff_count <= 0)
;      ? RaiseError(-1, "Превышено количество амортизационных начислений!", "") : 0;


  (@@_credit2_depr >= @@_isum_main)
      ? RaiseError(-1, "Все уже самортизированно!", "")
      : 0;


  ((@@_credit2_depr + @@_isum_depreciation) > @@_isum_main)
      ? (_isum_depreciation = @@_isum_main - @@_credit2_depr)
      : 0;
      
  call("$CURCFG::$CURSEC:_create_os_depreciation_order", Otoday(), @@order_type, @@c_curr, @@c_contractor, @@c_dogovor, @@_isum_depreciation, @@_ldom_date0);
#}

;> ----------------------------------------------------------------------------
;> __os_all_depreciation
;    распоряжение на амортизацию
;> ----------------------------------------------------------------------------
const char _os_all_depreciation=\
#{
  $LONG(_number,_cfdom,_ldom_date0) 
  $MONEY(_total_depreciation,_isum_rest)
    _number             = 0;
    _total_depreciation = 0;
    _ldom_date0         = CldGetLimit(@@date0,  "ldom");


  CURSOR
    select cfdom into ?_cfdom
    from $utl_months_dates
    where
      cfdom > ?date0
  : call("$CURCFG::$CURSEC:_os_one_depreciation", long(@@_cfdom), @@_isum_depreciation) ? return(1) : 0;
#}

;> ----------------------------------------------------------------------------
;> __os_one_depreciation
;> ----------------------------------------------------------------------------
const char _os_one_depreciation_parms=_cfdom,_isum_depreciation
const char _os_one_depreciation=\
#{
  _number = @@_number + 1;

; -------------------------------------
; недоамортизируемый остаток
; -------------------------------------
  _isum_rest = @@_isum_main - @@_total_depreciation;

; -------------------------------------
; для последней амортизации берем чистый остаток, 
; т.к. из-за округления возможна незначительная ошибка
; -------------------------------------
  _isum_depreciation = (@@_number >= @@months_count) ? @@_isum_rest : @@_isum_depreciation;
  _total_depreciation = @@_total_depreciation + @@_isum_depreciation;

  $LONG(_ldom) _ldom = CldGetLimit(@@_cfdom, "ldom");

  call("$CURCFG::$CURSEC:_create_os_depreciation_order", @@_ldom, @@order_type, @@c_curr, @@c_contractor, @@c_dogovor, @@_isum_depreciation, @@_ldom_date0);

; -------------------------------------
; ограничение на кол-во записей
; -------------------------------------
  (@@_number >= @@months_count)
      ? return(1)
      : return(0);
#}


;> ----------------------------------------------------------------------------
;> __create_os_depreciation_order
;> ----------------------------------------------------------------------------
const char _create_os_depreciation_order_parms=_op_day,_order_type,_c_curr,_c_contractor,_c_dogovor,_isum_depreciation,_ldom_date0
const char _create_os_depreciation_order=\
#{
  $LONG(_ldom) _ldom = CldGetLimit(@@_op_day, "ldom");

;  (@@_op_day < @@_ldom)
;      ? RaiseError(-1, "Амортизация должна производиться только в последний рабочий день месяца!", "")
;      : 0;

;  (@@_op_day <= @@_ldom_date0)
;      ? RaiseError(-1, "Амортизация должна производиться начиная со следующего месяца после даты ввода в эксплуатацию!", "")
;      : 0;

  _coll_insert  = Auth.obj_by_name("<null>", "DB_Coll");
    @_coll_insert.ClearNames();
    @_coll_insert.AssignVarLong("op_day",                              @@_op_day);
    @_coll_insert.AssignVarLong("order_type",                          @@_order_type);
    @_coll_insert.AssignVarLong("c_curr",                              @@_c_curr);
    @_coll_insert.AssignVarLong("c_contractor",                        @@_c_contractor);
    @_coll_insert.AssignVarLong("c_dogovor",                           @@_c_dogovor);
    @_coll_insert.SetVarMoney("ISum_OS_Depreciation.isum",       @@_isum_depreciation);
  $CURCFG::UK_Orders.DoInsertForColl(@@_coll_insert);

  Auth.delete_obj_by_name(@@_coll_insert);
#}


;> ----------------------------------------------------------------------------
;> __stocks_purchase
;    
;> ----------------------------------------------------------------------------
const char _stocks_purchase_parms=_ext_coll,_op_day,_demand_bill,_comment
const char _stocks_purchase=\
#{
  _coll_insert  = Auth.obj_by_name("<null>", "DB_Coll");
    @_coll_insert.ClearNames();
    @_coll_insert.AssignVarLong("order_type",                          @@order_type);
    @_coll_insert.AssignVarLong("c_curr",                              @@c_curr);
    @_coll_insert.AssignVarLong("c_contractor",                        @@c_contractor);
    @_coll_insert.AssignVarLong("c_dogovor",                           @@c_dogovor);
    @_coll_insert.AssignVarDate("op_day",                              @@_op_day);
    @_coll_insert.AssignVarString("Param_CommentCustom.param_value_s", @@_demand_bill);
    @_coll_insert.AssignVarString("Param_CommentCustom.param_value_s", @@_comment);
  $CURCFG::UK_Orders.DoInsertForColl(@@_coll_insert);

  Auth.delete_obj_by_name(@@_coll_insert);

  $LONG(_c_order)
  $CURCFG::UK_Orders.GetKeyLong("c_order", "_c_order");

  (@@_ext_coll == "") ? (_ext_coll = Auth.obj_by_name("<null>", "DB_Coll")) : 0;
  @_ext_coll.SetVarLong("__c_order", @@_c_order);
#}


;> ----------------------------------------------------------------------------
;> __employee_accountable
;    
;> ----------------------------------------------------------------------------
const char _employee_accountable_parms=\
#{";"
  _op_day:Дата списания#Tdate_t
  _op_day_rs:Дата проводки по р/с#Tdate_t
  _isum_postage:Почтовые расходы#Tmoney_t
  _isum_office:Оформление офиса#Tmoney_t
  _isum_trips:Командировочные#Tmoney_t
  _isum_mobile:Мобильная связь#Tmoney_t
  _isum_transport:Транспортные расходы#Tmoney_t
  _isum_state_duty:Госпошлина#Tmoney_t
  _isum_delivery:Услуги доставки#Tmoney_t
  _isum_accessories:Хоз. принадлежности#Tmoney_t
  _comment
#}
const char _employee_accountable=\
#{
; -------------------------------------
; создаем распоряжение
; -------------------------------------
  _coll_insert  = Auth.obj_by_name("<null>", "DB_Coll");
    @_coll_insert.ClearNames();
    @_coll_insert.AssignVarLong("order_type",                           @@order_type        );
    @_coll_insert.AssignVarLong("c_curr",                               @@c_curr            );
    @_coll_insert.AssignVarLong("c_employee",                           @@c_employee        );
    @_coll_insert.AssignVarLong("c_dogovor",                            @@c_dogovor         );
    @_coll_insert.AssignVarDate("op_day",                               @@_op_day           );
    @_coll_insert.AssignVarString("Param_CommentCustom.param_value_s",  @@_comment          );

    @_coll_insert.SetVarMoney("ISum_LbrAccountable_Postage.isum",       @@_isum_postage     );
    @_coll_insert.SetVarMoney("ISum_LbrAccountable_Office.isum",        @@_isum_office      );
    @_coll_insert.SetVarMoney("ISum_LbrAccountable_Trips.isum",         @@_isum_trips       );
    @_coll_insert.SetVarMoney("ISum_LbrAccountable_Mobile.isum",        @@_isum_mobile      );
    @_coll_insert.SetVarMoney("ISum_LbrAccountable_Transport.isum",     @@_isum_transport   );
    @_coll_insert.SetVarMoney("ISum_LbrAccountable_StateDuty.isum",     @@_isum_state_duty  );
    @_coll_insert.SetVarMoney("ISum_LbrAccountable_Delivery.isum",      @@_isum_delivery    );
    @_coll_insert.SetVarMoney("ISum_LbrAccountable_Accessories.isum",   @@_isum_accessories );
  $CURCFG::UK_Orders.DoInsertForColl(@@_coll_insert);
  Auth.delete_obj_by_name(@@_coll_insert);

  $LONG(_c_order)
  $CURCFG::UK_Orders.GetKeyLong("c_order", "_c_order");

; -------------------------------------
; в проводках в которых фигурирует р/с проекта меняем опер. день
; -------------------------------------
  $LONG(_c_schema)
  CURSOR
    select p.c_schema into ?_c_schema
    from $uk_orders_provs p
      join $uk_ref_schema s on
                                s.c_schema = p.c_schema and
                                p.op_day between s.prev_change and s.next_change and
                                (
                                  s.accnt_type_d = $SCHEMA_ACCNT_BRANCH_RS or
                                  s.accnt_type_c = $SCHEMA_ACCNT_BRANCH_RS
                                )
    where
      p.c_order = @_c_order
    : call("$CURCFG::cmds_orders:_change_prov_operday", @@_c_order, @@_c_schema, 0, @@_op_day_rs);
#}


;> ----------------------------------------------------------------------------
;> __employee_salary_adv
;    выплата работнику аванса (середина месяца)
;    !!! хранить это в параметрах распоряжения
;> ----------------------------------------------------------------------------
const char _employee_salary_adv=\
#{
  $LONG(_c_order)
  $CURCFG::UK_Orders.GetKeyLong("c_order", "_c_order");

  return(@@_c_order)
#}

;> ----------------------------------------------------------------------------
;> __employee_salary_pri
;    выплата работнику получки (конец месяца)
;    !!! нужно заложить параметр, уменьшающий кол-во раб. дней (отпуск или больничный)
;    !!! м.б. отдельной spc 
;    !!! хранить это в параметрах распоряжения
;> ----------------------------------------------------------------------------
const char _employee_salary_pri=\
#{
#}


;> ----------------------------------------------------------------------------
;> __pipe_pre_insert
;> ----------------------------------------------------------------------------
const char pipe_pre_insert=\
#{
  (@@c_branch == $BRANCH_CONS)
      ? RaiseError(-1, "Проект 'ВСЕ' только для просмотра! Для него нельзя создать договор!", "")
      : 0;
#}

;> ----------------------------------------------------------------------------
;> __pipe_pre_update
;> ----------------------------------------------------------------------------
const char pipe_pre_update=\
#{
  HEAP.ISum_Main.isum         = @@STORE.ISum_Main.isum;
  HEAP.ISum_NDS.isum          = @@STORE.ISum_NDS.isum;
  HEAP.ISum_Depreciation.isum = @@STORE.ISum_Depreciation.isum;
#}

;> ----------------------------------------------------------------------------
;> __pipe_post_update
;> ----------------------------------------------------------------------------
const char pipe_post_update=\
#{
; -------------------------------------
; проверка на наличие распоряжений только в случае, если менются суммы (???)
; -------------------------------------
  (@@ISum_Main.isum         == @@HEAP.ISum_Main.isum) &&
  (@@ISum_NDS.isum          == @@HEAP.ISum_NDS.isum) &&
  (@@ISum_Depreciation.isum == @@HEAP.ISum_Depreciation.isum)
      ? return(0)
      : 0;

  $LONG(_count_orders)
  SQL
    select count(*) into ?_count_orders
    from $uk_orders_def o
    where
      o.c_dogovor = @c_dogovor and
      o.state not in ($ORDER_STATE_DELETED);

  (@@_count_orders == 0)
      ? 0
      : RaiseError(-1, "По договору уже созданы распоряжения! Для изменения данных их необходимо удалить!", "");
  
#}

;> ----------------------------------------------------------------------------
;> __pipe_pre_delete
;> ----------------------------------------------------------------------------
const char pipe_pre_delete=\
#{
  call("$CURCFG::cmds_orders:_check_for_existing_orders", "c_dogovor", @@c_dogovor, "договор");
#}


; -----------------------------------------------------------------------------
[UK_Dogovors_Accnts] default: $CURCFG::UK_Contractors_Tpl
const char ks_table=$uk_dogovors_accnts
const char ks_keys=c_dogovor,accnt_type
const char history=change:prev_change/next_change
const char drop_condition=*
const char query_defaults=\
#{";"
  prev_change:@today
  next_change:$DayMax
#}

const char ks_defaults=\
#{";"
  c_accnt:0
#}

const char foreigns=\
#{";"
  Dogovor($CURCFG::UK_Dogovors_All):c_dogovor
  Accnt:c_accnt
  AccntCurr:c_accnt,Dogovor.c_curr(c_curr)
  AccntType($CURCFG::UK_Abbrs_AccntDogTypes):accnt_type(type)
#}


; -----------------------------------------------------------------------------
[UK_Dogovors_AccntsAll] default: $CURCFG::UK_Contractors_Tpl
const char ks_table=$uk_dogovors_accnts
const char ks_keys=c_dogovor,accnt_type
const char ks_where=[next_change]=$DayMax
const char ks_defaults=\
#{";"
  c_accnt:0
  prev_change:@today
  next_change:$DayMax
#}

const char foreigns=\
#{";"
  Dogovor($CURCFG::UK_Dogovors_All):c_dogovor
  Accnt(AccntDay):c_accnt,next_change(#today)
  AccntCurr(AccntCurrDay):c_accnt,Dogovor.c_curr(c_curr),next_change(#today)
  AccntType($CURCFG::UK_Abbrs_AccntDogTypes):accnt_type(type)
#}


; -----------------------------------------------------------------------------
; Параметры договора. 
; Значение параметра может быть как абсолютным, так и типизированным
; (в зависимости от типа-контекста)
; -----------------------------------------------------------------------------
[UK_Dogovors_Params] default: $CURCFG::UK_Contractors_Tpl
const char ks_table=$uk_dogovors_params
const char ks_keys=c_dogovor,param_type
const char ks_defaults=\
#{";"
  c_dogovor:0
  param_type:0
  param_value:0
  param_dec:0
#}

const char foreigns=\
#{";"
  ParamType($CURCFG::UK_Abbrs_DogovorParams):param_type(type)
  ParamValue($CURCFG::UK_Abbrs):param_value(type)
#}

const char synonyms=\
#{
  param_value_out[20]=?/param_value,param_dec/
                      (
                          (@param_value==0) 
                            ? (@param_dec==0)
                                : rfmtdec(@param_dec, "# ### ##&.&&&&&&")
                            : string(@param_value)
                          
                      );
#}

; -----------------------------------------------------------------------------
[UK_Dogovors_Isums] default: $CURCFG::UK_Contractors_Tpl
const char ks_table=$uk_dogovors_isums
const char ks_keys=c_dogovor,isum_type


const char ks_defaults=\
#{";"
  c_dogovor:0
  isum_type:0
  isum:0
#}

const char foreigns=\
#{";"
  IsumType($CURCFG::UK_Abbrs_IsumDogTypes):isum_type(type)
#}


;[UK_Dogovors_Params]
; ???
;

;> ============================================================================
;> orders
;> ============================================================================
[UK_Users_Filters_For_Orders]
const char main_class=DB_Kstat
const char ks_table=$uk_users_filter_for_orders
const char ks_keys=c_user
const char mode=sidur
const char cursor_type=dynamic
const char read_access=any
const char update_access=any
const char insert_access=any
const char delete_access=any
const char ks_where=[c_user]=@CurrUser.c_user
const char ks_defaults=\
#{";"
  c_branch:$BRANCH_OUR
  c_user:@CurrUser.c_user
; ---------------------------
; атрибуты для задания периода
; ---------------------------
  period_type int default $PERIODFILTER_KIND_ABS_TYPED
; абсолютный период (год/квартал/месяц)
  year        int default $_FALSE
  quarter     int default $_FALSE
  month       int default $_FALSE
; абсолютные даты
  date0:@today
  date1:@today
; окно от текущего дня
  days_shift_minus:0
  days_shift_plus:0
; ---------------------------
  c_contractor:0
  c_employee:0
  order_type:0
  order_state:0
  is_show_deleted:$_FALSE
#}

const char synonyms=\
#{";"
  _date0[10]=?/days_shift_minus/string(rfmtdate(long(Otoday() - @days_shift_minus), "dd.mm.yyyy"))
  _date1[10]=?/days_shift_plus/string(rfmtdate(long(Otoday()  + @days_shift_plus),  "dd.mm.yyyy"))
#}

const char refs_x1=\
#{";"
  OrdersByFilter($CURCFG::UK_Orders_RPT):period_type,year,quarter,month,date0,date1,days_shift_minus,days_shift_plus,c_contractor,c_employee,order_type,order_state,is_show_deleted
  ActiveContractors($CURCFG::UK_ActiveContractors_RPT):c_branch
  ActiveEmployees($CURCFG::UK_ActiveEmployees_RPT):c_branch
  ActiveOrderTypes($CURCFG::UK_ActiveOrderTypes_RPT):c_branch
#}

const char foreigns=\
#{";"
  Period_Kind($CURCFG::UK_Abbrs_Period_Filter_Kinds):period_type(type)
  
#}

[UK_Orders_RPT]
const char main_class=DB_Ksrpt
const char read_access=any
const char ks_keys=c_order
const char cursor_type=scroll
const char base_attrs=period_type,year,quarter,month,date0,date1,days_shift_minus,days_shift_plus,c_contractor,c_employee,order_type,order_state,is_show_deleted
const char attrs=\
#{","
  c_order           int
; --
  c_branch          int
; --
  period_type       int
  year              int
  quarter           int
  month             int 
  date0             date
  date1             date
  days_shift_minus  int
  days_shift_plus   int
  c_contractor      int  default $_FALSE
  c_employee        int  default $_FALSE
  order_type        int
  order_state       int
  is_show_deleted   int  default $_FALSE
; --
  _empty_1          money default 0
  _empty_2          money default 0
  _empty_3          money default 0
  _empty_4          money default 0
  _empty_5          money default 0
  _empty_6          money default 0
  _empty_7          money default 0
  _empty_8          money default 0 
  _empty_9          money default 0
#}

; -------------------------------------
const char foreigns=\
#{";"
  Order($CURCFG::UK_Orders_Def):c_order
#}

; -------------------------------------
const char references=\
#{";"
  StatesHistory($CURCFG::UK_Orders_StatesHistory):c_order
  Params($CURCFG::UK_Orders_Params):c_order
  ISums($CURCFG::UK_Orders_ISums):c_order
  Provs($CURCFG::UK_Orders_Provs):c_order
  Items($CURCFG::UK_Orders_Items):c_order
  Schema($CURCFG::UK_REF_Schema):order_type
#}

; -------------------------------------
const char refs_x1=\
#{";"
  _ISum_LbrPaymentGROSS($CURCFG::UK_Orders_ISums_IN_Schema):c_order,'$SCHEMA_ISUM_LABOUR_PAYMENT_GROSS'(isum_type),'0'(c_item_group)
  _ISum_LbrPaymentNET_ADV($CURCFG::UK_Orders_ISums_IN_Schema):c_order,'$SCHEMA_ISUM_LABOUR_PAYMENT_NET_ADV'(isum_type),'0'(c_item_group)
  _ISum_LbrPaymentNET_PRI($CURCFG::UK_Orders_ISums_IN_Schema):c_order,'$SCHEMA_ISUM_LABOUR_PAYMENT_NET_PRI'(isum_type),'0'(c_item_group)
  _ISum_LbrPaymentNET_FULL($CURCFG::UK_Orders_ISums_IN_Schema):c_order,'$SCHEMA_ISUM_LABOUR_PAYMENT_NET_FULL'(isum_type),'0'(c_item_group)
  _ISum_LbrNDFL($CURCFG::UK_Orders_ISums_IN_Schema):c_order,'$SCHEMA_ISUM_LABOUR_NDFL'(isum_type),'0'(c_item_group)
  _ISum_LbrIns_PFR($CURCFG::UK_Orders_ISums_IN_Schema):c_order,'$SCHEMA_ISUM_LABOUR_INSURANCE_PFR'(isum_type),'0'(c_item_group)
  _ISum_LbrIns_FSS($CURCFG::UK_Orders_ISums_IN_Schema):c_order,'$SCHEMA_ISUM_LABOUR_INSURANCE_FSS'(isum_type),'0'(c_item_group)
  _ISum_LbrIns_FSS_ACC($CURCFG::UK_Orders_ISums_IN_Schema):c_order,'$SCHEMA_ISUM_LABOUR_INSURANCE_FSS_ACC'(isum_type),'0'(c_item_group)
  _ISum_LbrIns_OMS($CURCFG::UK_Orders_ISums_IN_Schema):c_order,'$SCHEMA_ISUM_LABOUR_INSURANCE_OMS'(isum_type),'0'(c_item_group)
#}

; -------------------------------------
const char synonyms=\
#{";"
  _isum_labour_gross[MONEY]       =? /_ISum_LbrPaymentGROSS.isum/(@_ISum_LbrPaymentGROSS.isum)
  _isum_labour_net_full[MONEY]    =? /_ISum_LbrPaymentNET_FULL.isum/(@_ISum_LbrPaymentNET_FULL.isum)
  _isum_labour_net_adv[MONEY]     =? /_ISum_LbrPaymentNET_ADV.isum/(@_ISum_LbrPaymentNET_ADV.isum)
  _isum_labour_net_pri[MONEY]     =? /_ISum_LbrPaymentNET_PRI.isum/(@_ISum_LbrPaymentNET_PRI.isum)
  _isum_labour_ndfl[MONEY]        =? /_ISum_LbrNDFL.isum/(@_ISum_LbrNDFL.isum)
  _isum_labour_ins_pfr[MONEY]     =? /_ISum_LbrIns_PFR.isum/(@_ISum_LbrIns_PFR.isum)
  _isum_labour_ins_fss[MONEY]     =? /_ISum_LbrIns_FSS.isum/(@_ISum_LbrIns_FSS.isum)
  _isum_labour_ins_oms[MONEY]     =? /_ISum_LbrIns_OMS.isum/(@_ISum_LbrIns_OMS.isum)
  _isum_labour_ins_fss_acc[MONEY] =? /_ISum_LbrIns_FSS_ACC.isum/(@_ISum_LbrIns_FSS_ACC.isum)
#}

; -------------------------------------
const char spc_codes=\
#{";"
  $spc_uk_orders_set_state_ENTERED       (<Order.$spc_uk_orders_set_state_ENTERED>)
  $spc_uk_orders_printed                 (<Order.$spc_uk_orders_printed>)
  $spc_uk_orders_performed_full          (<Order.$spc_uk_orders_performed_full>)
  $spc_uk_orders_performed_full_rollback (<Order.$spc_uk_orders_performed_full_rollback>)
  $spc_uk_orders_rollback                (<Order.$spc_uk_orders_rollback>)
  $spc_uk_orders_delete                  (<Order.$spc_uk_orders_delete>)
#}

; -----------------------------------------------------------------------------
const char pipe_subobj=\
#{
  SQL create unique index idx_@{_rpt_table}_0 on @_rpt_table (c_order);


  $LONG(_today) _today = Otoday();
  $LONG(_c_branch,_date0,_date1,_c_contractor,_c_employee)
  $LONG(_order_type,_is_show_deleted,_order_state)
    StdEnv.GetVarLong("BranchSelect.c_branch", "_c_branch" );
    
    _date0           = (@@period_type == $PERIODFILTER_KIND_COND_DAYS)
                          ? long(@@_today - @@days_shift_minus) :
                       (@@period_type == $PERIODFILTER_KIND_ABS_DATES)
                          ? long(@@date0) :
                       (@@period_type == $PERIODFILTER_KIND_ABS_TYPED)
                          ? call("$CURCFG::$CURSEC:_get_date_for_period", @@year, @@quarter, @@month, "f")
                          : @@_today;

    _date1           = (@@period_type == $PERIODFILTER_KIND_COND_DAYS)
                          ? long(@@_today + @@days_shift_plus) :
                       (@@period_type == $PERIODFILTER_KIND_ABS_DATES)
                          ? long(@@date1) :
                       (@@period_type == $PERIODFILTER_KIND_ABS_TYPED)
                          ? call("$CURCFG::$CURSEC:_get_date_for_period", @@year, @@quarter, @@month, "l")
                          : @@_today;


    _c_contractor    = isnull(@@c_contractor)    ? $_FALSE                : long(@@c_contractor);
    _c_employee      = isnull(@@c_employee)      ? $_FALSE                : long(@@c_employee);
    _order_type      = isnull(@@order_type)      ? $_FALSE                : long(@@order_type);
    _order_state     = isnull(@@order_state)     ? $_FALSE                : long(@@order_state);
    _is_show_deleted = isnull(@@is_show_deleted) ? $_FALSE                : long(@@is_show_deleted);

  $CHAR(_where_branch,_where_dates,_where_contractor,_where_employee)
  $CHAR(_where_order_type,_where_show_deleted,_where_order_state)
    _where_branch       = "and @_c_branch in (o.c_branch, $BRANCH_CONS)";
    _where_branch       = "";
    _where_dates        = "and o.op_day between @_date0 and @_date1";

    _where_contractor   = (@@_c_contractor == $_FALSE)                            ? ""     :
                          (@@_c_contractor == $_EMPTY)                            ? "and o.c_contractor > 0"
                                                                                  : "and o.c_contractor in (@_c_contractor)";

    _where_employee   =   (@@_c_employee   == $_FALSE)                            ? ""     :
                          (@@_c_employee   == $_EMPTY)                            ? "and o.c_employee > 0"
                                                                                  : "and o.c_employee in (@_c_employee)";

    _where_order_type   = (@@_order_type   == $_FALSE)                            ? ""     : "and o.order_type   in (@_order_type)";

    _where_order_state  = (@@_order_state  == $_FALSE)                            ? ""     : 
                          (@@_order_state  == $EXT_ORDER_STATE_BEFORE_PERFORMED)  ? "and o.state in ($ORDER_STATE_ENTERED, $ORDER_STATE_PRINTED, $ORDER_STATE_SENDING)"
                                                                                  : "and o.state in (@_order_state)";

    _is_show_deleted    = (@@_order_state == $ORDER_STATE_DELETED)                ? $_TRUE : @@_is_show_deleted;
    _where_show_deleted = (@@_is_show_deleted == $_TRUE)                          ? ""     : "and o.state not    in ($ORDER_STATE_DELETED)";
  
  SQL
    insert into @_rpt_table (c_order)
      select o.c_order
      from $uk_orders_def o
      where
        not exists (
                     select *
                     from $uk_ref_abbrs a
                     where
                       a.type = o.order_type and
                       a.abbr matches "ORDER_TYPE_DUMMY_*"
                   )
        @_where_branch
        @_where_dates
        @_where_contractor
        @_where_employee
        @_where_order_type
        @_where_order_state
        @_where_show_deleted;

  SQL update statistics high for table @_rpt_table (c_order);
#}

; -----------------------------------------------------------------------------
const char _get_date_for_period_parms=_year,_quarter,_month,_prefix
const char _get_date_for_period=\
#{
  $CHAR(__cld_const)
  $LONG(__op_day)

  ((@@_quarter == $_FALSE) && (@@_month == $_FALSE))
        ? call("$CURCFG::$CURSEC:_set_params_for_year", @@_year, @@_prefix) :
   (@@_month != $_FALSE)
        ? call("$CURCFG::$CURSEC:_set_params_for_month", @@_year, @@_month, @@_prefix)
        : call("$CURCFG::$CURSEC:_set_params_for_quarter", @@_year, @@_quarter, @@_prefix);

  __op_day = CldGetLimit(@@__op_day, @@__cld_const);
  return(@@__op_day);
#}

const char _set_params_for_month_parms=_year,_month,_prefix
const char _set_params_for_month=\
#{
  __op_day    = rmdyjul(@@_month,  1, @@_year);
  __cld_const = "c" + @@_prefix + "dom";
#}

const char _set_params_for_quarter_parms=_year,_quarter,_prefix
const char _set_params_for_quarter=\
#{
  __op_day    = rmdyjul(@@_quarter*3,  1, @@_year);
  __cld_const = "c" + @@_prefix + "doq";
#}

const char _set_params_for_year_parms=_year,_prefix
const char _set_params_for_year=\
#{
  __op_day    = rmdyjul(1,  1, @@_year);
  __cld_const = "c" + @@_prefix + "doy";
#}


[UK_ActiveContractors_RPT]
const char main_class=DB_Ksrpt
const char read_access=any
const char ks_keys=c_contractor
const char ks_order=shname
const char cursor_type=scroll
const char base_attrs=c_branch
const char attrs=\
#{","
  c_contractor  int
  count_orders  int default 0
  shname        varchar(40)
; --
  c_branch      int
#}

const char synonyms=\
#{";"
  name[160]==Contractor.name
  inn[12]==Contractor.Corp.inn
#}

const char foreigns=\
#{";"
  Contractor($CURCFG::UK_Contractors_Def):c_contractor
#}

const char pipe_subobj=\
#{
  SQL create unique index idx_@{_rpt_table}_0 on @_rpt_table (c_contractor);

  
  $LONG(_c_branch)
  StdEnv.GetVarLong("BranchSelect.c_branch", "_c_branch" );

  $CHAR(_where_branch) _where_branch = "and @_c_branch in (o.c_branch, $BRANCH_CONS)";

  SQL
    insert into @_rpt_table (c_contractor, shname, count_orders)
      select o.c_contractor, c.shname, count(*)
      from $uk_orders_def o
        join $uk_contractors_def c on c.c_contractor = o.c_contractor
      where
        o.c_order = o.c_order and
        o.state not in ($ORDER_STATE_DELETED)
      group by o.c_contractor, c.shname;

  SQL insert into @_rpt_table (c_contractor, shname, count_orders) values ($_EMPTY, "(Любой)", 0);

  SQL update statistics high for table @_rpt_table (c_contractor);
#}

[UK_ActiveEmployees_RPT]
const char main_class=DB_Ksrpt
const char read_access=any
const char ks_keys=c_employee
const char ks_order=shname
const char cursor_type=scroll
const char base_attrs=c_branch
const char attrs=\
#{","
  c_employee    int
  shname        varchar(40)
  count_orders  int default 0
; --
  c_branch      int
#}

const char synonyms=\
#{";"
  shname[40]==Employee.shname
  name[160]==Employee.name
#}

const char foreigns=\
#{";"
  Employee($CURCFG::UK_Employees_Def):c_employee
#}

const char pipe_subobj=\
#{
  SQL create unique index idx_@{_rpt_table}_0 on @_rpt_table (c_employee);

  
  $LONG(_c_branch)
  StdEnv.GetVarLong("BranchSelect.c_branch", "_c_branch" );

  $CHAR(_where_branch) _where_branch = "and @_c_branch in (o.c_branch, $BRANCH_CONS)";

  SQL
    insert into @_rpt_table (c_employee, shname, count_orders)
      select o.c_employee, e.shname, count(*)
      from $uk_orders_def o
        join $uk_employees_def e on e.c_employee = o.c_employee
      where
        o.c_order = o.c_order and
        o.state not in ($ORDER_STATE_DELETED)
      group by o.c_employee, e.shname;

  SQL insert into @_rpt_table (c_employee, shname, count_orders) values ($_EMPTY, "(Любой)", 0);

  SQL update statistics high for table @_rpt_table (c_employee);
#}


[UK_ActiveOrderTypes_RPT]
const char main_class=DB_Ksrpt
const char read_access=any
const char ks_keys=order_type
const char ks_order=shname
const char cursor_type=scroll
const char base_attrs=c_branch
const char attrs=\
#{","
  order_type    int
  count_orders  int default 0
  shname        varchar(60)
; --
  c_branch      int
#}

const char foreigns=\
#{";"
  OrderType($CURCFG::UK_Abbrs_OrderTypes):order_type(type)
#}

const char pipe_subobj=\
#{
  SQL create unique index idx_@{_rpt_table}_0 on @_rpt_table (order_type);

  
  $LONG(_c_branch)
  StdEnv.GetVarLong("BranchSelect.c_branch", "_c_branch" );

  $CHAR(_where_branch) _where_branch = "and @_c_branch in (o.c_branch, $BRANCH_CONS)";

  SQL
    insert into @_rpt_table (order_type, shname, count_orders)
      select o.order_type, a.sabbr, count(*)
      from $uk_orders_def o
        join $uk_ref_abbrs a on a.type = o.order_type
      where
        o.c_order = o.c_order and
        o.state not in ($ORDER_STATE_DELETED)
      group by o.order_type, a.sabbr;

  SQL update statistics high for table @_rpt_table (order_type);
#}


template [UK_Orders_Tpl]
const char main_class=DB_Kstat
const char read_access=any
const char mode=sidur
const char insert_access=PLACE_UK_ORDERS
const char update_access=PLACE_UK_ORDERS
const char delete_access=PLACE_UK_ORDERS
char cursor_type=scroll


[UK_Orders]
const char main_class=DB_Kscurs
const char parent_kstat=$CURCFG::UK_Orders_Def
const char ks_where=[state] not in ($ORDER_STATE_DELETED)


[UK_OrdersEntered]
const char main_class=DB_Kscurs
const char parent_kstat=$CURCFG::UK_Orders_Def
const char ks_where=[state] in ($ORDER_STATE_ENTERED)


; -----------------------------------------------------------------------------
; распоряжения не старше чем n дней (из настроек) от физического "сегодня"
; -----------------------------------------------------------------------------
[UK_Orders_Actual]
const char main_class=DB_Kscurs
const char parent_kstat=$CURCFG::UK_Orders_Def
const char ks_where=\
#{
  [state]      not in ($ORDER_STATE_DELETED) and
  [order_type] not in ($ORDER_TYPE_DUMMY_EMPLOYEE_INIT) and
  [op_day] <= today +
                      (
                        select value_i
                        from $uk_ref_settings
                        where
                          setting_param=$SETTING_PARAM_DAYS_SHIFT_PLUS and
                          today between prev_change and next_change and
                          $BRANCH_WHERE_SQL
                      )
#}

[UK_Orders_WithOutPseudo]
const char main_class=DB_Kscurs
const char parent_kstat=$CURCFG::UK_Orders_Def
const char ks_where=\
#{
  [order_type] not in ($ORDER_TYPE_DUMMY_EMPLOYEE_INIT)
#}

[UK_Orders_WithOutPseudo_WithOutDeleted]
const char main_class=DB_Kscurs
const char parent_kstat=$CURCFG::UK_Orders_WithOutPseudo
const char ks_where=\
#{
  [state] not in ($ORDER_STATE_DELETED)
#}



[UK_Orders_Def] default: $CURCFG::UK_Orders_Tpl
const char cursor_type=dynamic 
const char ks_table=$uk_orders_def
const char ks_keys=c_order
const char serial=c_order
const char ks_where=$BRANCH_WHERE_OBJ
const char ks_order=op_day,c_branch,c_order
const char ks_defaults=\
#{";"
  op_day:@today
  c_curr:$CURR_ROUBLE
  c_branch:@BranchSelect.c_branch
  order_type:$ORDER_TYPE_SIMPLE
  state:$ORDER_STATE_ENTERED
  c_dogovor:0
  c_contractor:0
  c_employee:0
#}

const char insert=\
#{";"
;  stdopn
;
;  Param_AccntD.do_opn
;  Param_AccntC.do_opn
;
;  ISum_Simple.do_opn
;  ISum_Clear.do_opn
;  ISum_NDS.do_opn
;  ISum_OS_Main.do_opn
;  ISum_OS_NDS.do_opn
;  ISum_OS_Clear.do_opn
;  ISum_OS_Depreciation.do_opn
;  ISum_Stock_Total.do_opn
;  ISum_Stock_Total_CLEAR.do_opn
;  ISum_Stock_Total_NDS.do_opn
;  ISum_Contr_Pay_To.do_opn
;  ISum_Deposit.do_opn
;  ISum_Deposit_Int_Calc.do_opn
;  ISum_Deposit_Int_Payment.do_opn
;  ISum_Funds_Tax_NDS.do_opn
;  ISum_Funds_Tax_NDFL.do_opn
;  ISum_Funds_Tax_Property.do_opn
;  ISum_LbrPaymentGROSS.do_opn
;  ISum_LbrNDFL.do_opn
;  ISum_LbrPaymentNET_ADV.do_opn
;  ISum_LbrPaymentNET_PRI.do_opn
;  ISum_LbrPFR_Deduction.do_opn
;  ISum_LbrPaymentNET_FULL.do_opn
;  ISum_LbrIns_PFR.do_opn
;  ISum_LbrIns_FSS.do_opn
;  ISum_LbrIns_FSS_ACC.do_opn
;  ISum_LbrIns_OMS.do_opn
;  ISum_LbrOverpay_FSS.do_opn
;  ISum_LbrOverpay_VacationReserv.do_opn
;  ISum_LbrAccountable_Postage.do_opn
;  ISum_LbrAccountable_Office.do_opn
;  ISum_LbrAccountable_Trips.do_opn
;  ISum_LbrAccountable_Mobile.do_opn
;  ISum_LbrAccountable_Transport.do_opn
;  ISum_LbrAccountable_StateDuty.do_opn
;  ISum_LbrAccountable_Delivery.do_opn
;  ISum_LbrAccountable_Accessories.do_opn
#}


const char rfc_modifiers=\
#{";"
; суммы
  ISum_Simple:d
  ISum_Clear:d
  ISum_NDS:d
  ISum_OS_Main:d
  ISum_OS_NDS:d
  ISum_OS_Clear:d
  ISum_OS_Depreciation:d
  ISum_Stock_Total:d
  ISum_Stock_Total_CLEAR:d
  ISum_Stock_Total_NDS:d
;
  ISum_Contr_Pay_To:d
;
  ISum_Deposit:d
  ISum_Deposit_Int_Calc:d
  ISum_Deposit_Int_Payment:d
;
  ISum_Funds_Tax_NDS:d
  ISum_Funds_Tax_NDFL:d
  ISum_Funds_Tax_Property:d
; суммы по работникам
  ISum_LbrPaymentGROSS:d
  ISum_LbrNDFL:d
  ISum_LbrPaymentNET_ADV:d
  ISum_LbrPaymentNET_PRI:d
  ISum_LbrPFR_Deduction:d
  ISum_LbrPaymentNET_FULL:d
  ISum_LbrIns_PFR:d
  ISum_LbrIns_FSS:d
  ISum_LbrIns_FSS_ACC:d
  ISum_LbrIns_OMS:d
  ISum_LbrOverpay_FSS:d
  ISum_LbrOverpay_VacationReserv:d
; суммы по подотчетным лицам
  ISum_LbrAccountable_Postage:d
  ISum_LbrAccountable_Office:d
  ISum_LbrAccountable_Trips:d
  ISum_LbrAccountable_Mobile:d
  ISum_LbrAccountable_Transport:d
  ISum_LbrAccountable_StateDuty:d
  ISum_LbrAccountable_Delivery:d
  ISum_LbrAccountable_Accessories:d
; обнуляющие суммы в технических распоряжениях
  ISum_Lbr_Paym_Salary_Gross_Reset:d
  ISum_Lbr_Paym_Illness_Gross_Reset:d
  ISum_Lbr_Paym_Vacation_Gross_Reset:d
  ISum_Lbr_NDFL_Reset:d
  ISum_Lbr_Paym_Salary_Net_Reset:d
  ISum_Lbr_Paym_Illness_Net_Reset:d
  ISum_Lbr_Paym_Vacation_Net_Reset:d
  ISum_Lbr_Ins_PFR_Reset:d
  ISum_Lbr_Ins_FSS_Reset:d
  ISum_Lbr_Ins_FSS_ACC_Reset:d
  ISum_Lbr_Ins_OMS_Reset:d
; счета
  Param_AccntD:d
  Param_AccntC:d
; дни по сотрудникам
  Param_Labour_Days_Of_Payment:d
  Param_Labour_Days_Of_Illness:d
  Param_Labour_Days_Of_Vacation:d
  Param_Labour_Days_Of_Payment_Reset:d
  Param_Labour_Days_Of_Illness_Reset:d
  Param_Labour_Days_Of_Vacation_Reset:d
; прочее
  Param_CommentCustom:d
  Param_LabourVacationStart:d
  Param_LabourVacationFinish:d
  Param_LabourIllnessStart:d
  Param_LabourIllnessFinish:d
  Param_RBP_Period_Start:d
  Param_RBP_Period_Finish:d
;
  ISum_Lbr_Child_Fss:d
  ISum_Lbr_Child_Firm:d
  ISum_Lbr_Child_Summary:d
  ISum_Lbr_Illness_Fss:d
  ISum_Lbr_Illness_Firm:d
;
  Items:d
#}

; -----------------------------------------------------------------------------
const char outer_slaves=\
#{";"
  ISum_Simple($CURCFG::UK_Orders_ISums):c_order,'$SCHEMA_ISUM_SIMPLE'(isum_type),'0'(c_item_group)
  ISum_Clear($CURCFG::UK_Orders_ISums):c_order,'$SCHEMA_ISUM_CLEAR'(isum_type),'0'(c_item_group)
  ISum_NDS($CURCFG::UK_Orders_ISums):c_order,'$SCHEMA_ISUM_NDS'(isum_type),'0'(c_item_group)
; ---------------------------
; суммы для расчета с контрагентами
; ---------------------------
  ISum_Contr_Pay_To($CURCFG::UK_Orders_ISums):c_order,'$SCHEMA_ISUM_PAY_TO'(isum_type),'0'(c_item_group)
; ---------------------------
; суммы для расчета с ПИФами 
; ---------------------------
  ISum_Funds_Tax_NDS($CURCFG::UK_Orders_ISums):c_order,'$SCHEMA_ISUM_FUNDS_TAX_NDS'(isum_type),'0'(c_item_group)
  ISum_Funds_Tax_NDFL($CURCFG::UK_Orders_ISums):c_order,'$SCHEMA_ISUM_FUNDS_TAX_NDFL'(isum_type),'0'(c_item_group)
  ISum_Funds_Tax_Property($CURCFG::UK_Orders_ISums):c_order,'$SCHEMA_ISUM_FUNDS_TAX_PROPERTY'(isum_type),'0'(c_item_group)
; ---------------------------
; суммы ОС
; ---------------------------
  ISum_OS_Main($CURCFG::UK_Orders_ISums):c_order,'$SCHEMA_ISUM_OS_MAIN'(isum_type),'0'(c_item_group)
  ISum_OS_NDS($CURCFG::UK_Orders_ISums):c_order,'$SCHEMA_ISUM_OS_NDS'(isum_type),'0'(c_item_group)
  ISum_OS_Clear($CURCFG::UK_Orders_ISums):c_order,'$SCHEMA_ISUM_OS_CLEAR'(isum_type),'0'(c_item_group)
  ISum_OS_Depreciation($CURCFG::UK_Orders_ISums):c_order,'$SCHEMA_ISUM_OS_DEPRECIATION'(isum_type),'0'(c_item_group)
  ISum_Stock_Total($CURCFG::UK_Orders_ISums):c_order,'$SCHEMA_ISUM_STOCKS_PURCHASE_TOTAL'(isum_type),'0'(c_item_group)
  ISum_Stock_Total_CLEAR($CURCFG::UK_Orders_ISums):c_order,'$SCHEMA_ISUM_STOCKS_PURCHASE_TOTAL_CLEAR'(isum_type),'0'(c_item_group)
  ISum_Stock_Total_NDS($CURCFG::UK_Orders_ISums):c_order,'$SCHEMA_ISUM_STOCKS_PURCHASE_TOTAL_NDS'(isum_type),'0'(c_item_group)
; ---------------------------
; суммы работников
; ---------------------------
  ISum_LbrPaymentGROSS($CURCFG::UK_Orders_ISums):c_order,'$SCHEMA_ISUM_LABOUR_PAYMENT_GROSS'(isum_type),'0'(c_item_group)
  ISum_LbrNDFL($CURCFG::UK_Orders_ISums):c_order,'$SCHEMA_ISUM_LABOUR_NDFL'(isum_type),'0'(c_item_group)
  ISum_LbrPaymentNET_ADV($CURCFG::UK_Orders_ISums):c_order,'$SCHEMA_ISUM_LABOUR_PAYMENT_NET_ADV'(isum_type),'0'(c_item_group)
  ISum_LbrPaymentNET_PRI($CURCFG::UK_Orders_ISums):c_order,'$SCHEMA_ISUM_LABOUR_PAYMENT_NET_PRI'(isum_type),'0'(c_item_group)
  ISum_LbrPaymentNET_FULL($CURCFG::UK_Orders_ISums):c_order,'$SCHEMA_ISUM_LABOUR_PAYMENT_NET_FULL'(isum_type),'0'(c_item_group)
  ISum_LbrPFR_Deduction($CURCFG::UK_Orders_ISums):c_order,'$SCHEMA_ISUM_LABOUR_PFR_DEDUCTION'(isum_type),'0'(c_item_group)
  ISum_LbrIns_PFR($CURCFG::UK_Orders_ISums):c_order,'$SCHEMA_ISUM_LABOUR_INSURANCE_PFR'(isum_type),'0'(c_item_group)
  ISum_LbrIns_FSS($CURCFG::UK_Orders_ISums):c_order,'$SCHEMA_ISUM_LABOUR_INSURANCE_FSS'(isum_type),'0'(c_item_group)
  ISum_LbrIns_FSS_ACC($CURCFG::UK_Orders_ISums):c_order,'$SCHEMA_ISUM_LABOUR_INSURANCE_FSS_ACC'(isum_type),'0'(c_item_group)
  ISum_LbrIns_OMS($CURCFG::UK_Orders_ISums):c_order,'$SCHEMA_ISUM_LABOUR_INSURANCE_OMS'(isum_type),'0'(c_item_group)
;
  ISum_LbrOverpay_FSS($CURCFG::UK_Orders_ISums):c_order,'$SCHEMA_ISUM_LABOUR_OVERPAY_FSS'(isum_type),'0'(c_item_group)
  ISum_LbrOverpay_VacationReserv($CURCFG::UK_Orders_ISums):c_order,'$SCHEMA_ISUM_LABOUR_OVERPAY_VACATION'(isum_type),'0'(c_item_group)
; подотчетные лица
  ISum_LbrAccountable_Postage($CURCFG::UK_Orders_ISums):c_order,'$SCHEMA_ISUM_LABOUR_ACCOUNTABLE_POSTAGE'(isum_type),'0'(c_item_group)
  ISum_LbrAccountable_Office($CURCFG::UK_Orders_ISums):c_order,'$SCHEMA_ISUM_LABOUR_ACCOUNTABLE_OFFICE'(isum_type),'0'(c_item_group)
  ISum_LbrAccountable_Trips($CURCFG::UK_Orders_ISums):c_order,'$SCHEMA_ISUM_LABOUR_ACCOUNTABLE_TRIPS'(isum_type),'0'(c_item_group)
  ISum_LbrAccountable_Mobile($CURCFG::UK_Orders_ISums):c_order,'$SCHEMA_ISUM_LABOUR_ACCOUNTABLE_MOBILE'(isum_type),'0'(c_item_group)
  ISum_LbrAccountable_Transport($CURCFG::UK_Orders_ISums):c_order,'$SCHEMA_ISUM_LABOUR_ACCOUNTABLE_TRANSPORT'(isum_type),'0'(c_item_group)
  ISum_LbrAccountable_StateDuty($CURCFG::UK_Orders_ISums):c_order,'$SCHEMA_ISUM_LABOUR_ACCOUNTABLE_STATE_DUTY'(isum_type),'0'(c_item_group)
  ISum_LbrAccountable_Delivery($CURCFG::UK_Orders_ISums):c_order,'$SCHEMA_ISUM_LABOUR_ACCOUNTABLE_DELIVERY'(isum_type),'0'(c_item_group)
  ISum_LbrAccountable_Accessories($CURCFG::UK_Orders_ISums):c_order,'$SCHEMA_ISUM_LABOUR_ACCOUNTABLE_ACCESSORIES'(isum_type),'0'(c_item_group)
; ---------------------------
; суммы депозитов
; ---------------------------
  ISum_Deposit($CURCFG::UK_Orders_ISums):c_order,'$SCHEMA_ISUM_DEPOSIT'(isum_type),'0'(c_item_group)
  ISum_Deposit_Int_Calc($CURCFG::UK_Orders_ISums):c_order,'$SCHEMA_ISUM_DEPOSIT_INT_CALC'(isum_type),'0'(c_item_group)
  ISum_Deposit_Int_Payment($CURCFG::UK_Orders_ISums):c_order,'$SCHEMA_ISUM_DEPOSIT_INT_PAYMENT'(isum_type),'0'(c_item_group)
; ---------------------------
; суммы сбрасывающие статистику за год (псевдораспоряжения)
; ---------------------------
  ISum_Lbr_Paym_Salary_Gross_Reset($CURCFG::UK_Orders_ISums):c_order,'$SCHEMA_ISUM_LABOUR_PAYM_SALARY_GROSS_RESET'(isum_type),'0'(c_item_group)
  ISum_Lbr_Paym_Illness_Gross_Reset($CURCFG::UK_Orders_ISums):c_order,'$SCHEMA_ISUM_LABOUR_PAYM_ILLNESS_GROSS_RESET'(isum_type),'0'(c_item_group)
  ISum_Lbr_Paym_Vacation_Gross_Reset($CURCFG::UK_Orders_ISums):c_order,'$SCHEMA_ISUM_LABOUR_PAYM_VACATION_GROSS_RESET'(isum_type),'0'(c_item_group)
;
  ISum_Lbr_NDFL_Reset($CURCFG::UK_Orders_ISums):c_order,'$SCHEMA_ISUM_LABOUR_NDFL_RESET'(isum_type),'0'(c_item_group)
;
  ISum_Lbr_Paym_Salary_Net_Reset($CURCFG::UK_Orders_ISums):c_order,'$SCHEMA_ISUM_LABOUR_PAYM_SALARY_NET_RESET'(isum_type),'0'(c_item_group)
  ISum_Lbr_Paym_Illness_Net_Reset($CURCFG::UK_Orders_ISums):c_order,'$SCHEMA_ISUM_LABOUR_PAYM_ILLNESS_NET_RESET'(isum_type),'0'(c_item_group)
  ISum_Lbr_Paym_Vacation_Net_Reset($CURCFG::UK_Orders_ISums):c_order,'$SCHEMA_ISUM_LABOUR_PAYM_VACATION_NET_RESET'(isum_type),'0'(c_item_group)
;
  ISum_Lbr_Ins_PFR_Reset($CURCFG::UK_Orders_ISums):c_order,'$SCHEMA_ISUM_LABOUR_INSURANCE_PFR_RESET'(isum_type),'0'(c_item_group)
  ISum_Lbr_Ins_FSS_Reset($CURCFG::UK_Orders_ISums):c_order,'$SCHEMA_ISUM_LABOUR_INSURANCE_FSS_RESET'(isum_type),'0'(c_item_group)
  ISum_Lbr_Ins_FSS_ACC_Reset($CURCFG::UK_Orders_ISums):c_order,'$SCHEMA_ISUM_LABOUR_INSURANCE_FSS_ACC_RESET'(isum_type),'0'(c_item_group)
  ISum_Lbr_Ins_OMS_Reset($CURCFG::UK_Orders_ISums):c_order,'$SCHEMA_ISUM_LABOUR_INSURANCE_OMS_RESET'(isum_type),'0'(c_item_group)
;
  ISum_Lbr_Child_Fss($CURCFG::UK_Orders_ISums):c_order,'$SCHEMA_ISUM_LABOUR_CHILD_PAYMENT_FSS'(isum_type),'0'(c_item_group)
  ISum_Lbr_Child_Firm($CURCFG::UK_Orders_ISums):c_order,'$SCHEMA_ISUM_LABOUR_CHILD_PAYMENT_FIRM'(isum_type),'0'(c_item_group)
  ISum_Lbr_Child_Summary($CURCFG::UK_Orders_ISums):c_order,'$SCHEMA_ISUM_LABOUR_CHILD_PAYMENT_SUMMARY'(isum_type),'0'(c_item_group)
  ISum_Lbr_Illness_Fss($CURCFG::UK_Orders_ISums):c_order,'$SCHEMA_ISUM_LABOUR_ILLNESS_PAYMENT_FSS'(isum_type),'0'(c_item_group)
  ISum_Lbr_Illness_Firm($CURCFG::UK_Orders_ISums):c_order,'$SCHEMA_ISUM_LABOUR_ILLNESS_PAYMENT_FIRM'(isum_type),'0'(c_item_group)
; ---------------------------
; счета
; ---------------------------
  Param_AccntD($CURCFG::UK_Orders_Params):c_order,'$ORDER_PARAM_ACCNT_DEBIT'(param_type)
  Param_AccntC($CURCFG::UK_Orders_Params):c_order,'$ORDER_PARAM_ACCNT_CREDIT'(param_type)
; ---------------------------
; дни для работников
; ---------------------------
  Param_Labour_Days_Of_Payment($CURCFG::UK_Orders_Params):c_order,'$ORDER_PARAM_COUNT_DAYS_OF_PAIMENT'(param_type)
  Param_Labour_Days_Of_Illness($CURCFG::UK_Orders_Params):c_order,'$ORDER_PARAM_COUNT_DAYS_OF_ILLNESS'(param_type)
  Param_Labour_Days_Of_Vacation($CURCFG::UK_Orders_Params):c_order,'$ORDER_PARAM_COUNT_DAYS_OF_VACATION'(param_type)
  Param_Labour_Days_Of_Payment_Reset($CURCFG::UK_Orders_Params):c_order,'$ORDER_PARAM_COUNT_DAYS_OF_PAIMENT_RESET'(param_type)
  Param_Labour_Days_Of_Illness_Reset($CURCFG::UK_Orders_Params):c_order,'$ORDER_PARAM_COUNT_DAYS_OF_ILLNESS_RESET'(param_type)
  Param_Labour_Days_Of_Vacation_Reset($CURCFG::UK_Orders_Params):c_order,'$ORDER_PARAM_COUNT_DAYS_OF_VACATION_RESET'(param_type)
; ---------------------------
; остальное
; ---------------------------
  Param_CommentCustom($CURCFG::UK_Orders_Params):c_order,'$ORDER_PARAM_COMMENT_CUSTOM'(param_type)
  Param_LabourVacationStart($CURCFG::UK_Orders_Params):c_order,'$ORDER_PARAM_VACATION_START'(param_type)
  Param_LabourVacationFinish($CURCFG::UK_Orders_Params):c_order,'$ORDER_PARAM_VACATION_FINISH'(param_type)
  Param_LabourIllnessStart($CURCFG::UK_Orders_Params):c_order,'$ORDER_PARAM_ILLNESS_START'(param_type)
  Param_LabourIllnessFinish($CURCFG::UK_Orders_Params):c_order,'$ORDER_PARAM_ILLNESS_FINISH'(param_type)
  Param_RBP_Period_Start($CURCFG::UK_Orders_Params):c_order,'$ORDER_PARAM_RBP_PERIOD_START'(param_type)
  Param_RBP_Period_Finish($CURCFG::UK_Orders_Params):c_order,'$ORDER_PARAM_RBP_PERIOD_FINISH'(param_type)
#}

;> ----------------------------------------------------------------------------
;> __foreigns
;> ----------------------------------------------------------------------------
const char foreigns=\
#{";"
  Curr:c_curr
  Branch:c_branch
  BranchAll:c_branch
  Type($CURCFG::UK_Abbrs_OrderTypes):order_type(type)
  State($CURCFG::UK_Abbrs_OrderStates):state(type)
  Dogovor($CURCFG::UK_Dogovors_All):c_dogovor
  Contractor($CURCFG::UK_Contractors_Def):c_contractor
  Employee($CURCFG::UK_Employees_Def):c_employee

; -------------------------------------
; настроечные счета (общие по проекту)
; -------------------------------------
  _B_RS($CURCFG::UK_REF_SettingsAccnts):c_branch,'$ACCNTSETTING_TYPE_BRANCH_RS'(accnt_type)
  _B_NDS($CURCFG::UK_REF_SettingsAccnts):c_branch,'$ACCNTSETTING_TYPE_BRANCH_NDS'(accnt_type)
  _B_Tax_Profit_Fed($CURCFG::UK_REF_SettingsAccnts):c_branch,'$ACCNTSETTING_TYPE_BRANCH_TAX_PROFIT_FED'(accnt_type)
  _B_Tax_Profit_Reg($CURCFG::UK_REF_SettingsAccnts):c_branch,'$ACCNTSETTING_TYPE_BRANCH_TAX_PROFIT_REG'(accnt_type)
  _B_UK_Settle_NDS($CURCFG::UK_REF_SettingsAccnts):c_branch,'$ACCNTSETTING_TYPE_BRANCH_UK_SETTLE_NDS'(accnt_type)
  _B_UK_Settle_NDFL($CURCFG::UK_REF_SettingsAccnts):c_branch,'$ACCNTSETTING_TYPE_BRANCH_UK_SETTLE_NDFL'(accnt_type)
;
  _B_Funds_Settle_NDS($CURCFG::UK_REF_SettingsAccnts):c_branch,'$ACCNTSETTING_TYPE_BRANCH_FUNDS_SETTLE_NDS'(accnt_type)
  _B_Funds_Settle_NDFL($CURCFG::UK_REF_SettingsAccnts):c_branch,'$ACCNTSETTING_TYPE_BRANCH_FUNDS_SETTLE_NDFL'(accnt_type)
  _B_Funds_Settle_Property($CURCFG::UK_REF_SettingsAccnts):c_branch,'$ACCNTSETTING_TYPE_BRANCH_FUNDS_SETTLE_PROPERTY'(accnt_type)
; расходы
  _B_Exp_Depreciation_OS($CURCFG::UK_REF_SettingsAccnts):c_branch,'$ACCNTSETTING_TYPE_EXP_DEPRECIATION_OS'(accnt_type)
  _B_Exp_Depreciation_NMA($CURCFG::UK_REF_SettingsAccnts):c_branch,'$ACCNTSETTING_TYPE_EXP_DEPRECIATION_NMA'(accnt_type)
  _B_Exp_Labour_Payment($CURCFG::UK_REF_SettingsAccnts):c_branch,'$ACCNTSETTING_TYPE_EXP_LABOUR_PAYMENT'(accnt_type)
  _B_Exp_Labour_ExtraMoney($CURCFG::UK_REF_SettingsAccnts):c_branch,'$ACCNTSETTING_TYPE_EXP_LABOUR_EXTRA_MONEY'(accnt_type)
  _B_Exp_Labour_Childs($CURCFG::UK_REF_SettingsAccnts):c_branch,'$ACCNTSETTING_TYPE_EXP_LABOUR_CHILDS'(accnt_type)
  _B_Exp_Ins_PFR($CURCFG::UK_REF_SettingsAccnts):c_branch,'$ACCNTSETTING_TYPE_EXP_INSURANCE_PFR'(accnt_type)
  _B_Exp_Ins_OMS($CURCFG::UK_REF_SettingsAccnts):c_branch,'$ACCNTSETTING_TYPE_EXP_INSURANCE_OMS'(accnt_type)
  _B_Exp_Ins_FSS($CURCFG::UK_REF_SettingsAccnts):c_branch,'$ACCNTSETTING_TYPE_EXP_INSURANCE_FSS'(accnt_type)
  _B_Exp_Ins_FSS_ACC($CURCFG::UK_REF_SettingsAccnts):c_branch,'$ACCNTSETTING_TYPE_EXP_INSURANCE_FSS_ACC'(accnt_type)
;
  _B_Inc_Ins_PFR($CURCFG::UK_REF_SettingsAccnts):c_branch,'$ACCNTSETTING_TYPE_INC_INSURANCE_PFR'(accnt_type)
  _B_Inc_Ins_FSS($CURCFG::UK_REF_SettingsAccnts):c_branch,'$ACCNTSETTING_TYPE_INC_INSURANCE_FSS'(accnt_type)
;
  _B_Return_Ins_FSS($CURCFG::UK_REF_SettingsAccnts):c_branch,'$ACCNTSETTING_TYPE_RETURN_INSURANCE_FSS'(accnt_type)
; 
  _B_Exp_Postage($CURCFG::UK_REF_SettingsAccnts):c_branch,'$ACCNTSETTING_TYPE_EXP_POSTAGE'(accnt_type)
  _B_Exp_Office($CURCFG::UK_REF_SettingsAccnts):c_branch,'$ACCNTSETTING_TYPE_EXP_OFFICE'(accnt_type)
  _B_Exp_BusinessTrips($CURCFG::UK_REF_SettingsAccnts):c_branch,'$ACCNTSETTING_TYPE_EXP_BUSINESSTRIPS'(accnt_type)
  _B_Exp_Mobile($CURCFG::UK_REF_SettingsAccnts):c_branch,'$ACCNTSETTING_TYPE_EXP_MOBILE'(accnt_type)
  _B_Exp_Transport($CURCFG::UK_REF_SettingsAccnts):c_branch,'$ACCNTSETTING_TYPE_EXP_TRANSPORT'(accnt_type)
  _B_Exp_State_Duty($CURCFG::UK_REF_SettingsAccnts):c_branch,'$ACCNTSETTING_TYPE_EXP_STATE_DUTY'(accnt_type)
  _B_Exp_State_Delivery($CURCFG::UK_REF_SettingsAccnts):c_branch,'$ACCNTSETTING_TYPE_EXP_DELIVERY'(accnt_type)
  _B_Exp_State_Accessories($CURCFG::UK_REF_SettingsAccnts):c_branch,'$ACCNTSETTING_TYPE_EXP_ACCESSORIES'(accnt_type)
  _B_Exp_DeferredCharges($CURCFG::UK_REF_SettingsAccnts):c_branch,'$ACCNTSETTING_TYPE_EXP_DEFERRED_CHARGES'(accnt_type)
  

; доходы
  _B_Inc_Interests($CURCFG::UK_REF_SettingsAccnts):c_branch,'$ACCNTSETTING_TYPE_INC_INTERESTS'(accnt_type)
  _B_Inc_Managements($CURCFG::UK_REF_SettingsAccnts):c_branch,'$ACCNTSETTING_TYPE_INC_MANAGEMENT'(accnt_type)
;
  _B_Cons_60335_PFR($CURCFG::UK_REF_SettingsAccnts):c_branch,'$ACCNTSETTING_TYPE_CONS_60335_PFR'(accnt_type)
  _B_Cons_60335_FSS($CURCFG::UK_REF_SettingsAccnts):c_branch,'$ACCNTSETTING_TYPE_CONS_60335_FSS'(accnt_type)
  _B_Cons_60335_FSS_ACC($CURCFG::UK_REF_SettingsAccnts):c_branch,'$ACCNTSETTING_TYPE_CONS_60335_FSS_ACC'(accnt_type)
  _B_Cons_60335_OMS($CURCFG::UK_REF_SettingsAccnts):c_branch,'$ACCNTSETTING_TYPE_CONS_60335_OMS'(accnt_type)
  
#}

const char refs_x1=\
#{";"
  ExtOrderInfo($CURCFG::UK_REF_DogKinds_OrderTypes):Dogovor.dog_kind(dog_kind),order_type
  Accnts_For_Order(uk_reports::UK_Report_Accnts_For_Order):c_order,state
#}

const char references=\
#{";"
  StatesHistory($CURCFG::UK_Orders_StatesHistory):c_order
  Params($CURCFG::UK_Orders_Params):c_order
  ISums($CURCFG::UK_Orders_ISums):c_order
  Provs($CURCFG::UK_Orders_Provs):c_order
  Items($CURCFG::UK_Orders_Items):c_order
  Schema($CURCFG::UK_REF_Schema):order_type
#}


;> ----------------------------------------------------------------------------
;> __synonyms_accnts
;> ----------------------------------------------------------------------------
const char synonyms_accnts=\
#{
; -------------------------------------
; общие счета по проекту
; -------------------------------------
  _a_b_rs[LONG]                        == _B_RS.c_accnt;
  _a_b_nds[LONG]                       == _B_NDS.c_accnt;
  _a_b_tax_profit_fed[LONG]            == _B_Tax_Profit_Fed.c_accnt;
  _a_b_tax_profit_reg[LONG]            == _B_Tax_Profit_Reg.c_accnt;
  _a_b_uk_settle_nds[LONG]             == _B_UK_Settle_NDS.c_accnt;
  _a_b_uk_settle_ndfl[LONG]            == _B_UK_Settle_NDFL.c_accnt;
  _a_b_funds_settle_nds[LONG]          == _B_Funds_Settle_NDS.c_accnt;
  _a_b_funds_settle_ndfl[LONG]         == _B_Funds_Settle_NDFL.c_accnt;
  _a_b_funds_settle_property[LONG]     == _B_Funds_Settle_Property.c_accnt;
  _a_b_expense_depreciation_os[LONG]   == _B_Exp_Depreciation_OS.c_accnt;
  _a_b_expense_depreciation_nma[LONG]  == _B_Exp_Depreciation_NMA.c_accnt;
  _a_b_expense_labour_payment[LONG]    == _B_Exp_Labour_Payment.c_accnt;
  _a_b_expense_labour_childs[LONG]     == _B_Exp_Labour_Childs.c_accnt;
  _a_b_expense_labour_extra_money[LONG]== _B_Exp_Labour_ExtraMoney.c_accnt;

  _a_b_expense_postage[LONG]       == _B_Exp_Postage.c_accnt;
  _a_b_expense_office[LONG]        == _B_Exp_Office.c_accnt;
  _a_b_expense_businesstrips[LONG] == _B_Exp_BusinessTrips.c_accnt;
  _a_b_expense_mobile[LONG]        == _B_Exp_Mobile.c_accnt;
  _a_b_expense_transport[LONG]     == _B_Exp_Transport.c_accnt;
  _a_b_expense_state_duty[LONG]    == _B_Exp_State_Duty.c_accnt;
  _a_b_expense_delivery[LONG]      == _B_Exp_State_Delivery.c_accnt;
  _a_b_expense_accessories[LONG]   == _B_Exp_State_Accessories.c_accnt;

  _a_b_expense_insurance_pfr[LONG] == _B_Exp_Ins_PFR.c_accnt;
  _a_b_expense_insurance_oms[LONG] == _B_Exp_Ins_OMS.c_accnt;
  _a_b_expense_insurance_fss[LONG] == _B_Exp_Ins_FSS.c_accnt;
  _a_b_expense_insurance_fss_acc[LONG] == _B_Exp_Ins_FSS_ACC.c_accnt;

  _a_b_expense_deferred_charges[LONG]  == _B_Exp_DeferredCharges.c_accnt;

  _a_b_income_insurance_pfr[LONG]  == _B_Inc_Ins_PFR.c_accnt;
  _a_b_income_insurance_fss[LONG]  == _B_Inc_Ins_FSS.c_accnt;
  _a_b_return_insurance_fss[LONG]  == _B_Return_Ins_FSS.c_accnt;

  _a_b_income_from_interests[LONG]   == _B_Inc_Interests.c_accnt;
  _a_b_income_from_managements[LONG] == _B_Inc_Managements.c_accnt;

  _a_b_cons_60335_pfr[LONG]     == _B_Cons_60335_PFR.c_accnt;
  _a_b_cons_60335_fss[LONG]     == _B_Cons_60335_FSS.c_accnt;
  _a_b_cons_60335_fss_acc[LONG] == _B_Cons_60335_FSS_ACC.c_accnt;
  _a_b_cons_60335_oms[LONG]     == _B_Cons_60335_OMS.c_accnt;

; -------------------------------------
; счета по распоряжению
; -------------------------------------
  _a_o_debit[LONG]  == Param_AccntD.param_value_i;
  _a_o_credit[LONG] == Param_AccntC.param_value_i;

; -------------------------------------
; счета вклада
; -------------------------------------
  _accnt_deposit_main[LONG]       == Dogovor.Accnt_Dep_MainAll.c_accnt;
  _accnt_deposit_int_calced[LONG] == Dogovor.Accnt_Dep_Int_CalcedAll.c_accnt;
  _accnt_deposit_int_paid[LONG]   == Dogovor.Accnt_Dep_Int_PaidAll.c_accnt;

; -------------------------------------
; счета контрагента
; -------------------------------------
  _accnt_contractor_a[LONG] == Contractor._accnt_contractor_a;
  _accnt_contractor_p[LONG] == Contractor._accnt_contractor_p;

; -------------------------------------
; счета сотрудника/работника
; -------------------------------------
  _a_e_requirements[LONG]       == Employee.AccntRequirements.c_accnt;
  _a_e_salary[LONG]             == Employee.AccntSalary.c_accnt;
  _a_e_assistance[LONG]         == Employee.AccntAssistance.c_accnt;
  _a_e_accountable[LONG]        == Employee.AccntAccountable.c_accnt;
  _a_e_insurance_pfr[LONG]      == Employee.AccntInsuranse_PFR.c_accnt;
  _a_e_insurance_oms[LONG]      == Employee.AccntInsuranse_OMS.c_accnt;
  _a_e_insurance_fss[LONG]      == Employee.AccntInsuranse_FSS.c_accnt;
  _a_e_insurance_fss_acc[LONG]  == Employee.AccntInsuranse_FSS_ACC.c_accnt;

; -------------------------------------
; основной счет договора (как правило - единственный)
; -------------------------------------
  _accnt_dog_primary[LONG] == Dogovor.Accnt_Primary.c_accnt;
  _accnt_dog_expense[LONG] == Dogovor.Accnt_Exp.c_accnt;

; -------------------------------------
; счета Фондов
; -------------------------------------
  _accnt_dog_funds_settle[LONG] == Dogovor.Accnt_Funds_Settle.c_accnt;

; -------------------------------------
; счета договора ОС
; -------------------------------------
  _accnt_dog_os_invest[LONG]       == Dogovor.Accnt_OS_Invest.c_accnt;
  _accnt_dog_os_main[LONG]         == Dogovor.Accnt_OS_Main.c_accnt;
  _accnt_dog_os_depreciation[LONG] == Dogovor.Accnt_OS_Depreciation.c_accnt;
  _accnt_dog_os_cancel[LONG]       == Dogovor.Accnt_OS_Cancel.c_accnt;
#}


;> ----------------------------------------------------------------------------
;> __synonyms_isums
;> ----------------------------------------------------------------------------
const char synonyms_isums=\
#{
; -------------------------------------
; суммы для формирования проводок по схеме
; -------------------------------------
  _isum_simple[MONEY] == ISum_Simple.isum;
  _isum_clear[MONEY]  == ISum_Clear.isum;
  _isum_nds[MONEY]    == ISum_NDS.isum;

; -----------------
; суммы по фондам
; -----------------
  _isum_fund_settle_tax_nds      == ISum_Funds_Tax_NDS.isum;
  _isum_fund_settle_tax_ndfl     == ISum_Funds_Tax_NDFL.isum;
  _isum_fund_settle_tax_property == ISum_Funds_Tax_Property.isum;

; -----------------
; суммы по контрагентам
; -----------------
  _isum_to_contr                        == ISum_Contr_Pay_To.isum;
;  _isum_from_contr
;  _isum_utility_payment
;

; -----------------
; суммы ОС
; -----------------
  _isum_os_main[MONEY]         == ISum_OS_Main.isum;
  _isum_os_nds[MONEY]          == ISum_OS_NDS.isum;
  _isum_os_clear[MONEY]        == ISum_OS_Clear.isum;
  _isum_os_depreciation[MONEY] == ISum_OS_Depreciation.isum;

; -----------------
; суммы по вкладам
; -----------------
  _isum_deposit[MONEY]             == ISum_Deposit.isum;
  _isum_deposit_int_calc[MONEY]    == ISum_Deposit_Int_Calc.isum;
  _isum_deposit_int_payment[MONEY] == ISum_Deposit_Int_Payment.isum;

; -----------------
; суммы по трудовому договору и с подотчетными лицами
; -----------------
  _lbr_payment_gross[MONEY]    == ISum_LbrPaymentGROSS.isum;
  _lbr_ndfl[MONEY]             == ISum_LbrNDFL.isum;
  _lbr_payment_net_adv[MONEY]  == ISum_LbrPaymentNET_ADV.isum;
  _lbr_payment_net_pri[MONEY]  == ISum_LbrPaymentNET_PRI.isum;
  _lbr_payment_net_full[MONEY] == ISum_LbrPaymentNET_FULL.isum;
  _lbr_pfr_deduction[MONEY]    == ISum_LbrPFR_Deduction.isum;

  _lbr_accountable_postage[MONEY]     == ISum_LbrAccountable_Postage.isum;
  _lbr_accountable_office[MONEY]      == ISum_LbrAccountable_Office.isum;
  _lbr_accountable_trips[MONEY]       == ISum_LbrAccountable_Trips.isum;
  _lbr_accountable_mobile[MONEY]      == ISum_LbrAccountable_Mobile.isum;
  _lbr_accountable_transport[MONEY]   == ISum_LbrAccountable_Transport.isum;
  _lbr_accountable_state_duty[MONEY]  == ISum_LbrAccountable_StateDuty.isum;
  _lbr_accountable_delivery[MONEY]    == ISum_LbrAccountable_Delivery.isum;
  _lbr_accountable_accessories[MONEY] == ISum_LbrAccountable_Accessories.isum;

  _lbr_insurance_pfr[MONEY]     == ISum_LbrIns_PFR.isum;
  _lbr_insurance_fss[MONEY]     == ISum_LbrIns_FSS.isum;
  _lbr_insurance_fss_acc[MONEY] == ISum_LbrIns_FSS_ACC.isum;
  _lbr_insurance_oms[MONEY]     == ISum_LbrIns_OMS.isum;
;  
  _lbr_overpay_fss[MONEY]       == ISum_LbrOverpay_FSS.isum;
  _lbr_overpay_reserv[MONEY]    == ISum_LbrOverpay_VacationReserv.isum;
  
; -------------------------------------
; суммы, обнуляющие статистику за год по работникам
; (как суммы проводок - не используются, но пусть будут для единообразия)
; -------------------------------------
  _lbr_paym_salary_gross_reset[MONEY]   == ISum_Lbr_Paym_Salary_Gross_Reset.isum;
  _lbr_paym_illness_gross_reset[MONEY]  == ISum_Lbr_Paym_Illness_Gross_Reset.isum;
  _lbr_paym_vacation_gross_reset[MONEY] == ISum_Lbr_Paym_Vacation_Gross_Reset.isum;
  _lbr_ndfl_reset[MONEY]                == ISum_Lbr_NDFL_Reset.isum;
  _lbr_paym_salary_net_reset[MONEY]     == ISum_Lbr_Paym_Salary_Net_Reset.isum;
  _lbr_paym_illness_net_reset[MONEY]    == ISum_Lbr_Paym_Illness_Net_Reset.isum;
  _lbr_paym_vacation_net_reset[MONEY]   == ISum_Lbr_Paym_Vacation_Net_Reset.isum;
  _lbr_insurance_pfr_reset[MONEY]       == ISum_Lbr_Paym_Ins_PFR_Reset.isum;
  _lbr_insurance_fss_reset[MONEY]       == ISum_Lbr_Paym_Ins_FSS_Reset.isum;
  _lbr_insurance_fss_acc_reset[MONEY]   == ISum_Lbr_Paym_Ins_FSS_ACC_Reset.isum;
  _lbr_insurance_oms_reset[MONEY]       == ISum_Lbr_Paym_Ins_OMS_Reset.isum;

  _lbr_child_fss[MONEY]     == ISum_Lbr_Child_Fss.isum;
  _lbr_child_firm[MONEY]    == ISum_Lbr_Child_Firm.isum;
  _lbr_child_summary[MONEY] == ISum_Lbr_Child_Summary.isum;

  _lbr_illness_fss[MONEY]   == ISum_Lbr_Illness_Fss.isum;
  _lbr_illness_firm[MONEY]  == ISum_Lbr_Illness_Firm.isum;
#}

;> ----------------------------------------------------------------------------
;> __synonyms
;    определяем синонимы для использования в UK_Orders_Provs 
;    по имени синонима в распоряжении (sabbr) выходим на абсолютное значение
;> ----------------------------------------------------------------------------
const char synonyms=\
${.:synonyms_accnts}\
${.:synonyms_isums}\
#{
  __order_isum_fund_settle_tax=?/_isum_fund_settle_tax_nds,_isum_fund_settle_tax_ndfl,_isum_fund_settle_tax_property/
                                ( 
                                  (@_isum_fund_settle_tax_nds       > 0) ? @_isum_fund_settle_tax_nds  :
                                  (@_isum_fund_settle_tax_ndfl      > 0) ? @_isum_fund_settle_tax_ndfl :
                                  (@_isum_fund_settle_tax_property  > 0) ? @_isum_fund_settle_tax_property : 0
                                );

  __isum_labour_accountable=?/_lbr_accountable_postage,_lbr_accountable_office,_lbr_accountable_trips,_lbr_accountable_mobile,_lbr_accountable_transport,_lbr_accountable_state_duty,_lbr_accountable_delivery,_lbr_accountable_accessories/
                             (@_lbr_accountable_postage + @_lbr_accountable_office + @_lbr_accountable_trips + @_lbr_accountable_mobile + @_lbr_accountable_transport + @_lbr_accountable_state_duty + @_lbr_accountable_delivery + @_lbr_accountable_accessories);

  __order_isum[MONEY] = order_type(
                                    $ORDER_TYPE_PAYMENT_TO|
                                    $ORDER_TYPE_PAIMENT_DIRECT|
                                    $ORDER_TYPE_CALCED                  : ISum_Contr_Pay_To.isum,
                                    $ORDER_TYPE_OS_INIT|
                                    $ORDER_TYPE_OS_CANCEL               : ISum_OS_Main.isum,
                                    $ORDER_TYPE_OS_DEPRECIATION|         
                                    $ORDER_TYPE_NMA_DEPRECIATION        : ISum_OS_Depreciation.isum,
                                    $ORDER_TYPE_OS_CANCEL               : ISum_OS_Clear.isum,
                                    $ORDER_TYPE_STOCKS_PURCHASE         : ISum_Stock_Total.isum,
                                    $ORDER_TYPE_EMPLOYEE_SALARY_ADV     : ISum_LbrPaymentNET_ADV.isum,
                                    $ORDER_TYPE_EMPLOYEE_SALARY_PRI     : ISum_LbrPaymentNET_PRI.isum,
                                    $ORDER_TYPE_EMPLOYEE_ACCOUNTABLE    : __isum_labour_accountable,
                                    $ORDER_TYPE_EMPLOYEE_CHILD_PAYMENT  : ISum_Lbr_Child_Summary.isum,
                                    $ORDER_TYPE_EMPLOYEE_FIN_HELP|
                                    $ORDER_TYPE_EMPLOYEE_ILLNESS        : ISum_LbrPaymentNET_FULL.isum,
                                    $ORDER_TYPE_EMPLOYEE_EXTRA_MONEY|
                                    $ORDER_TYPE_EMPLOYEE_EXTRA_MONEY_WO_FUNDS|
                                    $ORDER_TYPE_EMPLOYEE_VACATION_PAID|
                                    $ORDER_TYPE_EMPLOYEE_VACATION_ACCEPT|
                                    $ORDER_TYPE_EMPLOYEE_RESERV_INCREASE: ISum_LbrPaymentGROSS.isum,
                                    $ORDER_TYPE_EMPLOYEE_RESERV_DECREASE: ISum_LbrIns_PFR.isum,
                                    $ORDER_TYPE_EMPLOYEE_PAYMENT_TO_FNS : ISum_LbrNDFL.isum,
                                    $ORDER_TYPE_SIMPLE|
                                    $ORDER_TYPE_FUNDS_INVOICE|
                                    $ORDER_TYPE_DEFERRED_CHARGES_INIT|
                                    $ORDER_TYPE_DEFERRED_CHARGES_REDUCE|
                                    $ORDER_TYPE_FUNDS_PAYMENT           : ISum_Simple.isum,
                                    $ORDER_TYPE_FUNDSCALC_RECEIPT|
                                    $ORDER_TYPE_FUNDSCALC_TAX_CALC|
                                    $ORDER_TYPE_FUNDSCALC_TAX_TRANSFER  : __order_isum_fund_settle_tax,
                                    $ORDER_TYPE_DEPOSIT_START           : ISum_Deposit.isum,
                                    $ORDER_TYPE_DEPOSIT_INT_CALC_LDOM   : ISum_Deposit_Int_Calc.isum,
                                    $ORDER_TYPE_DEPOSIT_INT_CALC_FINISH : ISum_Deposit_Int_Calc.isum,
                                    $ORDER_TYPE_DEPOSIT_INT_PAYMENT     : ISum_Deposit_Int_Payment.isum,
                                    $ORDER_TYPE_DEPOSIT_FINISH          : ISum_Deposit.isum,
                                                                          '0'
                                  );
; -------------------------------------
; синонимы для удобства
; -------------------------------------
  _year[LONG]=?/op_day/long(rfmtdate(@op_day,"yyyy"));
  _month[10]=?/op_day/string(rfmtdate(@op_day,"mmm"));
  _month_i[LONG]=?/op_day/rfmtdate(@op_day,"mm");
  _quarter[1]=?/_month_i/string(long((@_month_i + 2)/3));
; -------------------------------------
; назначение платежа
; -------------------------------------
  _comment_custom[250]                    == Param_CommentCustom.param_value_s;
; -------------------------------------
; даты
; -------------------------------------
;  _vacation_start[DATE]                    == Param_LabourVacationStart.param_value_d;
;  _vacation_finish[DATE]                   == Param_LabourVacationFinish.param_value_d;
#}


;> ----------------------------------------------------------------------------
;> __spc_codes
;> ----------------------------------------------------------------------------
const char spc_codes=\
#{
; ---------------------------
; изменение состояния
; ---------------------------
  $spc_uk_orders_set_state_ENTERED        (<@_orders_set_state (c_order,_state='$ORDER_STATE_ENTERED',_state_before='$_FALSE',_state_after='$ORDER_STATE_PRINTED')>): PLACE_UK_ORDERS;
  $spc_uk_orders_set_state_ENTERED_forced (<@_orders_set_state (c_order,_state='$ORDER_STATE_ENTERED',_state_before='$_FALSE',_state_after='$_FALSE')>): PLACE_NORIGHT;
  $spc_uk_orders_set_state_PRINTED        (<@_orders_set_state (c_order,_state='$ORDER_STATE_PRINTED',_state_before='$ORDER_STATE_ENTERED',_state_after='$ORDER_STATE_SENDING')>): PLACE_UK_ORDERS;
  $spc_uk_orders_set_state_SENDING        (<@_orders_set_state (c_order,_state='$ORDER_STATE_SENDING',_state_before='$ORDER_STATE_PRINTED',_state_after='$ORDER_STATE_PERFORMED')>): PLACE_UK_ORDERS;
  $spc_uk_orders_set_state_PERFORMED      (<@_orders_set_state (c_order,_state='$ORDER_STATE_PERFORMED',_state_before='$ORDER_STATE_SENDING',_state_after='$_FALSE')>): PLACE_UK_ORDERS;

; ---------------------------
; операции над распоряжениями
; ---------------------------
  $spc_uk_orders_recalc_params            (<@_recalc_params (c_order,order_type,op_day,c_contractor,c_employee)>);
  $spc_uk_orders_printed                  (<@_order_printing (c_order,state,c_user=@CurrUser.c_user)>): PLACE_UK_ORDERS;
  $spc_uk_orders_delete                   (<@_orders_delete (c_order,state,c_user=@CurrUser.c_user,State.sabbr)>): PLACE_UK_ORDERS;
  $spc_uk_orders_refresh_isums_by_items   (<@_refresh_isums_by_items (
                                                                       c_order,state,c_branch,
                                                                       _isum_total_clear=ISum_Stock_Total_CLEAR.isum,
                                                                       _isum_total_nds=ISum_Stock_Total_NDS.isum
                                                                     )
                                          >): PLACE_UK_ORDERS;
  $spc_uk_orders_rollback_delete          (<@_orders_set_state (c_order,_state='$ORDER_STATE_ENTERED',_state_before='$ORDER_STATE_DELETED',_state_after='$ORDER_STATE_DELETED')>): PLACE_UK_ORDERS;

  $spc_uk_orders_sending                  (<Provs.$spc_uk_orders_sending            + $spc_uk_orders_set_state_SENDING>);
  $spc_uk_orders_performed                (<Provs.$spc_uk_orders_performed          + $spc_uk_orders_set_state_PERFORMED>);
  $spc_uk_orders_sending_rollback         (<Provs.$spc_uk_orders_sending_rollback   + $spc_uk_orders_set_state_PRINTED>);
  $spc_uk_orders_performed_rollback       (<Provs.$spc_uk_orders_performed_rollback + $spc_uk_orders_set_state_SENDING>);


  $spc_uk_orders_performed_full           (<$spc_uk_orders_set_state_PRINTED   + $spc_uk_orders_sending          + $spc_uk_orders_performed>);
  $spc_uk_orders_performed_full_rollback  (<$spc_uk_orders_performed_rollback  + $spc_uk_orders_sending_rollback + $spc_uk_orders_set_state_ENTERED>);

; ---------------------------
; вставка в таблицу с историей изменения состояния (чтобы не смотреть логи)
; ---------------------------
  $spc_uk_orders_change_state (<@_orders_change_history_state (c_order,state,c_user=@CurrUser.c_user)>): PLACE_UK_ORDERS;

; ---------------------------
; специальные функции для разработчика
; ---------------------------
  $spc_uk_orders_rollback (<@_orders_rollback (c_order,state,State.sabbr)>): PLACE_NORIGHT;

  $spc_get_tunning_info (<@_get_tunning_info ( state, order_type,op_day,
                                               _isum0=ISums.0.isum,
                                               _isum_type0=ISums.0.isum_type,
                                               ISum_Simple.isum,
                                               Param_AccntD.param_value_i,
                                               Param_AccntC.param_value_i,
                                               Param_CommentCustom.param_value_s,
                                               ISum_LbrPaymentGROSS.isum,
                                               ISum_LbrNDFL.isum,
                                               ISum_LbrPaymentNET_ADV.isum,
                                               ISum_LbrPaymentNET_PRI.isum,
                                               ISum_LbrPaymentNET_FULL.isum,
                                               ISum_LbrIns_PFR.isum,
                                               ISum_LbrIns_FSS.isum,
                                               ISum_LbrIns_FSS_ACC.isum,
                                               ISum_LbrIns_OMS.isum,
                                               ISum_LbrOverpay_FSS.isum,
                                               ISum_LbrOverpay_VacationReserv.isum
                                             )
                        >):#P_get_tunning_info_parms;
  $spc_correct_isums_for_employee_order (<@_correct_isums_for_employee_order (c_order)>):#P_correct_isums_for_employee_order_parms;
  $spc_correct_ins_isums_for_employee_order (<@_correct_ins_isums_for_employee_order (c_order)>):#P_correct_ins_isums_for_employee_order_parms;
  $spc_correct_simple_order (<@_correct_simple_order (c_order,order_type)>):#P_correct_simple_order_parms;
  $spc_correct_sophisticated_order (<@_correct_sophisticated_order (c_order,state)>):#P_correct_sophisticated_order_parms;
#}


;> ------------------------------------------------
;> __correct_simple_order
;    изменение простого распоряжения (дата, сумма, счета, комментарий)
;> ------------------------------------------------
const char _correct_simple_order_parms=\
#{";"
  _op_day:Опер. день#Tdate_t
  _isum:Сумма#Tmoney_t
  _c_accnt_debit:Счет дебета#Tlong_t
  _c_accnt_credit:Счет кредита#Tlong_t
  _comment:Комментарий#Tstring_t
#}

const char _correct_simple_order=\
#{
  (@@order_type == $ORDER_TYPE_SIMPLE)
      ? 0
      : RaiseError(-1, "Корректировать можно только простые распоряжения!", "");

  _coll_update=Auth.obj_by_name("<null>", "DB_Coll");
    @_coll_update.AssignVarDate   ("op_day",                            @@_op_day);
    @_coll_update.AssignVarLong   ("Param_AccntD.param_value_i",        @@_c_accnt_debit);
    @_coll_update.AssignVarLong   ("Param_AccntC.param_value_i",        @@_c_accnt_credit);
    @_coll_update.SetVarMoney     ("ISum_Simple.isum",            @@_isum);
    @_coll_update.AssignVarString ("Param_CommentCustom.param_value_s", @@_comment);
  @THIS.DoUpdateForColl(@@_coll_update);
  Auth.delete_obj_by_name(@@_coll_update);


  SQL update $uk_orders_provs set (c_accnt_debit, c_accnt_credit) = (@_c_accnt_debit, @_c_accnt_credit) where c_order = @c_order;
#}

;> ------------------------------------------------
;> __correct_sophisticated_order
;    изменение любого распоряжения (дата, одна любая сумма, комментарий)
;> ------------------------------------------------
const char _correct_sophisticated_order_parms=\
#{";"
  _op_day:Опер. день#Tdate_t
  _isum_type:Тип суммы#Tlong_t
  _isum:Сумма#Tmoney_t
  _comment:Комментарий#Tstring_t
#}

const char _correct_sophisticated_order=\
#{
  (@@state == $ORDER_STATE_ENTERED)
      ? 0
      : RaiseError(-1, "Корректировать можно только распоряжения в состоянии [Введен]!", "");

; -------------------------------------
; меняем дату и комментарий
; -------------------------------------
  _coll_update=Auth.obj_by_name("<null>", "DB_Coll");
    @_coll_update.AssignVarDate   ("op_day",                            @@_op_day);
    @_coll_update.AssignVarString ("Param_CommentCustom.param_value_s", @@_comment);
  @THIS.DoUpdateForColl(@@_coll_update);


; -------------------------------------
; меняем одну произвольную сумму
; -------------------------------------
  @_coll_update.ClearNames();
    @_coll_update.SetVarMoney("isum", @@_isum);

  _coll_order_isums_keys=Auth.obj_by_name("<null>", "DB_Coll");
  @_coll_order_isums_keys.ClearNames();
    @_coll_order_isums_keys.AssignVarLong("c_order",   @@c_order);
    @_coll_order_isums_keys.AssignVarLong("isum_type", @@_isum_type);
  $CURCFG::UK_Orders_ISums.KeysFromCollection(@@_coll_order_isums_keys);
  $CURCFG::UK_Orders_ISums.DoUpdateForColl(@@_coll_update);

  Auth.delete_obj_by_name(@@_coll_order_isums_keys);
  Auth.delete_obj_by_name(@@_coll_update);
#}


;> ------------------------------------------------
;> __correct_isums_for_employee_order
;    получение аттрибутов объекта и сохранение их во внешней коллекции
;    для использования в Delphi
;> ------------------------------------------------
const char _correct_isums_for_employee_order_parms=\
#{";"
  _isum_ndfl:Новая сумма НДФЛ#Tmoney_t
  _isum_net_value:Новая сумма NET#Tmoney_t
  _isum_net_attr:Имя атрибута NET-суммы#Tmoney_t
#}

const char _correct_isums_for_employee_order=\
#{
  _coll_update=Auth.obj_by_name("<null>", "DB_Coll");
    @_coll_update.SetVarMoney  ("ISum_LbrNDFL.isum",   @@_isum_ndfl);
    @_coll_update.SetVarMoney  (@@_isum_net_attr,               @@_isum_net_value);
  @THIS.DoUpdateForColl(@@_coll_update);
  Auth.delete_obj_by_name(@@_coll_update);
#}


;> ------------------------------------------------
;> __correct_ins_isums_for_employee_order
;    получение аттрибутов объекта и сохранение их во внешней коллекции
;    для использования в Delphi
;> ------------------------------------------------
const char _correct_ins_isums_for_employee_order_parms=\
#{";"
  _isum_pfr:Новая сумма ПФР#Tmoney_t
  _isum_fss:Новая сумма ФСС#Tmoney_t
  _isum_fss_acc:Новая сумма ФСС 0.2%#Tmoney_t
  _isum_ffoms:Новая сумма ФФОМС#Tmoney_t
#}

const char _correct_ins_isums_for_employee_order=\
#{
  _coll_update=Auth.obj_by_name("<null>", "DB_Coll");
    @_coll_update.SetVarMoney  ("ISum_LbrIns_PFR.isum",      @@_isum_pfr);
    @_coll_update.SetVarMoney  ("ISum_LbrIns_FSS.isum",      @@_isum_fss);
    @_coll_update.SetVarMoney  ("ISum_LbrIns_FSS_ACC.isum",  @@_isum_fss_acc);
    @_coll_update.SetVarMoney  ("ISum_LbrIns_OMS.isum",      @@_isum_ffoms);
  @THIS.DoUpdateForColl(@@_coll_update);
  Auth.delete_obj_by_name(@@_coll_update);
#}

;> ------------------------------------------------
;> __get_tunning_info
;    получение аттрибутов объекта и сохранение их во внешней коллекции
;    для использования в Delphi
;> ------------------------------------------------
const char _get_tunning_info_parms=\
#{";"
  ext_coll_name:Имя внешней коллекции#Tstring_t
#}

const char _get_tunning_info=\
#{
  @ext_coll_name.RenewVarsFromColl(CURRENT.get_name());
#}

;> ----------------------------------------------------------------------------
;> __pipe_pre_insert
;> ----------------------------------------------------------------------------
const char pipe_pre_insert=\
#{
  (@@c_branch == $BRANCH_CONS)
      ? RaiseError(-1, "Проект 'ВСЕ' только для просмотра! В нем нельзя создать распоряжение!", "")
      : 0;

; -------------------------------------
; проверка на ограничение кол-ва распоряжений данного типа для данного договора
; -------------------------------------
  call("$CURCFG::cmds_dogovors:check_count_dog_orders_by_order_type", @@c_dogovor, @@order_type, @@ExtOrderInfo.order_limit);

; -------------------------------------
; если распоряжение создается раньше даты начала работы программы считаем его полностью проведенным
; -------------------------------------
  (@@op_day <= $DATE_START)
      ? (IO.state = $ORDER_STATE_PERFORMED)
      : 0;
#}

;> ----------------------------------------------------------------------------
;> __pipe_pre_update
;> ----------------------------------------------------------------------------
const char pipe_pre_update=\
#{
  ((@@STORE.state == $ORDER_STATE_ENTERED) || (@@STORE.state != @@state))
      ? 0
      : RaiseError(-1, "[@c_order] Нельзя редактировать распоряжение в состоянии отличном от 'На вводе'!", "");

  HEAP.state = @@STORE.state;
#}

;> ----------------------------------------------------------------------------
;> __pipe_post_insert
;> ----------------------------------------------------------------------------
const char pipe_post_insert=\
#{
  @THIS.DoSpc($spc_uk_orders_change_state, "<null>");
#}

;> ----------------------------------------------------------------------------
;> __pipe_post_update
;> ----------------------------------------------------------------------------
const char pipe_post_update=\
#{
  (@@state == @@HEAP.state)
      ? 0
      : @THIS.DoSpc($spc_uk_orders_change_state, "<null>");
#}

;> ----------------------------------------------------------------------------
;> __order_printing
;> ----------------------------------------------------------------------------
const char _order_printing=\
#{
  (@@state == $ORDER_STATE_ENTERED)
      ? @THIS.DoSpc($spc_uk_orders_set_state_PRINTED, "<null>")
      : call("$CURCFG::UK_Orders_StatesHistory:_change_history_state", @@c_order, $ORDER_STATE_PRINTED, @@c_user);
#}

;> ----------------------------------------------------------------------------
;> __orders_change_history_state
;> ----------------------------------------------------------------------------
const char _orders_change_history_state=\
#{
  call("$CURCFG::UK_Orders_StatesHistory:_change_history_state", @@c_order, @@state, @@c_user);
#}

;> ----------------------------------------------------------------------------
;> __pipe_delete
;> ----------------------------------------------------------------------------
const char pipe_delete=\
#{
  @THIS.DoSpc($spc_uk_orders_delete, "<null>");
  pipe_delete_RES=0;
#}

;> ----------------------------------------------------------------------------
;> __orders_delete
;> ----------------------------------------------------------------------------
const char _orders_delete=\
#{
; -------------------------------------
; проверки перед удалением
  (@@state > $ORDER_STATE_ENTERED) ? RaiseError(-1,"Нельзя удалить ордер в текущем состоянии <" + string(@@State.sabbr) + ">!",""): 0;


; -------------------------------------
; помечаем распоряжение как удаленное (меняем статус)
; -------------------------------------
  coll=Auth.obj_by_name("<null>", "DB_Coll");

  $LONG(state)
  state   = $ORDER_STATE_DELETED;

  CURRENT.SomeVarsToColl("state", @@coll, "state");
  @THIS.DoUpdateForColl(@@coll);

  Auth.delete_obj_by_name(@@coll);

  SQL delete from $utl_operations_accnts_spc where c_order = @c_order;
#}

;> ----------------------------------------------------------------------------
;> __orders_set_state
;    _state - новое состояние
;> ----------------------------------------------------------------------------
const char _orders_set_state=\
#{
  $LONG(_state_current)
    SQL select state into ?_state_current from $uk_orders_def where c_order = @c_order;

  ((@@_state_before != @@_state_current) && (@@_state_before != $_FALSE)) &&
  ((@@_state_after  != @@_state_current) && (@@_state_after  != $_FALSE))
      ? RaiseError(-1, "[@c_order] Неверное текущее состояние распоряжения!", "")
      : 0;

  _coll_state=Auth.obj_by_name("<null>", "DB_Coll");
    @_coll_state.AssignVarLong("state", @@_state);
  @THIS.DoUpdateForColl(@@_coll_state);

  Auth.delete_obj_by_name(@@_coll_state);


; -------------------------------------  
; вызов функции пересчета сумм и параметров
; (Настройки в Delphi)
; -------------------------------------  
  (@@_state == $ORDER_STATE_ENTERED) || (@@_state == $ORDER_STATE_PRINTED)
      ? @THIS.DoSpc($spc_uk_orders_recalc_params, "<null>")
      : 0;
#}

;> ----------------------------------------------------------------------------
;> __orders_rollback
;> ----------------------------------------------------------------------------
const char _orders_rollback=\
#{
; -------------------------------------
; проверки перед удалением
; -------------------------------------
  (@@state > $ORDER_STATE_ENTERED)
      ? RaiseError(-1,"Нельзя откатить создание ордера в текущем состоянии <" + string(@@State.sabbr) + ">!","")
      : 0;

  SQL delete from $uk_orders_params where c_order = @c_order;
  SQL delete from $uk_orders_isums  where c_order = @c_order;
  SQL delete from $uk_orders_provs  where c_order = @c_order;
  SQL delete from $uk_orders_def    where c_order = @c_order;
#}


;> ----------------------------------------------------------------------------
;> __back_to_entered_all_orders
;> ----------------------------------------------------------------------------
const char _back_to_entered_all_orders=\
#{
  $LONG(_c_order)

  CURSOR
    select o.c_order into ?_c_order
    from $uk_orders_def o
    : call("$CURCFG::$CURSEC:_rollback_one_order", @@_c_order);

  SQL drop table tmp_orders_for_rollback;
#}

;> ----------------------------------------------------------------------------
;> __refresh_isums_by_items
;       params:
;               c_order
;               state
;               c_branch
;               _isum_total_clear
;               _isum_total_nds
;> ----------------------------------------------------------------------------
const char _refresh_isums_by_items=\
#{
  (@@state == $ORDER_STATE_ENTERED)
      ? 0
      : RaiseError(-1, "[@c_order] Нельзя редактировать распоряжение в состоянии отличном от 'На вводе'!", "");

  SQL delete from $uk_orders_isums where c_order = @c_order and c_item_group <> 0;
  SQL delete from $uk_orders_provs where c_order = @c_order and c_item_group <> 0;

; -------------------------------------
; количество группировок - нужно для ликвидации возможной ошибки округления
; (у последней группы сумма ндс будет вычисляться не умножением/делением, а просто контролируемым остатком)
; -------------------------------------
  $LONG(_current_group,_count_groups)
    _current_group = 0;
  -SQL drop table tmp_order_item_groups;
  SQL
    select @c_order c_order, c_item_group, count(*) items_count
    from $uk_orders_items s
      join $uk_ref_items i on i.c_item = s.c_item
    where
      s.c_order = @c_order
    group by i.c_item_group
    into temp tmp_order_item_groups with no log;
  SQL create unique index idx_tmp_order_item_groups_0 on tmp_order_item_groups (c_item_group);
  SQL update statistics high for table tmp_order_item_groups (c_item_group);

  SQL select count(*) into ?_count_groups from tmp_order_item_groups;
  SQL drop table tmp_order_item_groups;

; -------------------------------------
  $LONG(_c_item_group)
  $MONEY(_tax_nds)
  $MONEY(_isum_by_group,_isum_by_group_clear,_isum_by_group_nds,_rest_total_clear,_rest_total_nds)
    _tax_nds              = call("$CURCFG::cmds:get_setting_attr", $SETTING_PARAM_TAX_NDS,  @@c_branch, "value_m");
    _isum_by_group        = 0;
    _isum_by_group_clear  = 0;
    _isum_by_group_nds    = 0;
    _rest_total_clear     = @@_isum_total_clear;
    _rest_total_nds       = @@_isum_total_nds;

  CURSOR
    select i.c_item_group, sum(s.isum) into ?_c_item_group, ?_isum_by_group
    from $uk_orders_items s
      join $uk_ref_items i on i.c_item = s.c_item
    where
      s.c_order = @c_order
    group by i.c_item_group
  : call("$CURCFG::$CURSEC:_insert_isum_into_stock_order", @@c_order, @@_c_item_group, @@_isum_by_group);
#}

;> ----------------------------------------------------------------------------
;> __insert_isum_into_stock_order
;> ----------------------------------------------------------------------------
const char _insert_isum_into_stock_order_parms=_c_order,_c_item_group,_isum_by_group
const char _insert_isum_into_stock_order=\
#{
  _current_group = @@_current_group + 1;

  (@@_current_group == @@_count_groups)
      ? call("$CURCFG::$CURSEC:_set_group_isums_equal_to_rests")
      : call("$CURCFG::$CURSEC:_calc_group_isums", @@_isum_by_group);

  call("$CURCFG::cmds_orders:add_isum_to_order", @@_c_order, @@_c_item_group, $SCHEMA_ISUM_STOCKS_PURCHASE_GROUP,       @@_isum_by_group,       0);
  call("$CURCFG::cmds_orders:add_isum_to_order", @@_c_order, @@_c_item_group, $SCHEMA_ISUM_STOCKS_PURCHASE_GROUP_CLEAR, @@_isum_by_group_clear, 0);
  call("$CURCFG::cmds_orders:add_isum_to_order", @@_c_order, @@_c_item_group, $SCHEMA_ISUM_STOCKS_PURCHASE_GROUP_NDS,   @@_isum_by_group_nds,   0);
#}

;> ----------------------------------------------------------------------------
;> __set_group_isums_equal_to_rests
;> ----------------------------------------------------------------------------
const char _set_group_isums_equal_to_rests=\
#{
  _isum_by_group_nds   = @@_rest_total_nds;
  _isum_by_group_clear = @@_rest_total_clear;
#}

;> ----------------------------------------------------------------------------
;> __calc_group_isums
;> ----------------------------------------------------------------------------
const char _calc_group_isums_parms=_isum_by_group
const char _calc_group_isums=\
#{
; -------------------------------------
; выделяем НДС и вычисляем чистую сумму
; -------------------------------------
  _isum_by_group_nds   = @@_isum_by_group - round(@@_isum_by_group/(1 + @_tax_nds * 0.01), 2);
  _isum_by_group_clear = @@_isum_by_group - @@_isum_by_group_nds;

; -------------------------------------
; уменьшаем остатки по чистой сумме и НДС
; -------------------------------------
  _rest_total_nds   = @@_rest_total_nds   - @@_isum_by_group_nds;
  _rest_total_clear = @@_rest_total_clear - @@_isum_by_group_clear;
#}



;> ----------------------------------------------------------------------------
;> __recalc_params
;    пересчет всех возможных параметров, которое могут быть связанны с распоряжением текущего типа
;> ----------------------------------------------------------------------------
const char _recalc_params=\
#{
; -------------------------------------
; 0) для определенных групп распоряжений (например по работникам)
;    пересчитываем суммы/параметры в псевдо-распоряжениях для обнуления ежегодных параметров на начало года
; -------------------------------------
  call("$CURCFG::cmds_recalc:_reset_annual_employee_params", @@c_employee, long(@@op_day), @@order_type);


;  return(0);

; -------------------------------------
; 1) 
;    таблица с распоряжением для пересчета
;    (нужно для унификации процедуры и для возможного использования пересчета по нескольким распоряжениям)
; -------------------------------------
  -SQL drop table tmp_orders_for_recalc;
  SQL create temp table tmp_orders_for_recalc (c_order int) with no log;
  SQL insert into tmp_orders_for_recalc (c_order) values (@c_order);
  SQL create unique index idx_tmp_orders_for_recalc_0 on tmp_orders_for_recalc (c_order);
  SQL update statistics high for table tmp_orders_for_recalc (c_order);

; -------------------------------------
; 2) 
;    выявляем все уникальные сущности по которым будет идти пересчет данных
;    (по контрам группировка - по c_contractor / по работникам - по c_employee / etc)
; -------------------------------------
  $CHAR(_pipe_recalc_name)
  CURSOR
    SELECT DISTINCT a.cfg_attr into ?_pipe_recalc_name
    FROM $uk_ref_abbrs a
    WHERE
      a.abbr MATCHES "CALC_ENTITY_*" AND
      EXISTS (
               SELECT *
               FROM $uk_ref_calc_params_rules r
               WHERE
                 r.entity_type     = a.type AND
                 r.order_type = @order_type
             )
    : call("$CURCFG::cmds_recalc:" + string(@@_pipe_recalc_name), "tmp_orders_for_recalc");

; -------------------------------------
;  возможные варианты вызовов (хранятся в настроечной таблице uk_ref_calc_params_rules)
; _recalc_params_for_employees
; _recalc_params_for_contractors
; -------------------------------------
#}

; -----------------------------------------------------------------------------
; номенклатуры для распоряжения, используется для:
;   1) запасов
; -----------------------------------------------------------------------------
[UK_Orders_Items]
const char main_class=DB_Kstat
const char read_access=any
const char update_access=PLACE_UK_ORDERS
const char insert_access=PLACE_UK_ORDERS
const char delete_access=PLACE_UK_ORDERS
const char mode=sidur
const char ks_table=$uk_orders_items
const char ks_keys=c_order,c_item
const char ks_defaults=\
#{";"
  c_order:0
  c_item:0
  quantity:0
  isum:0
  cost:0
#}

const char synonyms=\
#{";"
  _item_accnt_ncurracc[20]     == Item.ItemGroup.Accnt.ncurracc
  _item_accnt_exp_ncurracc[20] == Item.ItemGroup.AccntExp.ncurracc
#}

const char foreigns=\
#{";"
  Order($CURCFG::UK_Orders_Def):c_order
  Item($CURCFG::UK_REF_Items):c_item
#}

const char pipe_post_insert=\
#{
  call("$CURCFG::$CURSEC:_refresh_order_isums_by_items", @@c_order);
#}

const char pipe_post_update=\
#{
  call("$CURCFG::$CURSEC:_refresh_order_isums_by_items", @@c_order);
#}

const char pipe_post_delete=\
#{
  call("$CURCFG::$CURSEC:_refresh_order_isums_by_items", @@c_order);
#}

;> ----------------------------------------------------------------------------
;> __refresh_order_isums_by_items
;> ----------------------------------------------------------------------------
const char _refresh_order_isums_by_items_parms=_c_order
const char _refresh_order_isums_by_items=\
#{
  $CURCFG::UK_Orders_Def.SetKeyLong("c_order", @@_c_order);
  $CURCFG::UK_Orders_Def.DoSpc($spc_uk_orders_refresh_isums_by_items, "<null>");
#}


; -----------------------------------------------------------------------------
; параметры распоряжения
; -----------------------------------------------------------------------------
[UK_Orders_Params]
const char main_class=DB_Kstat
const char read_access=any
const char update_access=PLACE_UK_ORDERS
const char insert_access=PLACE_UK_ORDERS
const char delete_access=PLACE_UK_ORDERS
const char mode=sidur
const char ks_table=$uk_orders_params
const char ks_keys=c_order,param_type
const char ks_defaults=\
#{";"
  c_order:0
  param_type:0
  param_value_i:
  param_value_m:
  param_value_s:
  param_value_d:
#}

const char foreigns=\
#{";"
  Order($CURCFG::UK_Orders_Def):c_order
  ParamType($CURCFG::UK_Abbrs_ParamTypes):param_type(type)
;
  Accnt:param_value_i(c_accnt)
#}

const char synonyms=\
#{
  param_value[20]=?/param_value_i,param_value_m,param_value_d,param_value_s/
                      (
                          isnull(@param_value_i) 
                            ? isnull(@param_value_m)
                                ? isnull(@param_value_d)
                                    ? string(@param_value_s)
                                    : rfmtdate(@param_value_d, "dd.mm.yyyy")
                                : rfmtdec(@param_value_m, "# ### ##&.&&")
                            : string(@param_value_i)
                          
                      );
#}



; -----------------------------------------------------------------------------
; суммы распоряжения 
;   такие же параметры, только вынесены в отдельный объект т.к. вставка сюда
;   должна порождать N записей, согласно схеме проводок
; -----------------------------------------------------------------------------
[UK_Orders_ISums_IN_Schema]
const char main_class=DB_Kscurs
const char parent_kstat=$CURCFG::UK_Orders_ISums
const char ks_where=\
#{
  [isum] > 0
  and exists
      (
        select *
        from $uk_ref_schema s
        where
          s.order_type = [Order.order_type] and
          s.isum_type = [isum_type] and
          @today between s.prev_change and s.next_change
      )
#}



[UK_Orders_ISums]
const char main_class=DB_Kstat
const char read_access=any
const char update_access=PLACE_UK_ORDERS
const char insert_access=PLACE_UK_ORDERS
const char delete_access=PLACE_UK_ORDERS
const char mode=sidur
const char ks_table=$uk_orders_isums
const char ks_keys=c_order,isum_type,c_item_group
const char ks_defaults=\
#{";"
  c_order:0
  isum_type:0
  c_item_group:0
  op_day:0
  isum:0
#}

const char foreigns=\
#{";"
  Order($CURCFG::UK_Orders_Def):c_order
  IsumType($CURCFG::UK_Abbrs_SchemaIsums):isum_type(type)
  ItemGroup($CURCFG::UK_REF_Item_Groups):c_item_group
#}

;const char refs_x1=\
;#{";"
;  Schema($CURCFG::UK_REF_Schema):Order.order_type(order_type),isum_type
;#}

;> ----------------------------------------------------------------------------
;> __synonyms
;> ----------------------------------------------------------------------------
const char synonyms=\
#{";"
  _order_type[LONG]           == Order.order_type
  _op_day[LONG]               == Order.op_day
; счет группы номенклатур (используется в схеме проводок)
  _accnt_item_group[LONG]     == ItemGroup.c_accnt;
  _accnt_exp_item_group[LONG] == ItemGroup.c_accnt_exp;
#}

;> ----------------------------------------------------------------------------
;> __spc_codes
;> ----------------------------------------------------------------------------
const char spc_codes=\
#{
  $spc_get_tunning_info (<@_get_tunning_info (isum) >):#P_get_tunning_info_parms;
#}

;> ------------------------------------------------
;> __get_tunning_info
;    получение аттрибутов объекта и сохранение их во внешней коллекции
;    для использования в Delphi
;> ------------------------------------------------
const char _get_tunning_info_parms=\
#{";"
  ext_coll_name:Имя внешней коллекции#Tstring_t
#}

const char _get_tunning_info=\
#{
  @ext_coll_name.RenewVarsFromColl(CURRENT.get_name());
#}

;> ----------------------------------------------------------------------------
;> __pipe_post_insert
;> ----------------------------------------------------------------------------
const char pipe_post_insert=\
#{
; -------------------------------------
; сумма должна быть значимой
; -------------------------------------
  (@@isum == 0) ? return(0) : 0;

; -------------------------------------
; в цикле по всем "проводкам" из схемы с текущим типом распоряжения и текущей суммой
; (вычисляем счета)
; -------------------------------------
  $LONG(_c_schema,_accnt_type_d,_accnt_type_c)
  $CHAR(_accnt_attr_debit,_accnt_attr_credit)
  CURSOR
    select s.c_schema, ad.cfg_attr, ac.cfg_attr
      into ?_c_schema, ?_accnt_attr_debit, ?_accnt_attr_credit
    from $uk_ref_schema s
      left join $uk_ref_abbrs ad on ad.type = s.accnt_type_d and ad.abbr matches 'SCHEMA_ACCNT_*'
      left join $uk_ref_abbrs ac on ac.type = s.accnt_type_c and ad.abbr matches 'SCHEMA_ACCNT_*'
    where
      s.order_type = @_order_type and
      s.isum_type  = @isum_type and
      @_op_day between s.prev_change and s.next_change
    order by s.number
    : call("$CURCFG::cmds_orders:_insert_order_prov", @@c_order, @@isum_type, @@c_item_group, @@op_day,
                                                      @@_c_schema, @@isum, @@_accnt_attr_debit, @@_accnt_attr_credit);
#}

;> ----------------------------------------------------------------------------
;> __pipe_post_update
;> ----------------------------------------------------------------------------
const char pipe_post_update=\
#{
; -------------------------------------
; все "проводки" из схемы с текущим типом распоряжения и текущей суммой
; -------------------------------------
  SQL
    update $uk_orders_provs set isum = @isum
    where
      c_order = @c_order and
      exists
        (
          select *
          from $uk_ref_schema s
          where
            s.order_type = @_order_type and
            s.isum_type  = @isum_type and
            @_op_day between s.prev_change and s.next_change and
            s.c_schema   = $uk_orders_provs.c_schema
        );
#}


[UK_Orders_Provs]
const char main_class=DB_Kstat
const char read_access=any
const char update_access=PLACE_UK_ORDERS
const char insert_access=PLACE_UK_ORDERS
const char delete_access=PLACE_UK_ORDERS
const char mode=sidur
const char ks_table=$uk_orders_provs
const char ks_keys=c_order,c_schema,c_item_group
const char ks_defaults=\
#{";"
  c_order:0
  c_schema:0
  c_item_group:0
  isum:0
  c_accnt_debit:0
  c_accnt_credit:0
  c_doc:0
  op_day:0
#}

const char foreigns=\
#{";"
  Order($CURCFG::UK_Orders_Def):c_order
  Schema($CURCFG::UK_REF_Schema):c_schema
  ItemGroup($CURCFG::UK_REF_Item_Groups):c_item_group
  KsConf:c_doc
  AccntCurrD(AccntCurr):c_accnt_debit(c_accnt),Order.c_curr(c_curr)
  AccntCurrC(AccntCurr):c_accnt_credit(c_accnt),Order.c_curr(c_curr)
#}

const char synonyms=\
#{";"
  accnt_info_full_d[120]=?(@AccntCurrD.necurracc + "\n\r" + @Schema.AccntType_D.sabbr + "\n\r" + @Schema.AccntType_D.cfg_attr + "\n\r" + string(@c_accnt_debit))
  accnt_info_full_c[120]=?(@AccntCurrC.necurracc + "\n\r" + @Schema.AccntType_C.sabbr + "\n\r" + @Schema.AccntType_C.cfg_attr + "\n\r" + string(@c_accnt_credit))
#}

;> ----------------------------------------------------------------------------
;> __spc_codes
;> ----------------------------------------------------------------------------
const char spc_codes=\
#{
  $spc_uk_orders_sending            (<@_order_docs_create ( 
                                                            c_order,c_accnt_debit,c_accnt_credit,isum,
                                                            _c_doc=KsConf.c_doc,
                                                            _op_day=op_day,
                                                            _c_curr=Order.c_curr,
                                                            _comment=Order.Param_CommentCustom.param_value_s
                                                          )
                                    >): PLACE_UK_ORDERS;
  $spc_uk_orders_performed          (<@_order_docs_perform (c_order,_isum=KsConf.isum,_c_doc=KsConf.c_doc)>): PLACE_UK_ORDERS;
  $spc_uk_orders_sending_rollback   (<@_order_docs_delete (c_order,_c_doc=KsConf.c_doc)>): PLACE_UK_ORDERS;
  $spc_uk_orders_performed_rollback (<@_order_docs_on_enter (c_order,_c_doc=KsConf.c_doc)>): PLACE_UK_ORDERS;
#}

;> ----------------------------------------------------------------------------
;> __pipe_pre_insert
;> ----------------------------------------------------------------------------
const char pipe_pre_insert=\
#{
  IO.op_day = (long(@@op_day) == 0) ? @@Order.op_day : @@op_day;
#}

;> ----------------------------------------------------------------------------
;> __order_docs_create
;> ----------------------------------------------------------------------------
const char _order_docs_create=\
#{
  (@@_c_doc == 0)
      ? 0
      : RaiseError(-1, "Проводка уже создана", "");
  
; -------------------------------------
; по-умолчанию проводка создается в текущем опер. дне
; поэтому после создания - переносим ее в опер. день распоряжения
; -------------------------------------
  (@@isum == 0)
      ? return(0)
      : 0;

  _c_doc=KernDocGenerateMem( @@c_accnt_debit, @@c_accnt_credit, @@_c_curr, @@isum, "[@c_order] " + @@_comment);
  call("crbase::UserUtils:_move_uni_doc", @@_c_doc, long(@@_op_day));

; -------------------------------------
; 
; -------------------------------------
  _coll_update  = Auth.obj_by_name("<null>", "DB_Coll");
    @_coll_update.ClearNames();
    @_coll_update.AssignVarLong("c_doc", @@_c_doc);
  @THIS.DoUpdateForColl(@@_coll_update);
  Auth.delete_obj_by_name(@@_coll_update);
#}

;> ----------------------------------------------------------------------------
;> __order_docs_perform
;> ----------------------------------------------------------------------------
const char _order_docs_perform=\
#{
  (@@_isum == 0)
      ? return(0)
      : 0;

  (@@_c_doc == 0)
      ? RaiseError(-1, "Проводка удалена в АБС!", "")
      : 0;

  KsConf.SetKeyLong("c_doc", @@_c_doc);
  KsConf.DoSpc($spcDocPerform, "<null>" );
#}

;> ----------------------------------------------------------------------------
;> __order_docs_delete
;> ----------------------------------------------------------------------------
const char _order_docs_delete=\
#{
; -------------------------------------
; сначала сбрасываем ссылку на документ
; -------------------------------------
  _coll_update  = Auth.obj_by_name("<null>", "DB_Coll");
    @_coll_update.ClearNames();
    @_coll_update.AssignVarLong("c_doc", 0);
  @THIS.DoUpdateForColl(@@_coll_update);
  Auth.delete_obj_by_name(@@_coll_update);

  (@@_c_doc == 0)
      ? return(0)
      : 0;
  KsConf.SetKeyLong("c_doc", @@_c_doc);
  KsConf.DoDelete();
#}

;> ----------------------------------------------------------------------------
;> __order_docs_on_enter
;> ----------------------------------------------------------------------------
const char _order_docs_on_enter=\
#{
  (@@_c_doc == 0)
      ? return(0)
      : 0;

  KsConf.SetKeyLong("c_doc",@@_c_doc);
  KsConf.DoSpc($spcDocToEnter, "<null>" );
#}



[UK_Orders_StatesHistory]
const char main_class=DB_Kstat
const char read_access=any
const char update_access=PLACE_UK_ORDERS
const char insert_access=PLACE_UK_ORDERS
const char delete_access=PLACE_UK_ORDERS
const char mode=sidur
const char ks_table=$uk_orders_states_history
const char ks_keys=c_order,time1
const char ks_defaults=\
#{";"
  c_order:0
  state:0
  c_user:@CurrUser.c_user
#}

const char foreigns=\
#{";"
  State($CURCFG::UK_Abbrs_OrderStates):state(type)
  Users:c_user
#}


;> ----------------------------------------------------------------------------
;> __change_history_state
;    из-за моих проблем с типом DTIME в объектах (нет работающих примеров) - вынужден работать через sql
;    поддержка истории изменения состояния распоряжения
;> ----------------------------------------------------------------------------
const char _change_history_state_parms=_c_order,_state,_c_user
const char _change_history_state=\
#{
  $DTIME(_time0)
    _time0 = current;

; -------------------------------------
; закрываем текущую (последнюю!) запись
; (при условии что ее уже не закрыли при двойной операции)
; -------------------------------------
  $LONG(_cnt)
  SQL select count(*) into ?_cnt from $uk_orders_states_history where c_order = @_c_order and time1 = extend('@_time0', year to second) - 1 units second;

  (@@_cnt == 0)
      ? ExecutePipe("SQL " +
                        "update $uk_orders_states_history set time1 = extend('@_time0', year to second) - 1 units second " +
                        "where c_order = @_c_order and '@_time0' between time0 and time1;")
      : 0;

; -------------------------------------
; вставляем новое состояние + время + пользователь
; (при двойной операции возможна ситуация, когда запись с текущим временем уже есть)
; -------------------------------------
  SQL delete from $uk_orders_states_history where c_order = @_c_order and time0 >= '@_time0';
  SQL insert into $uk_orders_states_history (c_order, state, c_user, time0, time1) values (@_c_order, @_state, @_c_user, '@_time0', '9999-12-31 23:59:59');
#}


[cmds_orders]

;> ----------------------------------------------------------------------------
;> __insert_order_prov
;     !!! ключевая процедура, вычисляющая реальные счета согласно схеме проводок !!!
;> ----------------------------------------------------------------------------
const char _insert_order_prov_parms=_c_order,_isum_type,_c_item_group,_op_day,_c_schema,_isum,_accnt_attr_d,_accnt_attr_c
const char _insert_order_prov=\
#{
; -------------------------------------
; вычисляем реальные счета по именам аттрибутов объекта UK_Orders_Def (!!!)
; -------------------------------------
  $CHAR(_attrs_order,_attrs_local)
    _attrs_order = joinstr(",", @@_accnt_attr_d, @@_accnt_attr_c);
    _attrs_local = joinstr(",", "_c_accnt_debit", "_c_accnt_credit");

  _coll_select = Auth.obj_by_name("<null>", "DB_Coll");
    @_coll_select.AddListOfNames(@@_attrs_order);


;    $CURCFG::UK_Orders_Def.SetKeyLong("c_order", @@_c_order);
;    $CURCFG::UK_Orders_Def.DoSelectForColl(@@_coll_select);

    $CURCFG::UK_Orders_ISums.SetKeyLong("c_order",      @@_c_order);
    $CURCFG::UK_Orders_ISums.SetKeyLong("isum_type",    @@_isum_type);
    $CURCFG::UK_Orders_ISums.SetKeyLong("c_item_group", @@_c_item_group);
    $CURCFG::UK_Orders_ISums.DoSelectForColl(@@_coll_select);


  $LONG(_c_accnt_debit,_c_accnt_credit)
    @_coll_select.SomeVarsToColl(@@_attrs_order, CURRENT.get_name(), @@_attrs_local);


  _isum           = isnull(@@_isum)           ? 0 : @@_isum;
  _c_accnt_debit  = isnull(@@_c_accnt_debit)  ? 0 : @@_c_accnt_debit;
  _c_accnt_credit = isnull(@@_c_accnt_credit) ? 0 : @@_c_accnt_credit;

  call("$CURCFG::$CURSEC:_check_field_for_zerro", @@_c_schema, "Cумма",        @@_isum);
  call("$CURCFG::$CURSEC:_check_field_for_zerro", @@_c_schema, "Счет дебета",  @@_c_accnt_debit);
  call("$CURCFG::$CURSEC:_check_field_for_zerro", @@_c_schema, "Счет кредита", @@_c_accnt_credit);

; -------------------------------------
; вставляем информацию для будущей проводки
; -------------------------------------
  _coll_insert  = Auth.obj_by_name("<null>", "DB_Coll");
    @_coll_insert.ClearNames();

    @_coll_insert.AssignVarLong("c_order",        @@_c_order);
    @_coll_insert.AssignVarLong("c_schema",       @@_c_schema);
    @_coll_insert.AssignVarLong("c_item_group",   @@_c_item_group);
    @_coll_insert.SetVarMoney("isum",             @@_isum);
    @_coll_insert.AssignVarLong("c_accnt_debit",  @@_c_accnt_debit);
    @_coll_insert.AssignVarLong("c_accnt_credit", @@_c_accnt_credit);
    @_coll_insert.AssignVarLong("op_day",         @@_op_day);

  $CURCFG::UK_Orders_Provs.DoInsertForColl(@@_coll_insert);
  Auth.delete_obj_by_name(@@_coll_insert);
#}


;> ----------------------------------------------------------------------------
;> __check_field_for_zerro
;> ----------------------------------------------------------------------------
const char _check_field_for_zerro_parms=_c_schema,_fld_name,_fld_value
const char _check_field_for_zerro=\
#{
  (@@_fld_value == 0)
      ? 0
      : return(0);

  RaiseError(-1, "Нулевое значение! [c_schema=@_c_schema]: Атрибут <@_fld_name>", "");
#}


;> ----------------------------------------------------------------------------
;> __change_prov_operday
;> ----------------------------------------------------------------------------
const char _change_prov_operday_parms=_c_order,_c_schema,_c_item_group,_op_day_new
const char _change_prov_operday=\
#{
  _coll_key = Auth.obj_by_name("<null>", "DB_Coll");
    @_coll_key.AssignVarLong("c_order",       @@_c_order);
    @_coll_key.AssignVarLong("c_schema",      @@_c_schema);
    @_coll_key.AssignVarLong("c_item_group",  @@_c_item_group);
  $CURCFG::UK_Orders_Provs.KeysFromCollection(@@_coll_key);

  _coll_update = Auth.obj_by_name("<null>", "DB_Coll");
    @_coll_update.AssignVarDate("op_day", @@_op_day_new);
  $CURCFG::UK_Orders_Provs.DoUpdateForColl(@@_coll_update);

  Auth.delete_obj_by_name(@@_coll_key);
  Auth.delete_obj_by_name(@@_coll_update);
#}

;> ----------------------------------------------------------------------------
;> __add_isum_to_order
;> ----------------------------------------------------------------------------
const char add_isum_to_order_parms=_c_order,_c_item_group,_isum_type,_isum,_op_day
const char add_isum_to_order=\
#{
  _coll_isums = Auth.obj_by_name("<null>", "DB_Coll");
    @_coll_isums.AssignVarLong("c_order",       @@_c_order);
    @_coll_isums.AssignVarLong("c_item_group",  @@_c_item_group);
    @_coll_isums.AssignVarLong("isum_type",     @@_isum_type);
    @_coll_isums.AssignVarLong("op_day",        @@_op_day);
    @_coll_isums.SetVarMoney("isum",            @@_isum);
  $CURCFG::UK_Orders_ISums.DoInsertForColl(@@_coll_isums);
  Auth.delete_obj_by_name(@@_coll_isums);
#}

;> ----------------------------------------------------------------------------
;> __add_item_to_order
;> ----------------------------------------------------------------------------
const char add_item_to_order_parms=_c_order,_c_item,_quantity,_isum,_cost
const char add_item_to_order=\
#{
  _coll_items = Auth.obj_by_name("<null>", "DB_Coll");
    @_coll_items.AssignVarLong("c_order",  @@_c_order);
    @_coll_items.AssignVarLong("c_item",   @@_c_item);
    @_coll_items.AssignVarLong("quantity", @@_quantity);
    @_coll_items.SetVarMoney("isum",       @@_isum);
    @_coll_items.SetVarMoney("cost",       @@_cost);
  $CURCFG::UK_Orders_Items.DoInsertForColl(@@_coll_items);
  Auth.delete_obj_by_name(@@_coll_items);
#}

;> ----------------------------------------------------------------------------
;> __add_item_to_order_sql
;    нужна при импорте данных из 1C (чтобы не срабатывал постобработчик)
;    (=> пересчет сумм/проводок - принудительный)
;> ----------------------------------------------------------------------------
const char add_item_to_order_sql_parms=_c_order,_c_item,_quantity,_isum,_cost
const char add_item_to_order_sql=\
#{
  SQL
    insert into $uk_orders_items (  c_order,   c_item,   quantity,   isum,   cost)
                          values (@_c_order, @_c_item, @_quantity, @_isum, @_cost);
#}


;> ----------------------------------------------------------------------------
;> __check_orders_on_unique
;> ----------------------------------------------------------------------------
const char _check_orders_on_unique_parms=_order_type,_date0,_date1,_c_conractor,_c_employee,_c_dogovor,_correct_quantity,_is_raise_error
const char _check_orders_on_unique=\
#{
  $CHAR(_where_contractor,_where_employee,_where_dogovor)
    _where_contractor = (@@_c_conractor == 0) ? ""  : "o.c_conractor = @_c_conractor and";
    _where_employee   = (@@_c_employee == 0)  ? ""  : "o.c_employee  = @_c_employee and";
    _where_dogovor    = (@@_c_dogovor == 0)  ? ""   : "o.c_dogovor  = @_c_dogovor and";

  $LONG(_cnt_orders)
  SQL
    select count(*) into ?_cnt_orders
    from $uk_orders_def o
    where
      o.order_type = @_order_type and
      o.op_day between @_date0 and @_date1 and
      @_where_contractor
      @_where_employee
      @_where_dogovor
      o.state      > $ORDER_STATE_DELETED;

; 
  (@@_cnt_orders == @@_correct_quantity)
      ? return(@@_correct_quantity)
      : 0;

; 
  (@@_is_raise_error == $_FALSE)
      ? return(@@_cnt_orders)
      : 0;

  $CHAR(_order_type_sabbr,_shname)

  SQL select sabbr into ?_order_type_sabbr from $uk_ref_abbrs where type = @_order_type;

  (@@_c_conractor == 0) ? 0 : ExecutePipe("SQL select shname into ?_shname from $uk_contractors_def where c_contractor = @_c_conractor;");
  (@@_c_employee  == 0) ? 0 : ExecutePipe("SQL select shname into ?_shname from $uk_employees_def   where c_employee   = @_c_employee;");
  (@@_c_dogovor   == 0) ? 0 : ExecutePipe("SQL select shname into ?_shname from $uk_dogovors_def    where c_dogovor    = @_c_dogovor;");
  
  $CHAR(_err_ext)
    _err_ext = "";
    _err_ext = (@@_c_conractor == 0) ? @@_err_ext : "контрагенту";
    _err_ext = (@@_c_employee  == 0) ? @@_err_ext : "сотруднику";
    _err_ext = (@@_c_dogovor  == 0)  ? @@_err_ext : "договору";

  $CHAR(_err_ext2)
    _err_ext2 = (@@_correct_quantity == 0) ? "уже" : "еще не";
  
  RaiseError(-1, "Распоряжение типа [" + string(@@_order_type_sabbr) + "] по " + string(@@_err_ext) + " [" + string(@@_shname) + "] " + string(@@_err_ext2) + " создано!", "");
#}


;> ----------------------------------------------------------------------------
;> __check_for_existing_orders
;> ----------------------------------------------------------------------------
const char _check_for_existing_orders_parms=_key_name,_key_value,_entity_name
const char _check_for_existing_orders=\
#{
  $LONG(_count_orders)
  SQL
    select count(*) into ?_count_orders
    from $uk_orders_def o
    where
      o.@{_key_name} = @_key_value;

  (@@_count_orders == 0)
      ? 0
      : RaiseError(-1, "Нельзя удалить " + @@_entity_name + ", т.к. по нему есть распоряжения!", "");
#}


; =============================================================================
; пересчет параметров
; =============================================================================
[cmds_recalc]

;> ----------------------------------------------------------------------------
;> __recalc_params_for_employees
;> ----------------------------------------------------------------------------
const char _recalc_params_for_employees_parms=_tbl_with_orders
const char _recalc_params_for_employees=\
#{
  return(0);

; -------------------------------------
; 1) готовим временную таблицу со всеми работниками, по которым будет пересчет остатков
; -------------------------------------
  -SQL drop table tmp_recalc_employee_init;
  SQL
    create temp table tmp_recalc_employee_init (
      c_employee  int,
      date_recalc date
    ) with no log;
  SQL create unique index idx_tmp_recalc_employee_init_0 on tmp_recalc_employee_init (c_employee, date_recalc);
  SQL
    insert into tmp_recalc_employee_init (c_employee, date_recalc)
      select o.c_employee, min(o.op_day)
      from @_tbl_with_orders t
        join $uk_orders_def o on o.c_order = t.c_order
      group by o.c_employee;
  SQL update statistics high for table tmp_recalc_employee_init (c_employee, date_recalc);

  $LONG(_cnt)
  SQL select count(*) into ?_cnt from tmp_recalc_employee_init;
  (@@_cnt == 0)
      ? return(0)
      : 0;


; -------------------------------------
; 2) по каждому параметру-правилу
; -------------------------------------
  $LONG()
  $CHAR(_calc_param_type)
  CURSOR
    select calc_param_type into ?_calc_param_type
    from $uk_ref_calc_params_rules
    where
      entity_type = $CALC_ENTITY_EMPLOYEE

; -------------------------------------
; 2) удаляем историю параметров по сотруднику, начиная с даты пересчета
; -------------------------------------



; -------------------------------------
; 1) готовим временную таблицу со всеми распоряжениями по работнику, начиная с даты распоряжения (включительно)
; -------------------------------------
  -SQL drop table tmp_recalc_orders_employee;
  SQL
    create temp table tmp_recalc_orders_employee (
      c_order    int,
      c_employee int,
    ) with no log;
  SQL create unique index idx_tmp_recalc_orders_employee_0 on tmp_recalc_orders_employee (c_order);
  SQL create        index idx_tmp_recalc_orders_employee_1 on tmp_recalc_orders_employee (c_employee);

  SQL insert into
#}

;> ----------------------------------------------------------------------------
;> __recalc_employee_param_money
;> ----------------------------------------------------------------------------
const char _recalc_employee_param_money_parms=_c_order,_c_employee,_calc_param_type
const char _recalc_employee_param_money=\
#{
  call("$CURCFG::$CURSEC:_recalc_employee_param_int", @@_c_order, @@_c_employee, @@_calc_param_type, "");
#}

;> ----------------------------------------------------------------------------
;> __recalc_employee_param_int
;> ----------------------------------------------------------------------------
const char _recalc_employee_param_int_parms=_c_order,_c_employee,_calc_param_type
const char _recalc_employee_param_int=\
#{
#}


;> ----------------------------------------------------------------------------
;> __recalc_params_for_contractors
;> ----------------------------------------------------------------------------
const char _recalc_params_for_contractors_parms=_tbl_with_orders
const char _recalc_params_for_contractors=\
#{
#}


;> ----------------------------------------------------------------------------
;> __recalc_employee_param
;> ----------------------------------------------------------------------------
const char _recalc_employee_param_parms=_c_order,_c_employee,_calc_param_type,
const char _recalc_employee_param=\
#{
#}

;> ----------------------------------------------------------------------------
;> __reset_annual_employee_params
;    пересчет "сбрасываемых" сумм/параметров (нужно чтобы в начале года обнулить годовые параметры)
;    исходим из того, что все "сбрасывающие" распоряжения уже созданы
;    (при создании работника согласно таблицы $utl_year_dates, где жестко забиты даты до 2070 года)
;> ----------------------------------------------------------------------------
const char _reset_annual_employee_params_parms=_c_employee,_op_day,_order_type
const char _reset_annual_employee_params=\
#{
  (@@_c_employee == 0) ? return(0) : 0;

; -------------------------------------  
; 1) текущий период
; -------------------------------------  
  $LONG(_cfdoy,_cldoy)
    _cfdoy = CldGetLimit(@@_op_day, "cfdoy");
    _cldoy = CldGetLimit(@@_op_day, "cldoy");

; -------------------------------------
; 2) находим псевдо-распоряжение по работнику за 01 января следующего года и обновляем в нем суммы и параметры
; -------------------------------------
  $LONG(_c_order_reset)
  -SQL
    select c_order into ?_c_order_reset
    from $uk_orders_def
    where
      op_day     = @_cldoy + 1 and
      c_employee = @_c_employee and
      order_type = $ORDER_TYPE_DUMMY_EMPLOYEE_INIT and
      state      > $ORDER_STATE_DELETED;
  _c_order_reset = isnull(@@_c_order_reset) ? 0 : @@_c_order_reset;
  (@@_c_order_reset == 0)
      ? return(0)
      : 0;

; -------------------------------------  
; 3) формируем таблицы с уникальными суммами/параметрами, которые связаны с текущим типом распоряжения 
;    и которые необходимо пересчитать в ближайшем "сбрасываемом распоряжении"
; -------------------------------------  
  call("$CURCFG::$CURSEC:_create_table_for_recalc", "tmp_resetisum_types",  "$uk_ref_calc_resetisums_rules",  "resetisum_type",  @@_order_type);
  call("$CURCFG::$CURSEC:_create_table_for_recalc", "tmp_resetparam_types", "$uk_ref_calc_resetparams_rules", "resetparam_type", @@_order_type);

; -------------------------------------  
; 4) вычисляем новое значение для всех сумм и параметров, связанных с типом текущего распоряжения 
; -------------------------------------  
  call("$CURCFG::$CURSEC:_recalc_reset_isums",  "tmp_resetisum_types",  @@_c_order_reset, @@_c_employee, @@_cfdoy, @@_cldoy);
  call("$CURCFG::$CURSEC:_recalc_reset_params", "tmp_resetparam_types", @@_c_order_reset, @@_c_employee, @@_cfdoy, @@_cldoy);


; -------------------------------------  
  -SQL drop table tmp_resetisum_types;
  -SQL drop table tmp_resetparam_types;
#}

;> ----------------------------------------------------------------------------
;> __recalc_reset_isums
;> ----------------------------------------------------------------------------
const char _recalc_reset_isums_parms=_tmp_table,_c_order,_c_employee,_date0,_date1
const char _recalc_reset_isums=\
#{
  $LONG(_isum_type)
  CURSOR
    select resetisum_type into ?_isum_type
    from @_tmp_table
  : call("$CURCFG::$CURSEC:_recalc_annual_isum_type", @@_isum_type, @@_c_order, @@_c_employee, @@_date0, @@_date1);
#}

;> ----------------------------------------------------------------------------
;> __recalc_reset_params
;> ----------------------------------------------------------------------------
const char _recalc_reset_params_parms=_tmp_table,_c_order,_c_employee,_date0,_date1
const char _recalc_reset_params=\
#{
  $LONG(_param_type)
  CURSOR
    select resetparam_type into ?_param_type
    from @_tmp_table
  : call("$CURCFG::$CURSEC:_recalc_annual_param_type", @@_param_type, @@_c_order, @@_c_employee, @@_date0, @@_date1);
#}

;> ----------------------------------------------------------------------------
;> __recalc_annual_isum_type
;    !!! _c_employee - сделать параметром, когда будут остатки по другим сущностям !!!
;> ----------------------------------------------------------------------------
const char _recalc_annual_isum_type_parms=_resetisum_type,_c_order,_c_employee,_date0,_date1
const char _recalc_annual_isum_type=\
#{
  $MONEY(_new_isum)
  -SQL
    select sum(s.isum) into ?_new_isum
    from $uk_ref_calc_resetisums_rules r
      join $uk_orders_def o   on
                                 o.order_type = r.order_type and
                                 o.op_day between @_date0 and @_date1 and
                                 o.state >= $ORDER_STATE_PRINTED and
                                 o.c_employee = @_c_employee
      join $uk_orders_isums s on
                                 s.c_order   = o.c_order and
                                 s.isum_type = r.order_isum_type

    where
      r.resetisum_type = @_resetisum_type;
  _new_isum = isnull(@@_new_isum) ? 0 : @@_new_isum;

  SQL delete from $uk_orders_isums where c_order = @_c_order and isum_type = @_resetisum_type;
  SQL insert into $uk_orders_isums (c_order, isum_type, isum, c_item_group) values (@_c_order, @_resetisum_type, @_new_isum, 0);
#}

;> ----------------------------------------------------------------------------
;> __recalc_annual_param_type
;    !!! _c_employee - сделать параметром, когда будут остатки по другим сущностям !!!
;> ----------------------------------------------------------------------------
const char _recalc_annual_param_type_parms=_resetparam_type,_c_order,_c_employee,_date0,_date1
const char _recalc_annual_param_type=\
#{
  $MONEY(_new_param)
  -SQL
    select sum(p.param_value_i) into ?_new_param
    from $uk_ref_calc_resetparams_rules r
      join $uk_orders_def o   on
                                 o.order_type = r.order_type and
                                 o.op_day between @_date0 and @_date1 and
                                 o.state >= $ORDER_STATE_PRINTED and
                                 o.c_employee = @_c_employee
      join $uk_orders_params p on
                                 p.c_order    = o.c_order and
                                 p.param_type = r.order_param_type

    where
      r.resetparam_type = @_resetparam_type;
  _new_param = isnull(@@_new_param) ? 0 : @@_new_param;


  SQL delete from $uk_orders_params where c_order = @_c_order and param_type = @_resetparam_type;
  SQL insert into $uk_orders_params (c_order, param_type, param_value_i) values (@_c_order, @_resetparam_type, @_new_param);
#}


;> ----------------------------------------------------------------------------
;> __create_table_for_recalc
;> ----------------------------------------------------------------------------
const char _create_table_for_recalc_parms=_tmp_table,_reset_table,_reset_attr,_order_type
const char _create_table_for_recalc=\
#{
; -------------------------------------
; таблица со сбрасываемыми суммами, которые связаны с текущим типом распоряжения
; -------------------------------------
  -SQL drop table @_tmp_table;
  SQL
    create temp table @_tmp_table (
      @_reset_attr int
    ) with no log;
  SQL
    insert into @_tmp_table (@_reset_attr)
      select distinct @_reset_attr
      from @_reset_table
      where
        order_type = @_order_type;
  SQL create unique index idx_@{_tmp_table}_0 on @_tmp_table (@_reset_attr);
  SQL update statistics high for table @_tmp_table (@_reset_attr);

  $LONG(_result)
  SQL select count(*) into ?_result from @_tmp_table;

  return(@@_result);
#}


; -----------------------------------------------------------------------------
; именованные константы
; -----------------------------------------------------------------------------
template [UK_Abbrs_View]
const char main_class=DB_Kscurs
const char parent_kstat=$CURCFG::UK_Abbrs
char ks_order=type

[UK_Abbrs]
const char main_class=DB_Kstat
const char read_access=any
const char update_access=PLACE_NORIGHT
const char mode=sur
const char ks_table=$uk_ref_abbrs
const char ks_keys=type

[UK_Abbrs_UserModes] default: UK_Abbrs_View
char ks_where=[abbr] matches 'USER_MODE_*'

[UK_Abbrs_ChiefTypes] default: UK_Abbrs_View
char ks_where=[abbr] matches 'CHIEF_TYPE_*'

[UK_Abbrs_OrderTypes] default: UK_Abbrs_View
char ks_where=[abbr] matches 'ORDER_TYPE_*'

[UK_Abbrs_SettingTypes] default: UK_Abbrs_View
char ks_where=[abbr] matches 'SETTING_TYPE_*'

[UK_Abbrs_SettingParams] default: UK_Abbrs_View
char ks_where=[abbr] matches 'SETTING_PARAM_*'

; -----------------------------------------------------------------------------
[UK_Abbrs_SchemaIsums] default: UK_Abbrs_View
char ks_where=[abbr] matches 'SCHEMA_ISUM_*'

[UK_Abbrs_SchemaResetIsums] default: UK_Abbrs_View
char ks_where=[abbr] matches 'SCHEMA_ISUM_*_RESET'

[UK_Abbrs_SchemaIsums_WithoutReset] default: UK_Abbrs_View
char ks_where=[abbr] matches 'SCHEMA_ISUM_*' AND [abbr] not matches '*_RESET'

; -----------------------------------------------------------------------------
[UK_Abbrs_SchemaAccnts] default: UK_Abbrs_View
char ks_where=[abbr] matches 'SCHEMA_ACCNT_*'

[UK_Abbrs_SchemaProvs] default: UK_Abbrs_View
char ks_where=[abbr] matches 'SCHEMA_PROV_*'

[UK_Abbrs_SchemaComments] default: UK_Abbrs_View
char ks_where=[abbr] matches 'SCHEMA_COMMENT_*'

[UK_Abbrs_OrderStates] default: UK_Abbrs_View
char ks_where=[abbr] matches 'ORDER_STATE_*'

[UK_Abbrs_OrderStates_All] default: UK_Abbrs_View
char ks_where=[abbr] matches '*ORDER_STATE_*'


[UK_Abbrs_DogovorKinds] default: UK_Abbrs_View
char ks_where=[abbr] matches 'DOG_KIND_*'

[UK_Abbrs_DogovorKindsLabours] default: UK_Abbrs_View
char ks_where=[abbr] matches 'DOG_KIND_LABOUR*'


[UK_Abbrs_DogovorParams] default: UK_Abbrs_View
char ks_where=[abbr] matches 'DOGPARAM_*'

[UK_Abbrs_MainType] default: UK_Abbrs_View
char ks_where=[abbr] matches 'MAIN_TYPE_*'

[UK_Abbrs_MainType_OS] default: UK_Abbrs_View
char ks_where=[abbr] matches 'MAIN_TYPE_OS_*'

[UK_Abbrs_MainType_Emloyee] default: UK_Abbrs_View
char ks_where=[abbr] matches 'MAIN_TYPE_EMPLOYEE_*'


[UK_Abbrs_DepreciationType] default: UK_Abbrs_View
char ks_where=[abbr] matches 'DEPRECIATION_TYPE*'
const char foreigns=Ext($CURCFG::UK_REF_Depreciations):type

; -----------------------------------------------------------------------------
[UK_Abbrs_ParamTypes] default: UK_Abbrs_View
char ks_where=[abbr] matches 'ORDER_PARAM_*'

[UK_Abbrs_ResetParamTypes] default: UK_Abbrs_View
char ks_where=[abbr] matches 'ORDER_PARAM_*_RESET'

[UK_Abbrs_ParamTypes_WithoutReset] default: UK_Abbrs_View
char ks_where=[abbr] matches 'ORDER_PARAM_*' AND [abbr] not matches '*_RESET'

; -----------------------------------------------------------------------------
[UK_Abbrs_AccntDogTypes] default: UK_Abbrs_View
char ks_where=[abbr] matches 'ACCNTDOG_TYPE_*'

[UK_Abbrs_IsumDogTypes] default: UK_Abbrs_View
char ks_where=[abbr] matches 'ISUMDOG_TYPE_*'

[UK_Abbrs_IsumEmployeeTypes] default: UK_Abbrs_View
char ks_where=[abbr] matches 'ISUMEMPLOYEE_TYPE_*'

[UK_Abbrs_AccntSettingTypes] default: UK_Abbrs_View
char ks_where=[abbr] matches 'ACCNTSETTING_TYPE_*'
char ks_order=sabbr

[UK_Abbrs_AccntContractorTypes] default: UK_Abbrs_View
char ks_where=[abbr] matches 'ACCNTCONTRACTOR_TYPE_*'

[UK_Abbrs_AccntEmployeeTypes] default: UK_Abbrs_View
char ks_where=[abbr] matches 'ACCNTEMPLOYEE_TYPE_*'

[UK_Abbrs_Firms] default: UK_Abbrs_View
char ks_where=[abbr] matches 'FIRM_*'

[UK_Abbrs_Departments] default: UK_Abbrs_View
char ks_where=[abbr] matches 'DEPARTMENT_*'

[UK_Abbrs_Spc_OrdersCreate] default: UK_Abbrs_View
char ks_where=[abbr] matches 'spc_ordercreate_*'

[UK_Abbrs_CalcEntity] default: UK_Abbrs_View
char ks_where=[abbr] matches 'CALC_ENTITY_*'


[UK_Abbrs_CalcParams] default: UK_Abbrs_View
char ks_where=[abbr] matches 'CALC_PARAM_*'

[UK_Abbrs_Order_Params_And_Sums] default: UK_Abbrs_View
char ks_where=[abbr] matches 'ORDER_PARAM_*' OR [abbr] matches 'SCHEMA_ISUM_*'

[UK_Abbrs_Tax_Kinds] default: UK_Abbrs_View
char ks_where=[abbr] matches 'TAXKIND_*'

[UK_Abbrs_Period_Kinds] default: UK_Abbrs_View
char ks_where=[abbr] matches 'PERIOD_KIND_*'

[UK_Abbrs_PeriodReports_Kinds] default: UK_Abbrs_View
char ks_where=[abbr] matches 'PERIOD_KIND_*' and [type] not in ($PERIOD_KIND_GLOBAL)


[UK_Abbrs_Period_Filter_Kinds] default: UK_Abbrs_View
char ks_where=[abbr] matches 'PERIODFILTER_KIND_*'

[UK_Abbrs_Report_Groups] default: UK_Abbrs_View
char ks_where=[abbr] matches 'REPORT_GROUP_*'

[UK_Abbrs_Report_States] default: UK_Abbrs_View
char ks_where=[abbr] matches 'REPORT_STATE_*'

[UK_Abbrs_RepPeriod_Types] default: UK_Abbrs_View
char ks_where=[abbr] matches 'REPPERIOD_TYPE_*'

[UK_Abbrs_RepParam_Types] default: UK_Abbrs_View
char ks_where=[abbr] matches 'REPPARAM_TYPE_*'

[UK_Abbrs_MSFO_Reports] default: UK_Abbrs_View
char ks_where=[abbr] matches 'MSFO_REPORT_*'

[UK_Abbrs_Rest_Kinds] default: UK_Abbrs_View
char ks_where=[abbr] matches 'RESTKIND_*'

[UK_Abbrs_Operation_States] default: UK_Abbrs_View
char ks_where=[abbr] matches 'OPERATION_STATE_*'

[UK_Abbrs_Cotractors_Kinds] default: UK_Abbrs_View
char ks_where=[abbr] matches 'CONTRACTOR_KIND_*'

[UK_Abbrs_Operation_Spcs] default: UK_Abbrs_View
char ks_where=[abbr] matches 'spc_operation_*' and [type] not in ($spc_operation_do_spc)

[UK_Abbrs_Spc_Kinds] default: UK_Abbrs_View
char ks_where=[abbr] matches 'SPC_KIND_*'

[UK_Abbrs_AccntKinds_for_0420005] default: UK_Abbrs_View
char ks_where=\
#{
  [abbr] matches 'ACCNTCONTRACTOR_TYPE_*' or 
  [abbr] matches 'ACCNTSETTING_TYPE_*'
#}

[UK_Abbrs_Calc_Kinds] default: UK_Abbrs_View
char ks_where=[abbr] matches 'CALC_KIND_*'



[cmds]


;> ----------------------------------------------------------------------------
;> __
;> ----------------------------------------------------------------------------
const char create_turns_isum_parms=_tbl
const char create_turns_isum=\
#{
#}


;> ----------------------------------------------------------------------------
;> __get_setting_attr
;> ----------------------------------------------------------------------------
const char get_setting_attr_parms=_setting_param,_c_branch,_attr
const char get_setting_attr=\
#{
  $CHAR(value_s)
  $LONG(value_i)
  $LONG(value_d)
  $MONEY(value_m)

    call("crbase::cmds:getObjectInfo_To_Current",
            "$CURCFG::UK_REF_Settings", 
            "setting_param", @@_setting_param,
            "c_branch",      @@_c_branch,
            "@_attr",        "@_attr");

  return(@@@_attr);
#}

;> ----------------------------------------------------------------------------
;> __calc_ensuranse_isum
;    вычисление сложной суммы для перечисления страховых взносов
;    (для ПФР и ФСС)
;> ----------------------------------------------------------------------------
const char _calc_complicated_ensuranse_isum_parms=_isum,_anual0,_type_base_isum,_type_tax_base,_type_tax_extra
;#{";"
;  _isum:Текущая сумма вознаграждения#Tmoney_t
;  _anual0:Общая сумма вознаграждений за год (до текущей)#Tmoney_t
;
;  _type_base_isum:Тип, чтобы найти базовая сумма, после которой меняется процент#Tlong_t
;  _type_tax_base:Тип, чтобы найти базовый процент#Tlong_t
;  _type_tax_extra:Тип, чтобы найти экстра процент при привышении базовой суммы#Tlong_t
;#}
const char _calc_complicated_ensuranse_isum=\
#{
; -------------------------------------
; получаем значения по их типам
; -------------------------------------
  $MONEY(__base_isum,__tax_base,__tax_extra)
    __base_isum = call("$CURCFG::cmds:get_setting_attr", @@_type_base_isum,  $BRANCH_OUR, "value_m");
    __tax_base  = call("$CURCFG::cmds:get_setting_attr", @@_type_tax_base,   $BRANCH_OUR, "value_m");
    __tax_extra = call("$CURCFG::cmds:get_setting_attr", @@_type_tax_extra,  $BRANCH_OUR, "value_m");
  

; -------------------------------------
; считаем сумму превышающую базовый лимит => остальное будет по стандартному проценту
; =MIN(MAX(0;(salary_total+salary) - base_pfr); salary)
; -------------------------------------
  $MONEY(__ensurance_extra,__ensurance_base)
    __ensurance_extra = @@_anual0 + @@_isum - @@__base_isum;
    __ensurance_extra = (@@__ensurance_extra < 0      ) ? 0              : money(@@__ensurance_extra);
    __ensurance_extra = (@@__ensurance_extra > @@_isum) ? money(@@_isum) : money(@@__ensurance_extra);

    __ensurance_base  = @@_isum - @@__ensurance_extra;

  $MONEY(__isum_tax_base,__isum_tax_extra)
    __isum_tax_base  = round(@@__ensurance_base  * @@__tax_base  * 0.01, 2);
    __isum_tax_extra = round(@@__ensurance_extra * @@__tax_extra * 0.01, 2);

  return(@@__isum_tax_base + @@__isum_tax_extra);
#}



[]
