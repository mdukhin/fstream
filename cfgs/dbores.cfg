; новые объекты
;--------------------------------------------------
#opencfg <abbrs.cfg>
#opencfg <4glgpf.cfg>
#opencfg <ospcs.cfg>
#opencfg "errop4gl.cfg"
#opencfg "errfdr.cfg"
#opencfg "errdoc.cfg"
#opencfg "errkern1.cfg"
#opencfg "rights.cfg"
#opencfg "formmsg.cfg"
#opencfg "crbase.cfg"
#opencfg "uk_const.cfg"
#opencfg "uk_main.cfg"
#opencfg "uk_reports.cfg"

SECPATH=abbrs::;4glgpf::;ospcs::;crbase::;uk_const::;::;$CURCFG::;.

;==================================================
; стандартные ресурсы
;--------------------------------------------------
[]
char *read_access=any
char *zero_fields=-
long *debug=1
char scr_mode=view
;------------------------------------------
; разрешаем полный доступ и отменяем логирование
char DB_Kscoll.insert_access=any
char DB_Kscoll.update_access=any
char DB_Kscoll.delete_access=any
char DB_Kscoll.log_opns=!
;------------------------------------------
char DB_XForm.scr_mode=view
char DB_XForm.style=auto
char DB_XForm.stdmode=view

;==================================================
; окружение
;--------------------------------------------------
[StdEnv]
char subobj_names=\
#{
  CurrUser/Текущий пользователь;
  BranchSelect/@Не выбран текущий проект;
#}  
; действия при смене дня
char today_actions=
#ifdef SOMSERVER
char today_actions=\
#{
  _change_day_sect=StdCfg.GetSubconfig( "", "::change_day" );
  @_change_day_sect.VcolExecutePipe( "som_command", "<null>" );
#}
#endif
const char chgvar_actions=\
#{
  today:'${.:today_actions}';
; устанавливаем переменную @user_access при смене пользователя
  username:'
    _deflevs=ConfigGetString(":::DEFAULT_ACCOUNT_ACCESS_LEVEL");
    @@_deflevs=="" || @@_deflevs=="current" || long(@@_deflevs)<=0?
      StdEnv.GetVarLong("CurrUser.level","_deflev"):
      _deflev=long(@@_deflevs);
    StdEnv.SetVarLong( "user_access", @@_deflev )';
#}

[]

;--------------------------------------------------
; имя секции, с котоpой инициализиpуются данные
const char init_section=InitialEv
;==================================================
; текущий пользователь 
[CurrUser]
const char main_class=DB_Kstat
const char read_access=any
const char ks_table=users
const char ks_keys=c_user
const char ks_where=\
#{
  [shname]=@username and
  @today between [open_day] and [delete_day]
#}
char cursor_type=dynamic

;--------------------------------------------------
; все базовые пpава текущего пользователя (для проверки прав из
; DB_Env_impl::CheckBaseRight)
[CurrBaseRights]
const char main_class=DB_Kstat
const char read_access=any
const char ks_table=grouprights
const char ks_keys=c_base_right
const char ks_where=[c_group]=@CurrUser.c_group
char cursor_type=dynamic
;--------------------------------------------------
; все пpава на pабочие места для текущего пользователя (для проверки
; прав из DB_Env_impl::CheckPlaceRight)
[CurrOpRights]
const char main_class=DB_Kstat
const char read_access=any
const char ks_table=oprights_inc
const char ks_keys=c_op_right
const char ks_where=\
#{
  [c_base_right] in (select c_base_right from grouprights
    where c_group=@CurrUser.c_group)
#}

;==================================================
; предопределённые объекты
;--------------------------------------------------
; подобное описание позволяет использовать объект напрямую, например:
; StdCfg.GetSubconfig("","::")
[StdCfg]
const char main_class=DB_Stdcfg



;==================================================
; Календарь
;--------------------------------------------------
[Calendar]
const char main_class=DB_Kstat
const char read_access=any
const char insert_access=PLACE_NORIGHT
const char update_access=PLACE_NORIGHT 
const char delete_access=PLACE_NORIGHT
const char ks_table=calendar
const char ks_keys=cldyear,cldmonth
const char cursor_type=scroll

;> ------------------------------------------------
;> __pipe_pre_insert
;> ------------------------------------------------
const char pipe_pre_insert=\
#{
  call("$CURCFG::$CURSEC:_check_all_days_for_holiday", @@cldyear, @@cldmonth, @@clddays)
#}

;> ------------------------------------------------
;> __pipe_pre_update
;> ------------------------------------------------
const char pipe_pre_update=\
#{
  call("$CURCFG::$CURSEC:_check_all_days_for_holiday", @@cldyear, @@cldmonth, @@clddays)
#}

;> ------------------------------------------------
;> __check_all_days_for_holiday
;> ------------------------------------------------
const char _check_all_days_for_holiday_parms=_cldyear,_cldmonth,_clddays
const char _check_all_days_for_holiday=\
#{
  $LONG(_op_day)
  $CHAR(_day)
  CURSOR
    select op_day, substr("@_clddays", day(op_day), 1) into ?_op_day, ?_day
    from opdays
    where
      year(op_day)  = @_cldyear and
      month(op_day) = @_cldmonth
    : call("$CURCFG::$CURSEC:_check_one_day_for_holiday", @@_op_day, @@_day);
#}

;> ------------------------------------------------
;> __check_day_for_holiday
;> ------------------------------------------------
const char _check_one_day_for_holiday_parms=_op_day,_day_letter
const char _check_one_day_for_holiday=\
#{
  (@@_day_letter == "h")
      ? RaiseError(-1, "Операционный день [" + rfmtdate(@@_op_day, "dd.mm.yyyy") + "] не может быть выходным!", "")
      : 0;
#}



;==================================================
; Операционные дни
;--------------------------------------------------
[OpDays]
const char main_class=DB_Kstat
const char read_access=any
const char ks_table=opdays
char ks_keys=op_day
char ks_order=op_day
char cursor_type=scroll

[OpDays_Open]
const char main_class=DB_Kscurs
const char parent_kstat=OpDays
const char ks_where=[state]=$DAY_STATE_OPEN
const char cursor_type=scroll


;==================================================
; шаблоны
;--------------------------------------------------
template [AccntTpl]
const char main_class=DB_Kstat
const char read_access=any
const char insert_access=PLACE_ACCNT
const char update_access=PLACE_ACCNT
const char delete_access=PLACE_ACCNT
char cursor_type=scroll
;--------------------------------------------------
template [AccntSetTpl]
const char main_class=DB_Kstat
const char read_access=any
const char insert_access=PLACE_ACCNT
const char update_access=DISABLE
const char delete_access=PLACE_ACCNT
char cursor_type=scroll
;--------------------------------------------------
template [EditorTpl]
const char main_class=DB_Form
char parent_kstat=
char title=
char scr_name=
char filter_screen=
char scr_mode=
char edt_modes=siud!P
char spc_list=
char add_acts=\
#{
  *(add,dispatch,"Вставка#P-"): LFENTER
  { pipe=
      vldopn{opn=std};
      doopn{opn=insert};
      setmode{mode=edit};
      doopn{opn=read};
      enter_line
  };
#}

;==================================================
; валюты
;--------------------------------------------------
[CurrInfo]
const char main_class=DB_Kstat
const char read_access=any
; пользователи могут только менять
const char insert_access=PLACE_NORIGHT
const char update_access=PLACE_CURRINFO 
const char delete_access=PLACE_NORIGHT
const char ks_table=curr_info
; c_curr - currency code
; name   - currency name
; abbr   - currency abbreviation
; curr_okw - код валюты по ОКВ
; curr1  - name of roubles
; curr2  - name of cents
const char serial=c_curr
const char ks_keys=c_curr
char ks_order=c_curr
char cursor_type=scroll
; для проверки дубликатов
char refs_x1=Dup($CURCFG::$CURSEC):abbr;
;--------------------------------------------------
; для точного поиска
char synonyms=abbr_lu==abbr;
char filter_fields=abbr_lu:(%?%=abbr);
;--------------------------------------------------
; validate
char pipe_insert_vld=\
#{
; канонический вид
  abbr=strupr( strcompact( @@abbr, 0 ));
  name=strcompact( @@name, 3 );
  curr_okw=strcompact( @@curr_okw, 0 );
; проверяем указание кода
  @@abbr==""?
    RaiseError( ${errfdr:::ERR_CurrAbbrEmpty} ): 0;
; проверяем дубликат кода
  @@Dup.c_curr==0? 0:
  @@Dup.c_curr==@@c_curr? 0:
    RaiseError( ${errfdr:::ERR_CurrExist}, @@Dup.name, @@abbr );
; проверяем указание наименования
  @@name==""?
    RaiseError( ${errfdr:::ERR_CurrNameEmpty} ): 0;
; проверяем указание кода по ОКВ
  @@curr_okw==""?
    RaiseError( ${errfdr:::ERR_CurrOkwEmpty} ): 0;
#}
char pipe_update_vld=try("$CURCFG::$CURSEC:pipe_insert_vld", "" );
;--------------------------------------------------
; приводим в канонический вид
char pipe_pre_insert=\
#{
  IO.abbr=strupr( strcompact( @@abbr, 0 ));
  IO.name=strcompact( @@name, 3 );
  IO.curr_okw=strcompact( @@curr_okw, 0 );
#}
char pipe_pre_update=call("$CURCFG::$CURSEC:pipe_pre_insert");
;--------------------------------------------------
[Curr]
const char main_class=DB_Kscurs
const char parent_kstat=CurrInfo
char ks_where=[c_curr]!=$CURR_REVAL
;--------------------------------------------------
[CurrNR] Curr
char ks_where=[c_curr] not in($CURR_ROUBLE,$CURR_REVAL)
;--------------------------------------------------
; редактирование
[CurrInfoEdit] default: EditorTpl
const char parent_kstat=$CURCFG::CurrInfo
char title=Валюты
char scr_name=fdr_currinfo_frm
char filter_screen=fdr_currinfo_slct
char scr_mode=select
; проверка обязательности ввода select-полей
char abbr_exit=\
#{
  getvars{vars='abbr'};
  switch{var=abbr,empty=
    error{code=${errfdr:::ERR_CurrAbbrEmpty}}};
#}

;==================================================
; план счетов
;--------------------------------------------------
template [NplAccntTpl]
const char main_class=DB_Kstat
const char read_access=any
const char insert_access=PLACE_NPLAN
const char update_access=PLACE_NPLAN
const char delete_access=PLACE_NPLAN
char cursor_type=dynamic
;--------------------------------------------------
; счета 1го порядка
[NPl_accnt1] default: NplAccntTpl
const char ks_table=npl_accnt1
; c_naccnt_1 - ключ
; naccnt_1   - номер счёта 1го порядка
; name       - наименование
; open_day
; delete_day - история
const char serial=c_naccnt_1
const char ks_keys=c_naccnt_1
const char ks_where=@today between [open_day] and [delete_day]
char ks_order=naccnt_1
; для просмотра в форме
char references=NPL($CURCFG::NPl_accnt2):c_naccnt_1;
char slave_refs=\
#{
; только для удаления
;;Pl1Groups(accgrps::Pl1Groups):naccnt_1(num);
;;FALinesPl1(finan::FALinesPl1):naccnt_1(accnt1);
#}
char rfc_modifiers=\
#{
;;Pl1Groups:iu;
;;FALinesPl1:iu;
#}
; для проверки дубликатов
char refs_x1=Dup($CURCFG::$CURSEC):naccnt_1;
;--------------------------------------------------
; validate
char pipe_insert_vld=\
#{
; проверяем указание номера счета
  @@naccnt_1==0?
    RaiseError( ${errfdr:::ERR_NPlaccNAccntEmpty} ): 0;
; проверяем дубликат номера
  @@Dup.name==""? 0:
    RaiseError( ${errfdr:::ERR_NPlaccExist}, @@Dup.name, @@naccnt_1 );
; канонический вид
  name=strcompact( @@name, 3 );
; проверяем указание наименования
  @@name==""?
    RaiseError( ${errfdr:::ERR_NPlaccNameEmpty} ): 0;
#}
char pipe_update_vld=\
#{
; запрещаем менять номер счета
  ( @@naccnt_1!=@@STORE.naccnt_1? 0:
      1 )? 0:
    RaiseError( ${errfdr:::ERR_NPlacc1IllegalChange} );
; канонический вид
  name=strcompact( @@name, 3 );
; проверяем указание наименования
  @@name==""?
    RaiseError( ${errfdr:::ERR_NPlaccNameEmpty} ): 0;
#}
char pipe_delete_vld=\
#{
; проверяем использование в счетах 2го порядка
  call("$CURCFG::cmds:nplacc1_cnu_naccnt");
#}
;--------------------------------------------------
[cmds]
; проверить использование в счетах 2го порядка
char nplacc1_cnu_naccnt=\
#{
  $LONG(ekey)
  SQL select min(naccnt) into ?ekey
      from npl_accnt2
      where c_naccnt_1=?c_naccnt_1;
  isnull(@@ekey)?
    return(0): 0;
  RaiseError( ${errfdr:::ERR_NPlacc1UsedNAccnt}, @@ekey );
#}
;--------------------------------------------------
; редактирование
[NPlAccnt1Edit] default: EditorTpl
const char parent_kstat=$CURCFG::NPl_accnt1
char title=План балансовых счетов 1го порядка
char scr_name=fdr_npl_accnt1_frm
char filter_screen=npl_accnt1_tbl
char scr_mode=select
char forms_aux=\
#{
  NPL:$CURCFG::NPlAccnt2TableView_aux;
;;Pl1Groups:accgrps::AccGroupTableView_aux;
;;FALinesPl1:finan::FALineTableView_aux;
#}
; проверка обязательности ввода select-полей
char naccnt_1_exit=\
#{
  getvars{vars='naccnt_1'};
  switch{var=naccnt_1,empty=
    error{code=${errfdr:::ERR_NPlaccNAccntEmpty}}};
#}

;> ============================================================================
;> Naccnts2
;> ============================================================================
[NPlAccnt2TableView_aux]
const char main_class=DB_XForm
char title=Балансовые счета
char scr_name=fdr_npl_accnt2_slct
char filter_screen=${.:scr_name}
char stdmode=view
char filter_mode=view
char edt_modes=s!p!P
char flt_modes=${.:edt_modes}


[NPl_accnt2_used_only]
const char main_class=DB_Kscurs
const char parent_kstat=NPl_accnt2
const char ks_where=exists (select * from accnts_def a where a.c_naccnt = [c_naccnt] and @BranchSelect.c_branch in ($BRANCH_CONS, a.c_branch))

;==================================================
; балансовые счета
[NPl_accnt2] default: NplAccntTpl
const char ks_table=npl_accnt2
; c_naccnt   - ключ счета 2го порядка
; c_naccnt_1 - ключ счета 1го порядка
; naccnt_1   - счет 1го порядка
; naccnt     - номер счета 2го порядка
; name       - наименование
; type       - актив/пассив
; open_day
; delete_day - история
const char serial=c_naccnt
const char ks_keys=c_naccnt
const char ks_where=@today between [open_day] and [delete_day]
char ks_order=naccnt
char ks_defaults=

char foreigns=\
#{";"
  NPL1($CURCFG::NPl_accnt1):c_naccnt_1
#}

char lookups=\
#{";"
  TypeAP($CURCFG::AbbrsAccntAP):type
#}

char slave_refs=\
#{";"
  NAccntAcckind($CURCFG::NAccntAcckind):c_naccnt
; только для удаления
;;GPL2(accgrps::Pl2Groups):naccnt(num)
;;FALPL2(finan::FALinesPl2):naccnt(accnt2)
#}

char rfc_modifiers=\
#{";"
  NAccntAcckind:u
;;GPL2:iu
;;FALPL2:iu
#}

; для проверки дубликатов
char refs_x1=Dup($CURCFG::$CURSEC):naccnt;

;--------------------------------------------------
; для точного поиска
char synonyms=\
#{";"
  _name[240]=![naccnt] [name]
  naccnt_lu==naccnt
#}

char filter_fields=naccnt_lu:(%?%=naccnt);

const char spc_codes=\
#{
  $spc_get_tunning_info (<@get_tunning_info (c_naccnt,acckind=NAccntAcckind.0.acckind)>):#Pget_tunning_info_parms;
#}

;> ------------------------------------------------
;> __get_tunning_info
;    получение аттрибутов объекта и сохранение их во внешней коллекции
;    для использования в Delphi
;> ------------------------------------------------
const char get_tunning_info_parms=\
#{";"
  ext_coll_name:Имя внешней коллекции#Tstring_t
#}

const char get_tunning_info=\
#{
  @ext_coll_name.RenewVarsFromColl(CURRENT.get_name());
#}


;--------------------------------------------------
; validate
char pipe_insert_vld=\
#{
; проверяем указание номера счета
  @@naccnt==0?
    RaiseError( ${errfdr:::ERR_NPlaccNAccntEmpty} ): 0;
; проверяем дубликат номера
  @@Dup.name==""? 0:
    RaiseError( ${errfdr:::ERR_NPlaccExist}, @@Dup.name, @@naccnt );
; канонический вид
  name=strcompact( @@name, 3 );
; проверяем указание наименования
  @@name==""?
    RaiseError( ${errfdr:::ERR_NPlaccNameEmpty} ): 0;
#}
char pipe_update_vld=\
#{
; запрещаем менять номер счета и тип А/П
  ( @@naccnt!=@@STORE.naccnt? 0:
    @@naccnt_1!=@@STORE.naccnt_1? 0:
    @@type!=@@STORE.type? 0:
      1 )? 0:
    RaiseError( ${errfdr:::ERR_NPlaccIllegalChange} );
; канонический вид
  name=strcompact( @@name, 3 );
; проверяем указание наименования
  @@name==""?
    RaiseError( ${errfdr:::ERR_NPlaccNameEmpty} ): 0;
#}
char pipe_delete_vld=\
#{
; проверяем использование в счетах
  call("$CURCFG::cmds:nplacc_cnu_accnt");
#}
;--------------------------------------------------
; приводим в канонический вид
char pipe_pre_insert=IO.name=strcompact( @@name, 3 );
char pipe_pre_update=IO.name=strcompact( @@name, 3 );
;--------------------------------------------------
[cmds]
; проверить использование балансового счёта в счетах
char nplacc_cnu_accnt=\
#{
  $LONG(ekey)
  SQL select min(c_accnt)
      into ?ekey
      from accnts_def
      where c_naccnt=?c_naccnt;
  isnull(@@ekey)?
    return(0): 0;
; получаем дату открытия
  $DATE(eday1)
  SQL select open_day
      into ?eday1
      from accnts_def
      where c_accnt=?ekey;
  RaiseError( ${errfdr:::ERR_NPlaccUsedByAccnt},
    @@eday1, call("4glgpf::KeyDesc:Accnt") );
#}
;--------------------------------------------------
; редактирование
[NPlAccnt2Edit] default: EditorTpl
const char parent_kstat=$CURCFG::NPl_accnt2
char title=План балансовых счетов 2го порядка
char scr_name=fdr_npl_accnt2_frm
char filter_screen=fdr_npl_accnt2_slct
char scr_mode=select
char forms_aux=\
#{
  NAccntAcckind:$CURCFG::NAccntAcckind_aux;
#}
; проверка обязательности ввода select-полей
char naccnt_exit=\
#{
  getvars{vars='naccnt'};
  switch{var=naccnt,empty=
    error{code=${errfdr:::ERR_NPlaccNAccntEmpty}}};
#}

;==================================================
; виды счетов
;--------------------------------------------------
[]
; предопределённые виды (определяются при загрузке)
long ACCKIND_REVAL=1
long ACCKIND_CONVERSION=2
long ACCKIND_PROFEXP=3
long ACCKIND_NORMAL=4
long ACCKIND_STOCK=101
;--------------------------------------------------
template [AcckindTpl]
const char main_class=DB_Kstat
const char read_access=any
const char insert_access=PLACE_NORIGHT
const char update_access=PLACE_NORIGHT
const char delete_access=PLACE_NORIGHT
char cursor_type=dynamic
;--------------------------------------------------
[Acckind] default: AcckindTpl
const char ks_table=acckinds
; acckind   - вид счета
; abbr      - код вида
; name      - наименование вида
; rate_kind - тип переоценки валюты
const char ks_keys=acckind
const char serial=acckind
char ks_order=abbr
char ks_defaults=\
#{
  client:$ACCKIND_CLIENT_NO;
  contract_type:0;
  open_state:$ACCNT_STATE_OPEN;
  ext_name:$ACCKIND_EXT_NAME_ACCNT;
#}
char lookups=RateKind($CURCFG::AbbrsRateKind):rate_kind(type);
char slave_refs=\
#{
; только для удаления
  NAccntAcckind($CURCFG::NAccntAcckind):acckind;
#}
char rfc_modifiers=\
#{
  NAccntAcckind:iu;
#}
; для проверки дубликатов
char refs_x1=Dup($CURCFG::$CURSEC):abbr;
;--------------------------------------------------
; для точного поиска
char synonyms=${.:synonyms}abbr_lu==abbr;
char filter_fields=${.:filter_fields}abbr_lu:(%?%=abbr);
;--------------------------------------------------
; validate
char pipe_insert_vld=\
#{
; канонический вид
  abbr=strcompact( @@abbr, 0 );
  name=strcompact( @@name, 3 );
; проверяем указание кода
  @@abbr==""?
    RaiseError( ${errfdr:::ERR_AcckindAbbrEmpty} ): 0;
; проверяем дубликат кода
  @@Dup.acckind==0? 0:
  @@Dup.acckind==@@acckind? 0:
    RaiseError( ${errfdr:::ERR_AcckindExist}, @@Dup.name, @@abbr );
; проверяем указание наименования
  @@name==""?
    RaiseError( ${errfdr:::ERR_AcckindNameEmpty} ): 0;
#}
char pipe_update_vld=try("$CURCFG::$CURSEC:pipe_insert_vld", "" );
char pipe_delete_vld=\
#{
; проверяем предопределённые виды
  local("varname"); varname=
    @@acckind==$ACCKIND_REVAL? "ACCKIND_REVAL":
    @@acckind==$ACCKIND_CONVERSION? "ACCKIND_CONVERSION":
    @@acckind==$ACCKIND_PROFEXP? "ACCKIND_PROFEXP":
    @@acckind==$ACCKIND_NORMAL? "ACCKIND_NORMAL":
      "";
  @@varname==""? 0:
    RaiseError( ${errfdr:::ERR_AcckindReserved}, @@varname );
; проверяем использование в счетах
  call("$CURCFG::cmds:acckind_cnu_accnt");
#}
;--------------------------------------------------
; приводим в канонический вид
char pipe_pre_insert=\
#{
  IO.abbr=strcompact( @@abbr, 0 );
  IO.name=strcompact( @@name, 3 );
#}
char pipe_pre_update=try("$CURCFG::$CURSEC:pipe_pre_insert", "" );
;--------------------------------------------------
[NAccntAcckind] default: AcckindTpl
const char ks_table=naccnt_acckind
const char ks_keys=c_naccnt,acckind
char ks_order=naccnt,acckind
char lookups=\
#{";"
  NPL($CURCFG::NPl_accnt2):c_naccnt
  Acckind($CURCFG::Acckind):acckind
#}
;--------------------------------------------------
[cmds]
; проверить использование вида счёта в счетах
char acckind_cnu_accnt=\
#{
  $LONG(ekey)
  SQL select min(c_accnt)
      into ?ekey
      from accnts_def
      where acckind=?acckind;
  isnull(@@ekey)?
    return(0): 0;
; получаем дату открытия
  $DATE(eday1)
  SQL select open_day
      into ?eday1
      from accnts_def
      where c_accnt=?ekey;
  RaiseError( ${errfdr:::ERR_AcckindUsedByAccnt},
    @@eday1, call("4glgpf::KeyDesc:Accnt") );
#}
;--------------------------------------------------
; редактирование
[AcckindEdit] default: EditorTpl
const char parent_kstat=$CURCFG::Acckind
char title=Виды счетов
char scr_name=fdr_acckind_frm
char filter_screen=abbr_name40_slct
char scr_mode=select
; проверка обязательности ввода select-полей
char abbr_exit=\
#{
  getvars{vars='abbr'};
  switch{var=abbr,empty=
    error{code=${errfdr:::ERR_AcckindAbbrEmpty}}};
#}
;--------------------------------------------------
; редактирование допустимых видов счетов
[NAccntAcckind_aux]
const char main_class=DB_XForm
char title=Допустимые виды счетов
char scr_name=fdr_acckind_name_slct
char filter_screen=${.:scr_name}
char stdmode=edit
char filter_mode=tselect
char edt_modes=sid!p!P
char flt_modes=s
long empty->add=1

;> ============================================================================
;> NSYMBOLS
;    символы доходов/расходов
;> ============================================================================
[Nsymbols1] default: AccntTpl
const char ks_table=nsymbols_f20
const char ks_keys=nsymbf2_0
char ks_order=nsymbf2_0
char foreigns=TypeAP($CURCFG::AbbrsAccntAP):type;
char references=NS3($CURCFG::Nsymbols3):nsymbf2_0;
; проверяем использование
char pipe_delete_vld=\
#{
  $LONG(ekey)
  SQL select min(nsymbf2_1) into ?ekey
      from nsymbols_f21
      where nsymbf2_0=?nsymbf2_0;
  isnull(@@ekey)? 0:
    RaiseError( ${errop4gl:::ERR_Nsymbf20_Used}, @@ekey );
#}
;--------------------------------------------------
[Nsymbols3] default: AccntTpl
const char ks_table=nsymbols_f21
const char ks_keys=nsymbf2_1
char ks_order=nsymbf2_1
char foreigns=\
#{";"
  NS1($CURCFG::Nsymbols1):nsymbf2_0
#}
char references=NS5($CURCFG::Nsymbols5):nsymbf2_1;
; проверяем использование
char pipe_delete_vld=\
#{
  $LONG(ekey)
  SQL select min(nsymbf2) into ?ekey
      from nsymbols_f2
      where nsymbf2_1=?nsymbf2_1;
  isnull(@@ekey)? 0:
    RaiseError( ${errop4gl:::ERR_Nsymbf21_Used}, @@ekey );
#}
;--------------------------------------------------
[Nsymbols5] default: AccntTpl
const char ks_table=nsymbols_f2
const char ks_keys=nsymbf2
char ks_order=nsymbf2
char foreigns=NS3($CURCFG::Nsymbols3):nsymbf2_1;
; проверяем использование
char pipe_delete_vld=\
#{
  $LONG(ekey)
  SQL select min(c_accnt) into ?ekey
      from accnts_def
      where nsymbf2=?nsymbf2;
  isnull(@@ekey)? 0:
    RaiseError( ${errop4gl:::ERR_Nsymbf2_Used},
      call("4glgpf::KeyDesc:Accnt" );
#}
;--------------------------------------------------
; редактирование
template [NsymbolsEditTpl]
const char main_class=DB_Form
char scr_mode=edit
char edt_modes=suid
const long empty->add=1
;--------------------------------------------------
[Nsymbols1Edit] default: NsymbolsEditTpl
char parent_kstat=$CURCFG::Nsymbols1
char title=Разделы символов доходов/расходов
char scr_name=nsymbols1_tbl
;--------------------------------------------------
[Nsymbols3Edit] default: NsymbolsEditTpl
char parent_kstat=$CURCFG::Nsymbols3
char title=Группы символов доходов/расходов
char scr_name=nsymbols3_tbl
;--------------------------------------------------
[Nsymbols5Edit] default: NsymbolsEditTpl
char parent_kstat=$CURCFG::Nsymbols5
char title=Символы доходов/расходов
char scr_name=nsymbols5_frm
char filter_screen=fdr_nsymbols_slct

;> ============================================================================
;> NSYMBOLS2
;    новые символы доходов/расходов (нормализованные)
;> ============================================================================
[cmds]

;> ----------------------------------------------------------------------------
;> __calc_nsymbf2_pattern
;> ----------------------------------------------------------------------------
const char _calc_nsymbf2_pattern_parms=_nsymbf2,_min,_max,_shname,_s1,_s2,_s3
const char _calc_nsymbf2_pattern=\
#{
  (@@_nsymbf2 > @@_max) || (@@_nsymbf2 < @@_min) ? RaiseError(-1, "Номер " + @@_shname + " должен быть в диапазоне " + string(@@_min) + "-" + string(@@_max) + " !!!", "") : 0;
  IO.pattern = @@_s1 + @@_s2 + @@_s3 + "xx";
#}

;> ----------------------------------------------------------------------------
;> __check_nsymbf2_for_delete
;> ----------------------------------------------------------------------------
const char _check_nsymbf2_for_delete_parms=_child_tbl,_child_nsymbf2,_child_key,_c_key_value
const char _check_nsymbf2_for_delete=\
#{
  $LONG(ekey)
  SQL
    select min(@{_child_nsymbf2}) into ?ekey
    from @{_child_tbl}
    where @{_child_key} = @_c_key_value;


  isnull(@@ekey)
    ? 0
    : RaiseError( ${errop4gl:::ERR_Nsymbf20_Used}, @@ekey );
#}

;> ----------------------------------------------------------------------------
;> __check_nsymbf2_for_update
;> ----------------------------------------------------------------------------
const char _check_nsymbf2_for_update_parms=_child_tbl,_child_nsymbf2,_child_key,_c_key_value
const char _check_nsymbf2_for_update=\
#{
  $LONG(ekey)
  SQL
    select min(@{_child_nsymbf2}) into ?ekey
    from @{_child_tbl}
    where @{_child_key} = @_c_key_value;


  isnull(@@ekey)
    ? 0
    : RaiseError(-1, "Нельзя изменить номер, т.к. уже существуют зависимые подструктуры доходов/расходов", "");
#}


[Nsymbols2_f1_used_only]
const char main_class=DB_Kscurs
const char parent_kstat=Nsymbols2_f1
const char ks_where=exists (select * from nsymbols2_f5 where c_nsymbf2_f1 = [c_nsymbf2_f1])

[Nsymbols2_f1] default: AccntTpl
const char ks_table=nsymbols2_f1
const char ks_keys=c_nsymbf2_f1
const char serial=c_nsymbf2_f1
char ks_order=pattern

const char synonyms=\
#{";"
  _name=![nsymbf2_f1]. [name]
#}

char foreigns=\
#{";"
  TypeAP($CURCFG::AbbrsNsymbf2AP):type
#}

char references=\
#{";"
  NS2_f2($CURCFG::Nsymbols2_f2):c_nsymbf2_f1
  NS2_f3($CURCFG::Nsymbols2_f3):c_nsymbf2_f1
  NS2_f5($CURCFG::Nsymbols2_f5):c_nsymbf2_f1
#}

; проверяем использование
char pipe_delete_vld=\
#{
  call("$CURCFG::cmds:_check_nsymbf2_for_delete", "nsymbols2_f2", "nsymbf2_f2", "c_nsymbf2_f1", @@c_nsymbf2_f1);
#}

const char pipe_pre_insert=\
#{
  call("$CURCFG::cmds:_calc_nsymbf2_pattern", @@nsymbf2_f1, 1, 9, "статьи", string(@@nsymbf2_f1), "x", "x");
#}

const char pipe_pre_update=\
#{
  call("$CURCFG::cmds:_calc_nsymbf2_pattern", @@nsymbf2_f1, 1, 9, "статьи", string(@@nsymbf2_f1), "x", "x");
  HEAP.nsymbf2_f1 = @@STORE.nsymbf2_f1;
#}

const char pipe_post_update=\
#{
  (@@HEAP.nsymbf2_f1 == @@nsymbf2_f1)
      ? return(0)
      : 0;
  call("$CURCFG::cmds:_check_nsymbf2_for_update", "nsymbols2_f2", "nsymbf2_f2", "c_nsymbf2_f1", @@c_nsymbf2_f1);
#}


; -----------------------------------------------------------------------------
[Nsymbols2_f2_used_only]
const char main_class=DB_Kscurs
const char parent_kstat=Nsymbols2_f2
const char ks_where=exists (select * from nsymbols2_f5 where c_nsymbf2_f2 = [c_nsymbf2_f2])

[Nsymbols2_f2] default: AccntTpl
const char ks_table=nsymbols2_f2
const char ks_keys=c_nsymbf2_f2
const char serial=c_nsymbf2_f2
char ks_order=pattern

const char synonyms=\
#{";"
  _name=![nsymbf2_f2]. [name]
#}

char foreigns=\
#{";"
  NS2_f1($CURCFG::Nsymbols2_f1):c_nsymbf2_f1
#}

char references=\
#{";"
  NS2_f3($CURCFG::Nsymbols2_f3):c_nsymbf2_f2
  NS2_f5($CURCFG::Nsymbols2_f5):c_nsymbf2_f2
#}

; проверяем использование
char pipe_delete_vld=\
#{
  call("$CURCFG::cmds:_check_nsymbf2_for_delete", "nsymbols2_f3", "nsymbf2_f3", "c_nsymbf2_f2", @@c_nsymbf2_f2);
#}

const char pipe_pre_insert=\
#{
  call("$CURCFG::cmds:_calc_nsymbf2_pattern", @@nsymbf2_f2, 1, 9, "раздела", string(@@NS2_f1.nsymbf2_f1), string(@@nsymbf2_f2), "x");
#}

const char pipe_pre_update=\
#{
  call("$CURCFG::cmds:_calc_nsymbf2_pattern", @@nsymbf2_f2, 1, 9, "раздела", string(@@NS2_f1.nsymbf2_f1), string(@@nsymbf2_f2), "x");
  HEAP.nsymbf2_f2 = @@STORE.nsymbf2_f2;
#}

const char pipe_post_update=\
#{
  (@@HEAP.nsymbf2_f2 == @@nsymbf2_f2)
      ? return(0)
      : 0;
  call("$CURCFG::cmds:_check_nsymbf2_for_update", "nsymbols2_f3", "nsymbf2_f3", "c_nsymbf2_f2", @@c_nsymbf2_f2);
#}



; -----------------------------------------------------------------------------
[Nsymbols2_f3_used_only]
const char main_class=DB_Kscurs
const char parent_kstat=Nsymbols2_f3
const char ks_where=exists (select * from nsymbols2_f5 where c_nsymbf2_f3 = [c_nsymbf2_f3])

[Nsymbols2_f3] default: AccntTpl
const char ks_table=nsymbols2_f3
const char ks_keys=c_nsymbf2_f3
const char serial=c_nsymbf2_f3
char ks_order=pattern

const char synonyms=\
#{";"
  _name=![nsymbf2_f3]. [name]
#}

char foreigns=\
#{";"
  NS2_f1($CURCFG::Nsymbols2_f1):c_nsymbf2_f1
  NS2_f2($CURCFG::Nsymbols2_f2):c_nsymbf2_f2
  NAccnt($CURCFG::NPl_accnt2):c_naccnt
#}

char references=\
#{";"
  NS2_f5($CURCFG::Nsymbols2_f5):c_nsymbf2_f3
#}

; проверяем использование
char pipe_delete_vld=\
#{
  call("$CURCFG::cmds:_check_nsymbf2_for_delete", "nsymbols2_f5", "nsymbf2_f5", "c_nsymbf2_f3", @@c_nsymbf2_f3);
#}

const char pipe_pre_insert=\
#{
  call("$CURCFG::cmds:_calc_nsymbf2_pattern", @@nsymbf2_f3, 1, 9, "подраздела", string(@@NS2_f1.nsymbf2_f1), string(@@NS2_f2.nsymbf2_f2), string(@@nsymbf2_f3));
#}

const char pipe_pre_update=\
#{
  call("$CURCFG::cmds:_calc_nsymbf2_pattern", @@nsymbf2_f3, 1, 9, "подраздела", string(@@NS2_f1.nsymbf2_f1), string(@@NS2_f2.nsymbf2_f2), string(@@nsymbf2_f3));
  HEAP.nsymbf2_f3 = @@STORE.nsymbf2_f3;
#}

const char pipe_post_update=\
#{
  (@@HEAP.nsymbf2_f3 == @@nsymbf2_f3)
      ? return(0)
      : 0;
  call("$CURCFG::cmds:_check_nsymbf2_for_update", "nsymbols2_f5", "nsymbf2_f5", "c_nsymbf2_f3", @@c_nsymbf2_f3);
#}

[Nsymbols2_f5_used_only]
const char main_class=DB_Kscurs
const char parent_kstat=Nsymbols2_f5
const char ks_where=exists (select * from accnts_def a where a.c_nsymbf2_f5 = [c_nsymbf2_f5] and @BranchSelect.c_branch in ($BRANCH_CONS, a.c_branch))


[Nsymbols2_f5] default: AccntTpl
const char ks_table=nsymbols2_f5
const char ks_keys=c_nsymbf2_f5
const char serial=c_nsymbf2_f5
char ks_order=nsymbf2_out

char foreigns=\
#{";"
  NS2_f1($CURCFG::Nsymbols2_f1):c_nsymbf2_f1
  NS2_f2($CURCFG::Nsymbols2_f2):c_nsymbf2_f2
  NS2_f3($CURCFG::Nsymbols2_f3):c_nsymbf2_f3
#}

const char synonyms=\
#{";"
  _name[255]=![nsymbf2_out]. [name]
  _full_name[1000]=![_name] [NS2_f1.name] [NS2_f2.name] [NS2_f3.name]
#}

const char pipe_pre_insert=\
#{
  (@@nsymbf2_f5 > 99) || (@@nsymbf2_f5 < 1) ? RaiseError(-1, "Номер символа должен быть в диапазоне 1-99 !!!", "") : 0;

  $LONG(_f1,_f2,_f3)
    _f1 = @@NS2_f1.nsymbf2_f1 * 10000;
    _f2 = @@NS2_f2.nsymbf2_f2 *  1000;
    _f3 = @@NS2_f3.nsymbf2_f3 *   100;
  IO.nsymbf2_out = @@_f1 + @@_f2 + @@_f3 + @@nsymbf2_f5;
#}

;> ============================================================================
;> KINDS
;  места хранения
;> ============================================================================

[Nukinds] default: AccntTpl
const char ks_table=accukinds
const char ks_keys=ukind
char ks_where=[type]=$ACCNT_UKIND_NUKIND
char ks_defaults=type:$ACCNT_UKIND_NUKIND;
char ks_order=ukind
char filter_fields=name:(%dukind)|(name);
char synonyms=nukind<=>ukind;
; проверяем использование
char pipe_delete_vld=\
#{
  $LONG(ekey)
  SQL select min(c_accnt) into ?ekey
      from accnts_def
      where nukind=?nukind;
  isnull(@@ekey)? 0:
    RaiseError( ${errfdr:::ERR_Nukind_Used},
      call("4glgpf::KeyDesc:Accnt" );
#}
;--------------------------------------------------
; редактирование
[NukindsEdit]
const char main_class=DB_Form
char title=Места хранения
char parent_kstat=$CURCFG::Nukinds
char scr_name=fdr_nukinds_tbl
char filter_screen=fdr_nukinds_tbl
char scr_mode=edit
char edt_modes=suid
const long empty->add=1

;> ============================================================================
;> BRANCHES
;  проекты/подпроекты (филиалы)
;> ============================================================================
[Branch] default: AccntTpl
const char ks_table=branches
; c_branch - код филиала
; shname   - название
; ndep     - номер подпроекта в маске счета
; type     - тип: проект/подпроект
; open_day - история
; delete_day
const char ks_keys=c_branch
const char serial=c_branch
char ks_order=ndep
const char history=open:open_day/delete_day
char query_defaults=open_day:@today;delete_day:$DayMax;
char ks_defaults=\
#{
  ndep:0;
  cons_delay:0;
#}
; подпроекты
char slave_refs=BCD($CURCFG::BranchConsDep):c_branch(c_cons);
; проекты, в который входит подпроект
char references=Projects($CURCFG::BranchConsDep):c_branch;
char fmt_desc=Проект [shname]
;--------------------------------------------------
char synonyms=shname_lu==shname;
char filter_fields=\
#{
; для поиска по коду проекта
  shname:(%dndep)|(shname);
; для точного поиска
  shname_lu:(%?%=shname);
#}
;--------------------------------------------------
; specials
const char spc_codes=\
#{
  $spcRollbackDelete: PLACE_ACCNT;
  $spcRollbackInsert: PLACE_ACCNT;
  $spc_get_tunning_info (<@get_tunning_info (shname)>):#Pget_tunning_info_parms;
#}

;> ------------------------------------------------
;> __get_tunning_info
;    получение аттрибутов объекта и сохранение их во внешней коллекции
;    для использования в Delphi
;> ------------------------------------------------
const char get_tunning_info_parms=\
#{";"
  ext_coll_name:Имя внешней коллекции#Tstring_t
#}

const char get_tunning_info=\
#{
  @ext_coll_name.RenewVarsFromColl(CURRENT.get_name());
#}


;--------------------------------------------------
; validate
char kernel_history=\
#{
; проверяем указание и дубликат наименования
  New           : VldNew(rb_flag=0);
  RollbackDelete: VldNew(rb_flag=1);
; проверяем новые атрибуты, запрет изменения
  Change        : VldChg(rb_flag=0);
; проверяем использование филиала
  Delete        : VldDel(rb_flag=0);
  RollbackNew   : VldDel(rb_flag=1);
#}
char VldNew_parms=rb_flag
char VldNew=\
#{
  local("day1,day2");
  day1=@@rb_flag? @@STORE.delete_day+1: @@open_day;
  day2=@@delete_day;
; проверяем наименование
  call("$CURCFG::cmds:branch_cdu_shname");
; проверяем номер филиала
  call("$CURCFG::cmds:branch_cdu_ndep");
#}
char VldChg_parms=rb_flag
char VldChg=\
#{
  local("day1,day2");
  day1=@@rb_flag? @@STORE.delete_day+1: @@open_day;
  day2=@@delete_day;
; проверяем наименование
  call("$CURCFG::cmds:branch_cdu_shname");
; запрещаем менять номер филиала
  ( @@ndep!=@@STORE.ndep? 0:
      1 )? 0:
    RaiseError( ${errfdr:::ERR_ProjectIllegalChange} );
#}
char VldDel=\
#{
; проверяем зарезервированные проекты (имеют название "Общий")
  @@c_branch==$BRANCH_OUR ||
  @@c_branch==$BRANCH_CONS?
    RaiseError( ${errfdr:::ERR_ProjectReserved1},
      call("4glgpf::KeyDesc:Branch",@@c_branch) ):
    0;
; проверяем использование
  local("day1,day2");
  day1=@@rb_flag? @@STORE.open_day: @@delete_day+1;
  day2=@@STORE.delete_day;
  $LONG(ekey)
; проверяем использование подпроекта в счетах
  @@type==$BRANCH_TYPE_UNIBANK?
    call("$CURCFG::cmds:branch_sub_cnu_accnt" ):
    0;
; проверять использование проекта в счетах нет необходимости, т.к.
; удаление проекта приводит всего лишь к удалению привязки подпроектов к
; этому проекту, сами подпроекты, так же как и их счета, не
; затрагиваются.
; проверяем использование филиала как зависимого филиала
  call("$CURCFG::cmds:branch_cnu_cons" );
#}
;--------------------------------------------------
; приводим в канонический вид
char pipe_pre_insert=IO.shname=strcompact( @@shname, 3 );
char pipe_pre_update=IO.shname=strcompact( @@shname, 3 );
;--------------------------------------------------
[cmds]
; проверить указание наименования филиала и его дубликат в периоде
char branch_cdu_shname_parms=day1,day2
char branch_cdu_shname=\
#{
; канонический вид
  shname=strcompact( @@shname, 3 );
; проверяем указание наименования
  @@shname==""?
    RaiseError( ${errfdr:::ERR_ProjectShnameEmpty} ): 0;
; проверяем дубликат наименования с учетом типа
  $LONG(ekey)
  SQL select min(c_branch)
      into ?ekey
      from branches
      where shname=?shname and type=?type and
        delete_day>='@day1' and open_day<='@day2' and
        not(c_branch=?STORE.c_branch);
  isnull(@@ekey)?
    return(0): 0;
; получаем информацию о дубликате
  $DATE(eday1,eday2)
  SQL select open_day,delete_day
      into ?eday1,?eday2
      from branches
      where c_branch=?ekey;
  RaiseError( @@eday1>=@@day1 || @@eday2==$DayMax?
      ${errfdr:::ERR_ProjectShnameExist1}:
      ${errfdr:::ERR_ProjectShnameExist2},
    @@shname,
    @@eday1>=@@day1 || @@eday2==$DayMax? @@eday1: @@eday2 );
#}
;--------------------------------------------------
; проверить указание номера филиала и его дубликат в периоде
char branch_cdu_ndep_parms=day1,day2
char branch_cdu_ndep=\
#{
; проверяем указание номера филиала
  @@c_branch==$BRANCH_OUR? 0:
  @@c_branch==$BRANCH_CONS? 0:
  @@ndep==0?
    RaiseError( ${errfdr:::ERR_ProjectNdepEmpty} ):
  @@type==$BRANCH_TYPE_UNIBANK && !( @@ndep>=100 && @@ndep<=9999 )?
    RaiseError( ${errfdr:::ERR_ProjectSubIllegalNdep}, @@ndep ):
  @@type==$BRANCH_TYPE_CONS && !( @@ndep>=1 && @@ndep<=99 )?
    RaiseError( ${errfdr:::ERR_ProjectIllegalNdep}, @@ndep ):
    0;
; проверяем дубликат номера филиала
  local("ndep_where");
  ndep_where=@@ndep==0? "ndep=0 and type=?type": "ndep=?ndep";
  $LONG(ekey)
  SQL select min(c_branch)
      into ?ekey
      from branches
      where @ndep_where and
        delete_day>='@day1' and open_day<='@day2' and
        not(c_branch=?STORE.c_branch);
  isnull(@@ekey)?
    return(0): 0;
; получаем информацию о дубликате
  $DATE(eday1,eday2)
  SQL select open_day,delete_day
      into ?eday1,?eday2
      from branches
      where c_branch=?ekey;
  RaiseError( @@eday1>=@@day1 || @@eday2==$DayMax?
      ${errfdr:::ERR_ProjectNdepExist1}:
      ${errfdr:::ERR_ProjectNdepExist2},
    call("4glgpf::KeyDesc:Branch"),
    @@ndep,
    @@eday1>=@@day1 || @@eday2==$DayMax? @@eday1: @@eday2 );
#}
;--------------------------------------------------
; проверить использование подпроекта в счетах
char branch_sub_cnu_accnt_parms=day1,day2
char branch_sub_cnu_accnt=\
#{
  SQL select min(c_accnt)
      into ?ekey
      from accnts_def
      where c_branch=?c_branch and
        delete_day>='@day1' and open_day<='@day2';
  isnull(@@ekey)?
    return(0): 0;
; получаем даты использования
  $DATE(eday1,eday2)
  SQL select open_day,delete_day
      into ?eday1,?eday2
      from accnts_def
      where c_accnt=?ekey;
  RaiseError( @@eday2==$DayMax?
      ${errfdr:::ERR_ProjectUsedByAccnt1}:
      ${errfdr:::ERR_ProjectUsedByAccnt2},
    call("4glgpf::KeyDesc:Accnt"),
    @@eday2==$DayMax? @@eday1: @@eday2 );
#}
;--------------------------------------------------
; проверить использование филиала как зависимого филиала
char branch_cnu_cons_parms=day1,day2
char branch_cnu_cons=\
#{
  SQL select min(c_cons)
      into ?ekey
      from branches_cons_dep
      where c_branch=?c_branch and
        delete_day>='@day1' and open_day<='@day2';
  isnull(@@ekey)?
    return(0): 0;
; получаем даты использования
  $DATE(eday1,eday2)
  SQL select open_day,delete_day
      into ?eday1,?eday2
      from branches_cons_dep
      where c_cons=?ekey and c_branch=?c_branch;
  RaiseError( @@eday2==$DayMax?
      ${errfdr:::ERR_ProjectUsedBySup1}:
      ${errfdr:::ERR_ProjectUsedBySup1},
    call("4glgpf::KeyDesc:Branch"),
    @@eday2==$DayMax? @@eday1: @@eday2 );
#}
;--------------------------------------------------
; проверить существование филиала в периоде
char branch_cex_parms=pref,day1,day2
char branch_cex=\
#{
  @@@{pref}open_day<=@@day1? 0:
    RaiseError( ${errfdr:::ERR_ProjectNoBefore},
      @@@{pref}shname, @@day1, @@@{pref}open_day );
  @@@{pref}delete_day>=@@day2? 0:
    RaiseError( ${errfdr:::ERR_ProjectNoAfter},
      @@@{pref}shname, @@day2, @@@{pref}delete_day );
#}
;==================================================
; подпроекты проекта (список филиалов для консолидации)
[BranchConsDep] default: AccntSetTpl
const char ks_table=branches_cons_dep
const char ks_keys=c_cons,c_branch
char ks_order=c_cons,c_branch
const char history=open:open_day/delete_day
char query_defaults=open_day:@today;delete_day:$DayMax;
char foreigns=\
#{
; для проверки существования и типа
  ConsAll($CURCFG::BranchAll):c_cons(c_branch);
  BranchAll($CURCFG::BranchAll):c_branch;
#}
char lookups=\
#{
  Cons($CURCFG::BranchSup):c_cons(c_branch);
  Branch($CURCFG::BranchSub):c_branch;
#}
char fmt_desc=Подпроект [Branch.ndep]
;--------------------------------------------------
; specials
const char spc_codes=\
#{
  $spcRollbackDelete: PLACE_NORIGHT;
  $spcRollbackInsert: PLACE_NORIGHT;
#}
;--------------------------------------------------
; validate
char kernel_history=\
#{
; проверяем существование филиала-консолидации, тип филиала-консолида-
; ции, существование филиала, дубликат филиала в списке консолидации
  New           : VldNew(rb_flag=0);
  RollbackDelete: VldNew(rb_flag=1);
#}
char VldNew_parms=rb_flag
char VldNew=\
#{
; проверяем существование филиала-консолидации в периоде
  call("$CURCFG::cmds:branch_cex", "ConsAll.",
    @@open_day, @@delete_day );
; проверяем существование филиала в периоде
  call("$CURCFG::cmds:branch_cex", "BranchAll.",
    @@open_day, @@delete_day );
; запрещаем добавлять к стандартному проекту или стандартный подпроект
  @@c_cons==$BRANCH_CONS?
    RaiseError( ${errfdr:::ERR_ProjectReserved2},
      call("4glgpf::KeyDesc:Branch",@@c_cons) ):
  @@c_branch==$BRANCH_OUR?
    RaiseError( ${errfdr:::ERR_ProjectReserved3},
      call("4glgpf::KeyDesc:Branch",@@c_branch) ):
    0;
; проверяем типы филиалов (после проверки можно обращаться к подобъектам
; Cons и Branch, но в них есть еще ограничение по типу)
  @@ConsAll.type==$BRANCH_TYPE_CONS &&
  @@BranchAll.type==$BRANCH_TYPE_UNIBANK? 0:
    RaiseError( ${errfdr:::ERR_ProjectIllegalType} );
; проверяем дубликат филиала в списке консолидации
  call("$CURCFG::cmds:branch_cons_cdu",
    @@rb_flag==1? @@STORE.delete_day+1: @@open_day,
    @@delete_day );
#}
;--------------------------------------------------
; филиалы на просмотр (без ограничений на сегодняшний день)
[BranchAll]
#copy 4glgpf::TruncAll_tpl
#copy 4glgpf::RO_tpl1
#copy 4glgpf::RO_tpl2
#copy 4glgpf::RO_tpl3
;--------------------------------------------------
[cmds]
; проверить дубликат филиала в списке консолидации
char branch_cons_cdu_parms=day1,day2
char branch_cons_cdu=\
#{
  $DATE(eday2)
  SQL select min(delete_day)
      into ?eday2
      from branches_cons_dep
      where c_cons=?c_cons and c_branch=?c_branch and
        delete_day>='@day1' and open_day<='@day2' and
        not(c_cons=?STORE.c_cons and c_branch=?STORE.c_branch and
          delete_day=?STORE.delete_day);
  isnull(@@eday2)?
    return(0): 0;
; получаем информацию о дубликате
  $DATE(eday1)
  SQL select open_day
      into ?eday1
      from branches_cons_dep
      where c_cons=?c_cons and c_branch=?c_branch and
        delete_day=?eday2;
  RaiseError( @@eday1>=@@day1 || @@eday2==$DayMax?
      ${errfdr:::ERR_ProjectSubExist1}:
      ${errfdr:::ERR_ProjectSubExist2},
    call("4glgpf::KeyDesc:Branch",@@c_cons),
    call("4glgpf::KeyDesc:Branch",@@c_branch),
    @@eday1>=@@day1 || @@eday2==$DayMax? @@eday1: @@eday2 );
#}
;==================================================
[BranchSup]
const char main_class=DB_Kscurs
char parent_kstat=$CURCFG::Branch
char cursor_type=dynamic
char ks_where=[type]=$BRANCH_TYPE_CONS
char ks_defaults=type:$BRANCH_TYPE_CONS;
;--------------------------------------------------
[BranchSub]
const char main_class=DB_Kscurs
char parent_kstat=$CURCFG::Branch
char cursor_type=dynamic
char ks_where=[type]=$BRANCH_TYPE_UNIBANK
char ks_defaults=type:$BRANCH_TYPE_UNIBANK;
;--------------------------------------------------
; редактирование
[BranchSupEdit]
const char main_class=DB_Form
char parent_kstat=$CURCFG::BranchSup
char title=Описание проектов
char scr_name=fdr_branch_sup_frm
char filter_screen=fdr_branch_sup_slct
char scr_mode=select
char edt_modes=suix!p
char spc_list=/\
#{","
  $spcDelete
  $spcRollbackDelete
  $spcRollbackInsert
#}
char add_acts=\
#{
  *(add,dispatch,"Вставка#P-"):LFENTER
  { pipe=
      vldopn{opn=insert};
      doopn{opn=insert};
      setmode{mode=edit};
      doopn{opn=read}
  };
#}
char forms_aux=BCD:$CURCFG::BCD_aux;
;--------------------------------------------------
[BranchSubEdit] BranchSupEdit
char parent_kstat=$CURCFG::BranchSub
char title=Описание подпроектов
char scr_name=fdr_branch_sub_frm
char filter_screen=fdr_branch_sub_slct
char forms_aux=Projects:$CURCFG::Projects_aux;
;--------------------------------------------------
; подпроекты в проекте
[BCD_aux]
const char main_class=DB_XForm
char title=Подпроекты проекта
char scr_name=fdr_branch_sup_sub_tbl
char stdmode=view
char edt_modes=six!p!P
long empty->add=1
char spc_list=/\
#{","
  $spcDelete
  $spcRollbackDelete
  $spcRollbackInsert
#}
char enterline_add=protect{list='+open_day,delete_day;'};
;--------------------------------------------------
; проекты подпроекта
[Projects_aux]
const char main_class=DB_XForm
char title=Проекты подпроекта
char vars_prefix=Cons
char scr_name=fdr_branch_sup_slct
char stdmode=view
char edt_modes=s!p!P

;==================================================
; выбор текущего проекта, ограничивающего счета/контрагентов/настройки и т.д.
;--------------------------------------------------
[BranchSelect]
const char main_class=DB_Form
;const char parent_kstat=$CURCFG::BranchSup
const char parent_kstat=$CURCFG::BranchAll
const char ks_where=exists (select * from uk_ref_users_branches u where u.c_user = @CurrUser.c_user and u.c_branch = [c_branch])
char title=Выбор текущего проекта
char scr_name=fdr_branch_sup_slct
char scr_mode=tselect
char filter_mode=view
char edt_modes=s!p!P
long show_if_one=1
long save_current=1
char env_name=BranchSelect


;> ============================================================================
;> __spc_codes
;> ============================================================================
char spc_codes=\
#{";"
  $spcUserCode1 (@SaveToStdEnv)
  $spc_get_cld_days (<@_get_cld_days>):#P_get_cld_days_parms;
  $spc_set_cld_days (<@_set_cld_days>):#P_set_cld_days_parms;
#}

;> ============================================================================
;> __get_cld_days
;    возвращаемые переменные (в коллекции _coll_ext):
;      _cld_days           - строка расшифровывающая дни месяца (w-рабочий/h-выходной)
;      _is_calendar_exists - признак нахождения информации в таблице с календарем
;> ============================================================================
const char _get_cld_days_parms=\
#{";"
  _cld_year:Год#Tlong_t
  _cld_month:Месяц#Tlong_t
  _c_employee:ID работника#Tlong_t
  _coll_ext:Имя внешней коллекции#Tstring_t
#}
const char _get_cld_days=\
#{
; -------------------------------------
; внешняя переменная
; -------------------------------------
  $CHAR(_cld_days)
  _cld_days = (@@_c_employee == 0)
                    ? call("$CURCFG::$CURSEC:_get_cld_days_global",   @@_cld_year, @@_cld_month)
                    : call("$CURCFG::$CURSEC:_get_cld_days_employee", @@_cld_year, @@_cld_month, @@_c_employee);

  @_coll_ext.RenewVarsFromColl(CURRENT.get_name());
#}


;> ------------------------------------------------
;> __get_cld_days_global
;> ------------------------------------------------
const char _get_cld_days_global_parms=_cld_year,_cld_month
const char _get_cld_days_global=\
#{
  $LONG(_cnt)
  SQL select count(*) into ?_cnt from calendar where cldyear = @_cld_year and cldmonth = @_cld_month;

  $LONG(_is_calendar_exists)
  _is_calendar_exists = (@@_cnt == 0) ? $_FALSE : $_TRUE;

  $CHAR(_cld_days_global)
  _cld_days_global = (@@_cnt == 0)
                        ? call("$CURCFG::$CURSEC:_get_cld_days_default", @@_cld_year, @@_cld_month)
                        : call("$CURCFG::$CURSEC:_get_cld_days_from_table", @@_cld_year, @@_cld_month);

  return(@@_cld_days_global);
#}

;> ------------------------------------------------
;> __get_cld_days_employee
;> ------------------------------------------------
const char _get_cld_days_employee_parms=_cld_year,_cld_month,_c_employee
const char _get_cld_days_employee=\
#{
  $LONG(_cnt)
  SQL select count(*) into ?_cnt from $uk_employees_calendar where cldyear = @_cld_year and cldmonth = @_cld_month and c_employee = @_c_employee;

  $LONG(_is_calendar_exists)
  _is_calendar_exists = (@@_cnt == 0) ? $_FALSE : $_TRUE;

  $CHAR(_cld_days_employee)
  _cld_days_employee = (@@_cnt == 0)
                        ? call("$CURCFG::$CURSEC:_get_cld_days_global", @@_cld_year, @@_cld_month)
                        : call("$CURCFG::$CURSEC:_get_cld_days_from_employee_table", @@_cld_year, @@_cld_month, @@_c_employee);

  return(@@_cld_days_employee);
#}

;> ------------------------------------------------
;> __get_cld_days_from_table
;> ------------------------------------------------
const char _get_cld_days_from_table_parms=_cld_year,_cld_month
const char _get_cld_days_from_table=\
#{
  $CHAR(_days)
  SQL select clddays into ?_days from calendar where cldyear = @_cld_year and cldmonth = @_cld_month;
  return(@@_days);
#}

;> ------------------------------------------------
;> __get_cld_days_from_employee_table
;> ------------------------------------------------
const char _get_cld_days_from_employee_table_parms=_cld_year,_cld_month,_c_employee
const char _get_cld_days_from_employee_table=\
#{
  $CHAR(_days)
  SQL select clddays into ?_days from $uk_employees_calendar where cldyear = @_cld_year and cldmonth = @_cld_month and c_employee = @_c_employee;
  return(@@_days);
#}


;> ------------------------------------------------
;> __get_cld_days_default
;    формируем строку в зависимости от дня недели
;> ------------------------------------------------
const char _get_cld_days_default_parms=_cld_year,_cld_month
const char _get_cld_days_default=\
#{
; -------------------------------------
; вычисляем последний календарный день текущего месяца
; -------------------------------------
  $LONG(_op_day,_cldom)
  $LONG(_d,_m,_y)
    _op_day = long(rmdyjul(@@_cld_month, 01, @@_cld_year));
    _cldom = CldGetLimit(@@_op_day, "cldom");
    rjulmdy(@@_cldom, "_m", "_d", "y");

  $CHAR(_last_cfdoy)
    _last_cfdoy = "01.01.20" + string(@@_d);

  $CHAR(_days)  _days = "";
  $LONG(_day,_day_of_week)


; -------------------------------------
; цикл по всем допустимым дням месяца 
; (трюк с таблицей с годовыми датами)
; -------------------------------------
  CURSOR
    select year(y.cfdoy) - 2000 into ?_day
    from $utl_year_dates y
    where
      y.cfdoy between "01.01.2001" and date("@_last_cfdoy")
    : call("$CURCFG::$CURSEC:_add_day_to_cld_days", string(@@_day) + "." + string(@@_cld_month) + "." + string(@@_cld_year));

  return(@@_days);
#}

;> ----------------------------------------------------------------------------
;> __add_day_to_cld_days
;> ----------------------------------------------------------------------------
const char _add_day_to_cld_days_parms=_date
const char _add_day_to_cld_days=\
#{
  SQL select weekday("@_date") into ?_day_of_week from opdays where op_day = $DATE_START;

  _days = @@_days + string(((@@_day_of_week == 0) || (@@_day_of_week == 6)) ? "h" : "w");
#}


;> ============================================================================
;> __set_cld_days
;> ============================================================================
const char _set_cld_days_parms=\
#{";"
  _cld_year:Год#Tlong_t
  _cld_month:Месяц#Tlong_t
  _c_employee:ID работника#Tlong_t
  _cld_days:Строка#Tstring_t
#}
const char _set_cld_days=\
#{
  $LONG(_cnt)
  (@@_c_employee == 0)
      ? call("$CURCFG::$CURSEC:_set_cld_days_global", @@_cld_year, @@_cld_month, @@_cld_days)
      : call("$CURCFG::$CURSEC:_set_cld_days_employee", @@_cld_year, @@_cld_month, @@_c_employee, @@_cld_days);

#}

;> ------------------------------------------------
;> __set_cld_days_global
;> ------------------------------------------------
const char _set_cld_days_global_parms=_cld_year,_cld_month,_cld_days
const char _set_cld_days_global=\
#{
  SQL select count(*) into ?_cnt from calendar where cldyear = @_cld_year and cldmonth = @_cld_month;

  (@@_cnt == 0)
      ? call("$CURCFG::$CURSEC:_insert_global_calendar", @@_cld_year, @@_cld_month, @@_cld_days)
      : call("$CURCFG::$CURSEC:_update_global_calendar", @@_cld_year, @@_cld_month, @@_cld_days);
#}

;> ------------------------------------------------
;> __insert_global_calendar
;> ------------------------------------------------
const char _insert_global_calendar_parms=_cld_year,_cld_month,_cld_days
const char _insert_global_calendar=\
#{
  _coll_insert  = Auth.obj_by_name("<null>", "DB_Coll");
    @_coll_insert.ClearNames();
    @_coll_insert.AssignVarShort("cldyear",   @@_cld_year);
    @_coll_insert.AssignVarShort("cldmonth",  @@_cld_month);
    @_coll_insert.AssignVarString("clddays",  @@_cld_days);
  Calendar.DoInsertForColl(@@_coll_insert);

  Auth.delete_obj_by_name(@@_coll_insert);
#}

;> ------------------------------------------------
;> __update_global_calendar
;> ------------------------------------------------
const char _update_global_calendar_parms=_cld_year,_cld_month,_cld_days
const char _update_global_calendar=\
#{
  _coll_update  = Auth.obj_by_name("<null>", "DB_Coll");
    @_coll_update.ClearNames();
    @_coll_update.AssignVarString("clddays",  @@_cld_days);

  Calendar.SetKeyShort("cldyear", @@_cld_year);
  Calendar.SetKeyShort("cldmonth", @@_cld_month);
  Calendar.DoUpdateForColl(@@_coll_update);

  Auth.delete_obj_by_name(@@_coll_update);
#}

;> ------------------------------------------------
;> __set_cld_days_employee
;> ------------------------------------------------
const char _set_cld_days_employee_parms=_cld_year,_cld_month,_c_employee,_cld_days
const char _set_cld_days_employee=\
#{
  SQL select count(*) into ?_cnt from $uk_employees_calendar where cldyear = @_cld_year and cldmonth = @_cld_month and c_employee = @_c_employee;

  (@@_cnt == 0)
      ? call("$CURCFG::$CURSEC:_insert_employee_calendar", @@_cld_year, @@_cld_month, @@_c_employee, @@_cld_days)
      : call("$CURCFG::$CURSEC:_update_employee_calendar", @@_cld_year, @@_cld_month, @@_c_employee, @@_cld_days);
#}

;> ------------------------------------------------
;> __insert_employee_calendar
;> ------------------------------------------------
const char _insert_employee_calendar_parms=_cld_year,_cld_month,_c_employee,_cld_days
const char _insert_employee_calendar=\
#{
  _coll_insert  = Auth.obj_by_name("<null>", "DB_Coll");
    @_coll_insert.ClearNames();
    @_coll_insert.AssignVarShort("cldyear",   @@_cld_year);
    @_coll_insert.AssignVarShort("cldmonth",  @@_cld_month);
    @_coll_insert.AssignVarLong("c_employee", @@_c_employee);
    @_coll_insert.AssignVarString("clddays",  @@_cld_days);
  uk_main::UK_Employees_Calendar.DoInsertForColl(@@_coll_insert);

  Auth.delete_obj_by_name(@@_coll_insert);
#}

;> ------------------------------------------------
;> __update_employee_calendar
;> ------------------------------------------------
const char _update_employee_calendar_parms=_cld_year,_cld_month,_c_employee,_cld_days
const char _update_employee_calendar=\
#{
  _coll_update  = Auth.obj_by_name("<null>", "DB_Coll");
    @_coll_update.ClearNames();
    @_coll_update.AssignVarString("clddays",  @@_cld_days);

  uk_main::UK_Employees_Calendar.SetKeyShort("cldyear", @@_cld_year);
  uk_main::UK_Employees_Calendar.SetKeyShort("cldmonth", @@_cld_month);
  uk_main::UK_Employees_Calendar.SetKeyLong("c_employee", @@_c_employee);
  uk_main::UK_Employees_Calendar.DoUpdateForColl(@@_coll_update);

  Auth.delete_obj_by_name(@@_coll_update);
#}



;> ============================================================================
;> __SaveToStdEnv
;    для начальной загрузки и тестов
;> ============================================================================
char SaveToStdEnv=\
#{
  StdEnv.StoreObj("$CURSEC", @@THIS);
#}







;> ============================================================================
;  счета
;> accnts
; описание атрибутов:
;   ...
;   acckind
;   access
;   main         - тип основных стредств
;   nukind       - тип амортизации (в оригинальном Юнибанке это поле отвечало за что-то другое)
;> ============================================================================
[Accnt_Of_Branch]
const char main_class=DB_Kscurs
const char parent_kstat=Accnt
char ks_where=$BRANCH_WHERE_OBJ

; все счета (с историей)
[Accnt] default: AccntTpl
const char ks_table=accnts_def
const char serial=c_accnt
const char ks_keys=c_accnt
; будет перекрыто в курсорах
char ks_order=c_accnt
char history=open:open_day/delete_day
char query_defaults=open_day:@today;delete_day:$DayMax;
char ks_defaults=\
#{";"
  subacc:-1
  nsubacc:0
; автоматически установится по NPL.type
  nactpass:0
;
  c_branch:@BranchSelect.c_branch
  nukind:0
  ndep:0
  main:1
#}

char foreigns=\
#{";"
  AccntName($CURCFG::AccntName):c_accnt
  Nukind($CURCFG::Nukinds):nukind(ukind)
; ---------------------------
;  NS5($CURCFG::Nsymbols5):nsymbf2
; ---------------------------
  NS5($CURCFG::Nsymbols2_f5):c_nsymbf2_f5
  NAccntAcckind($CURCFG::NAccntAcckind):c_naccnt,acckind
; ---------------------------
; ссылки на kernel'овские переменные
; ---------------------------
  AccClient($CURCFG::AccClient):c_accnt
  AccContr($CURCFG::AccContr):c_accnt
  AccStat($CURCFG::AccStat):c_accnt
  RestRUR($CURCFG::Turnovers):c_accnt,'$CURR_ROUBLE'(c_curr),@today(op_day)
; ---------------------------
; для проверки типа подпроекта (проверка существования осуществляется в
; kernel'е)
; ---------------------------
  BranchAll($CURCFG::Branch):c_branch
#}

char lookups=\
#{";"
  NPL($CURCFG::NPl_accnt2):c_naccnt
  Acckind($CURCFG::Acckind):acckind
  Ntype($CURCFG::AbbrsAccntNtype):ntype(type)
  Branch($CURCFG::BranchSub):c_branch
#}

char refs_x1=\
#{";"
  NPL_X1($CURCFG::NPl_accnt2):naccnt
  MainType(uk_main::UK_Abbrs_MainType):ndep(cfg_attr)
  DepreciationType(uk_main::UK_Abbrs_DepreciationType):nukind(cfg_attr)
  Orders(uk_reports::UK_Report_Orders_For_Accnt):c_accnt,'$CURR_ROUBLE'(c_curr),'$_EMPTY'(order_state),'$_TRUE'(is_hide_deleted)
  OrdersAll(uk_reports::UK_Report_Orders_For_Accnt):c_accnt,'$CURR_ROUBLE'(c_curr),'$_EMPTY'(order_state),'$_FALSE'(is_hide_deleted)
  OrdersEntered(uk_reports::UK_Report_Orders_For_Accnt):c_accnt,'$CURR_ROUBLE'(c_curr),'$ORDER_STATE_ENTERED'(order_state),'$_TRUE'(is_hide_deleted)
  OrdersPerformed(uk_reports::UK_Report_Orders_For_Accnt):c_accnt,'$CURR_ROUBLE'(c_curr),'$ORDER_STATE_PERFORMED'(order_state),'$_TRUE'(is_hide_deleted)
  Turnovers_with_to($CURCFG::Turnovers_with_to):c_accnt,'$CURR_ROUBLE'(c_curr)
#}

char slave_refs=\
#{";"
  AccntCurr($CURCFG::AccntCurr):c_accnt
#}

char fmt_desc=[ncurracc]
; удобное сокращение
char synonyms=name==AccntName.name;
;--------------------------------------------------
char filter_fields=ncurracc:\
#{"|"
  (%*%[ ])(naccnt)/(%*nsubacc)
  (%*%[ ])(%*naccnt)//(nsymbf2)
  (%*%[ ])(%*naccnt)!(Branch.ndep)
  (%*%[ ])(%d%[\'.]ncurracc)
  (%*%[ ])(AccntName.name)
#};\
#{
; для точного поиска
  curracc_lu: (%?%=%d%[\'.]ncurracc);
#}
char synonyms=${.:synonyms}curracc_lu==ncurracc;
;--------------------------------------------------
; эти составные атрибуты обрабатываются в методе DB_Kernel::AccntChange
; основного (этого объекта). Если их не указать, то при отсутствии
; изменённых атрибутов основного объекта этот метод не будет вызван и
; эти атрибуты изменены не будут.
char kernel_vars=\
#{","
  AccntName.name
#}
; эти операции обрабатываются kernel'ом
char rfc_modifiers=AccntCurr:dID;
; дополнительные проверки (как в docmng)
char pipe_insert_vld=\
#{
  @THIS.InvokeKernel( "DB_Kernel::AccntNewVld",
    CURRENT.get_name(), CURRENT.get_name() );
  call("$CURCFG::cmds:accnt_extra_vld");
#}
char pipe_update_vld=\
#{
  @THIS.InvokeKernel( "DB_Kernel::AccntChangeVld",
    CURRENT.get_name(), CURRENT.get_name() );
  call("$CURCFG::cmds:accnt_extra_vld");
#}

;> ----------------------------------------------------------------------------
;> __pipe_pre_insert
;> ----------------------------------------------------------------------------
char pipe_pre_insert=\
#{
  (@@naccnt == 0) && (@@c_naccnt > 0)
      ? (IO.naccnt = @@NPL.naccnt)
      : 0;
  HEAP.c_naccnt = @@c_naccnt;

  (@@nsymbf2 == 0) && (@@c_nsymbf2_f5 > 0)
      ? (IO.nsymbf2 = @@NS5.nsymbf2_out)
      : 0;
  HEAP.c_nsymbf2_f5 = @@c_nsymbf2_f5;
#}

;> ----------------------------------------------------------------------------
;> __pipe_post_insert
;    трюк, чтобы работали новые аттрибуты
;    (т.к. они жестко прописаны в ядре, которое мне пока не под силу)
;> ----------------------------------------------------------------------------
char pipe_post_insert=\
#{
  SQL update accnts_def set (c_naccnt, c_nsymbf2_f5) = (@{HEAP.c_naccnt}, @{HEAP.c_nsymbf2_f5}) where c_accnt = @c_accnt;
#}

;> ----------------------------------------------------------------------------
; используем директивы для вызова kernel'а
;> ----------------------------------------------------------------------------
char insert=\
#{
  call($CURCFG::$CURSEC:AccntOpen);
  copy(${.:ks_keys});
#}
char AccntOpen=\
#{
  @THIS.InvokeKernel("DB_Kernel::AccntNew",
    CURRENT.get_name(), CURRENT.get_name() );
  @THIS.KeysFromCollection( CURRENT.get_name() );
#}

;> ----------------------------------------------------------------------------
char update=call($CURCFG::$CURSEC:AccntChange);
char AccntChange=\
#{
  @THIS.InvokeKernel("DB_Kernel::AccntChange",
    CURRENT.get_name(), CURRENT.get_name() );
#}

;> ----------------------------------------------------------------------------
char delete=call($CURCFG::$CURSEC:AccntDelete);
char AccntDelete=\
#{
  @THIS.InvokeKernel("DB_Kernel::AccntDelete",
    CURRENT.get_name(), CURRENT.get_name() );
#}

;> ----------------------------------------------------------------------------
char rollback_insert=call($CURCFG::$CURSEC:AccntRollbackInsert);
char AccntRollbackInsert=\
#{
  spc_code=$spcAccnt_RollbackInsert;
  new_ssub=0;
  ssub_tbl="";
  @THIS.InvokeKernel("DB_Kernel::AccntSpc",
    CURRENT.get_name(), CURRENT.get_name() );
#}

;> ----------------------------------------------------------------------------
char rollback_delete=call($CURCFG::$CURSEC:AccntRollbackDelete);
char AccntRollbackDelete=\
#{
  spc_code=$spcAccnt_RollbackDelete;
  new_ssub=0;
  ssub_tbl="";
  @THIS.InvokeKernel("DB_Kernel::AccntSpc",
    CURRENT.get_name(), CURRENT.get_name() );
#}

; special через kernel
char spc_default=@DefaultSpc(c_accnt,new_ssub=0,ssub_tbl='')
char DefaultSpc=\
#{
  $CURCFG::$CURSEC.InvokeKernel("DB_Kernel::AccntSpc",
    CURRENT.get_name(), CURRENT.get_name() );
#}
char DefaultSpc_vld=BREAK=\
#{
  $CURCFG::$CURSEC.InvokeKernel("DB_Kernel::AccntSpcVld",
    CURRENT.get_name(), CURRENT.get_name() );
#}

;> ----------------------------------------------------------------------------
;> __spc
;> ----------------------------------------------------------------------------
const char spc_codes=\
#{
  $spcRollbackInsert: PLACE_ACCNT;
  $spcRollbackDelete: PLACE_ACCNT;
  $spc_get_tunning_info (<@_get_tunning_info (c_accnt,ncurracc,AccntName.name,c_branch,DepreciationType.Ext.months_count,
                                              c_naccnt,naccnt,c_nsymbf2_f5,nsymbf2,nsubacc,access,ndep,nukind)>):#P_get_tunning_info_parms;
  $spc_age_accnt (<@_age_accnt (c_accnt,open_day)>):#P_age_accnt_parms;
  $spc_dogovor_perform_all_orders                 (<OrdersEntered.$spc_uk_orders_performed_full>);
  $spc_dogovor_rollback_performed_all_orders      (<OrdersPerformed.$spc_uk_orders_performed_full_rollback>);
#}

;> ------------------------------------------------
;> __get_tunning_info
;    получение аттрибутов объекта и сохранение их во внешней коллекции
;    для использования в Delphi
;> ------------------------------------------------
const char _get_tunning_info_parms=\
#{";"
  ext_coll_name:Имя внешней коллекции#Tstring_t
#}
const char _get_tunning_info=\
#{
  @ext_coll_name.RenewVarsFromColl(CURRENT.get_name());
#}

;> ----------------------------------------------------------------------------
;> __age_accnt
;    состаривание счета (перенос даты открытия на более раннюю дату с заполнением вх. остатков)
;> ----------------------------------------------------------------------------
const char _age_accnt_parms=\
#{";"
  new_open_day:Новая дата#Tdate_t
#}
const char _age_accnt=\
#{
  $LONG(_open_day, _new_open_day)
    _open_day     = long(@@open_day);
    _new_open_day = long(@@new_open_day);

  (@@_new_open_day < $DATE_START)
    ? RaiseError(-1, "Нельзя перенести счет раньше даты начала работы программы!", "")
    : 0;

  (@@_new_open_day > @@_open_day)
    ? RaiseError(-1, "Новая дата открытия должна быть меньше текущей даты открытия!", "")
    : 0;

; -------------------------------------
; таблицы без истории
; -------------------------------------
  SQL update accnts_def   set open_day = @_new_open_day where c_accnt = @c_accnt;
  SQL update accnts_multi set open_day = @_new_open_day where c_accnt = @c_accnt;

; -------------------------------------
; таблицы с историей
; -------------------------------------
  call("$CURCFG::$CURSEC:_update_accnt_table_with_history", "accnts_name",   @@c_accnt, @@_new_open_day);
  call("$CURCFG::$CURSEC:_update_accnt_table_with_history", "accnts_client", @@c_accnt, @@_new_open_day);
  call("$CURCFG::$CURSEC:_update_accnt_table_with_history", "accnts",        @@c_accnt, @@_new_open_day);
  call("$CURCFG::$CURSEC:_update_accnt_table_with_history", "accnts_state",  @@c_accnt, @@_new_open_day);

; -------------------------------------
; остатки по каждой валюте
; -------------------------------------
  $LONG(_c_curr)
  CURSOR
    select c_curr into ?_c_curr
    from accnts_multi
    where
      c_accnt = @c_accnt
    : call("$CURCFG::$CURSEC:_update_turnovers", @@c_accnt, @@_c_curr, @@_new_open_day);

;  RaiseError(-1, "success!!!", "");
#}

;> ----------------------------------------------------------------------------
;> __update_accnt_table_with_history
;> ----------------------------------------------------------------------------
const char _update_accnt_table_with_history_parms=_tbl,_c_accnt,_new_prev_change
const char _update_accnt_table_with_history=\
#{
  $LONG(_prev_change)
  SQL select min(prev_change) into ?_prev_change from @_tbl where c_accnt = @_c_accnt;
  SQL update @_tbl set prev_change = @_new_prev_change where c_accnt = @_c_accnt and prev_change = @_prev_change;
#}

;> ----------------------------------------------------------------------------
;> __update_turnovers
;> ----------------------------------------------------------------------------
const char _update_turnovers_parms=_c_accnt,_c_curr,_new_open_day
const char _update_turnovers=\
#{
; -------------------------------------
; 1) turnovers
; -------------------------------------

; -------------------------------------
; минимальная дата оборотов
; -------------------------------------
  $LONG(_op_day)
  SQL
    select min(op_day) into ?_op_day
    from turnovers
    where
      c_accnt = @_c_accnt and
      c_curr  = @_c_curr;

; -------------------------------------
; вх. остатки на мин. дату оборотов
; -------------------------------------
  $MONEY(_debit1,_credit1)
  SQL
    select debit1, credit1 into ?_debit1, ?_credit1
    from turnovers
    where
      c_accnt = @_c_accnt and
      c_curr  = @_c_curr  and
      op_day  = @_op_day;

; -------------------------------------
; заполняем остатки за каждый опер. день от новой минимальной до текущей
; -------------------------------------
  SQL
    insert into turnovers (c_accnt, c_curr, op_day, debit1, credit1, debit_to, credit_to, debit2, credit2)
      select @_c_accnt, @_c_curr, o.op_day, @_debit1, @_credit1, 0, 0, @_debit1, @_credit1
      from opdays o
      where
        o.op_day >= @_new_open_day and
        o.op_day <  @_op_day;


; -------------------------------------
; 2) accnts_blnc
; -------------------------------------

  $LONG(_op_day)
  SQL
    select min(op_day) into ?_op_day
    from accnts_blnc
    where
      c_accnt = @_c_accnt and
      c_curr  = @_c_curr;

  SQL
    insert into accnts_blnc (c_accnt, c_curr, op_day, info_turnover_d, info_turnover_c)
      select @_c_accnt, @_c_curr, o.op_day, 0, 0
      from opdays o
      where
        o.op_day >= @_new_open_day and
        o.op_day <  @_op_day;

#}


; -----------------------------------------------------------------------------
; все счета 
; -----------------------------------------------------------------------------
[AccntWithoutHistory]
const char main_class=DB_Kstat
const char read_access=any
const char ks_table=accnts_def
const char serial=c_accnt
const char ks_keys=c_accnt
const char ks_order=c_accnt

char foreigns=\
#{";"
  AccntName($CURCFG::AccntName):c_accnt
  Nukind($CURCFG::Nukinds):nukind(ukind)
;  NS5($CURCFG::Nsymbols5):nsymbf2
  NS5($CURCFG::Nsymbols2_f5):c_nsymbf2_f5
  NAccntAcckind($CURCFG::NAccntAcckind):c_naccnt,acckind
; ссылки на kernel'овские переменные
  AccClient($CURCFG::AccClient):c_accnt
  AccContr($CURCFG::AccContr):c_accnt
  AccStat($CURCFG::AccStat):c_accnt
  RestRUR($CURCFG::Turnovers):c_accnt,'$CURR_ROUBLE'(c_curr),@today(op_day)
; ---------------------------
; для проверки типа подпроекта (проверка существования осуществляется в
; kernel'е)
  BranchAll($CURCFG::Branch):c_branch
#}

char lookups=\
#{";"
  NPL($CURCFG::NPl_accnt2):c_naccnt
  Acckind($CURCFG::Acckind):acckind
  Ntype($CURCFG::AbbrsAccntNtype):ntype(type)
  Branch($CURCFG::BranchSub):c_branch
#}

char refs_x1=\
#{";"
  NPL_X1($CURCFG::NPl_accnt2):naccnt
  MainType(uk_main::UK_Abbrs_MainType):ndep(cfg_attr)
  DepreciationType(uk_main::UK_Abbrs_DepreciationType):nukind(cfg_attr)
  Orders(uk_reports::UK_Report_Orders_For_Accnt):c_accnt,'$CURR_ROUBLE'(c_curr),'$_EMPTY'(order_state),'$_TRUE'(is_hide_deleted)
  OrdersAll(uk_reports::UK_Report_Orders_For_Accnt):c_accnt,'$CURR_ROUBLE'(c_curr),'$_EMPTY'(order_state),'$_FALSE'(is_hide_deleted)
  OrdersEntered(uk_reports::UK_Report_Orders_For_Accnt):c_accnt,'$CURR_ROUBLE'(c_curr),'$ORDER_STATE_ENTERED'(order_state),'$_TRUE'(is_hide_deleted)
  OrdersPerformed(uk_reports::UK_Report_Orders_For_Accnt):c_accnt,'$CURR_ROUBLE'(c_curr),'$ORDER_STATE_PERFORMED'(order_state),'$_TRUE'(is_hide_deleted)
  Turnovers_with_to($CURCFG::Turnovers_with_to):c_accnt,'$CURR_ROUBLE'(c_curr)
#}

char slave_refs=\
#{";"
  AccntCurr($CURCFG::AccntCurr):c_accnt
#}

char synonyms=name==AccntName.name;


;const char foreigns=${dbores::Accnt_Of_Branch:foreigns}
;const char lookups=${dbores::Accnt_Of_Branch:lookups}
;const char refs_x1=${dbores::Accnt_Of_Branch:refs_x1}
;const char slave_refs=${dbores::Accnt_Of_Branch:slave_refs}
;const char synonyms=${dbores::Accnt_Of_Branch:synonyms}


;--------------------------------------------------
[cmds]
; дополнительные проверки после kernel'овских
char accnt_extra_vld=\
#{
; проверяем подпроект (kernel уже проверил существование c_branch)
; допускаем подпроект "Общий"
  @@c_branch==$BRANCH_OUR? 0:
; допускаем любой подподпроект
  @@BranchAll.type==$BRANCH_TYPE_UNIBANK? 0:
    RaiseError( ${errfdr:::ERR_AccntIllegalSubproj}, @@BranchAll.ndep );
#}
;==================================================
; наименование счёта
[AccntName] default: AccntTpl
const char ks_table=accnts_name
const char ks_keys=c_accnt
char ks_where=@today between [prev_change] and [next_change]
;--------------------------------------------------
; клиент счёта
[AccClient]
const char main_class=DB_Kstat
const char read_access=any
const char ks_table=accnts_client
const char ks_keys=c_accnt
char ks_where=@today between [prev_change] and [next_change]
char ks_defaults=c_client:$CLIENT_OUR_BANK;
;--------------------------------------------------
; договор счёта
[AccContr]
const char main_class=DB_Kstat
const char read_access=any
const char ks_table=accnts
const char ks_keys=c_accnt
char ks_where=@today between [prev_change] and [next_change]
char ks_defaults=c_contract:$CONTRACT_NO_CONTRACT;
;--------------------------------------------------
; состояние счёта
[AccStat]
const char main_class=DB_Kstat
const char read_access=any
const char ks_table=accnts_state
const char ks_keys=c_accnt
char ks_where=@today between [prev_change] and [next_change]
char ks_defaults=state:$ACCNT_STATE_OPEN;


; =============================================================================
; валюта счетов
; =============================================================================
[AccntCurr_Of_Branch]
const char main_class=DB_Kscurs
const char parent_kstat=AccntCurr
const char ks_where=$BRANCH_ACCNT_WHERE


[AccntCurr] default: AccntTpl
const char ks_table=accnts_multi
const char ks_keys=c_accnt,c_curr
char ks_order=c_accnt,c_curr
char history=open:open_day/delete_day
char query_defaults=open_day:@today;delete_day:$DayMax;

const char foreigns=\
#{";"
; для отображения
  RateKind($CURCFG::AbbrsRateKind):rate_kind(type)
; для просмотра остатков
  Turn($CURCFG::Turn):@today(op_day),c_accnt,c_curr
  Turnovers($CURCFG::Turnovers):@today(op_day),c_accnt,c_curr
#}

const char references=\
#{";"
  Turnovers_with_to($CURCFG::Turnovers_with_to):c_accnt,c_curr
#}

const char refs_x1=\
#{";"
  Orders(uk_reports::UK_Report_Orders_For_Accnt):c_accnt,c_curr,'$_EMPTY'(order_state),'$_TRUE'(is_hide_deleted)
  OrdersAll(uk_reports::UK_Report_Orders_For_Accnt):c_accnt,c_curr,'$_EMPTY'(order_state),'$_FALSE'(is_hide_deleted)
#}


char lookups=\
#{
  Accnt($CURCFG::Accnt):c_accnt;
  Curr($CURCFG::Curr):c_curr;
#}

char slaves=\
#{
  AccntCurr_OPL(uk_main::AccntCurr_OPL):c_accnt,c_curr;
#}

char fmt_desc=[Accnt.ncurracc]/[Curr.abbr]
;--------------------------------------------------
; для точного поиска
char synonyms=necurracc_lu==necurracc;
char filter_fields=necurracc_lu: (%?%=%dnecurracc);
;--------------------------------------------------
; используем директивы для вызова kernel'а
char insert=\
#{
  call($CURCFG::$CURSEC:AccntCurrAdd);
  copy(${.:ks_keys});
#}
char AccntCurrAdd=\
#{
  @THIS.InvokeKernel("DB_Kernel::AccntCurrNew",
    CURRENT.get_name(), CURRENT.get_name() );
  @THIS.KeysFromCollection( CURRENT.get_name() );
#}
char delete=call($CURCFG::$CURSEC:AccntCurrDelete);
char AccntCurrDelete=\
#{
  @THIS.InvokeKernel("DB_Kernel::AccntCurrDelete",
    CURRENT.get_name(), CURRENT.get_name() );
#}
char rollback_insert=call($CURCFG::$CURSEC:AccntCurrRollbackInsert);
char AccntCurrRollbackInsert=\
#{
  spc_code=$spcAccntCurr_RollbackInsert;
  @THIS.InvokeKernel("DB_Kernel::AccntCurrSpc",
    CURRENT.get_name(), CURRENT.get_name() );
#}
char rollback_delete=call($CURCFG::$CURSEC:AccntCurrRollbackDelete);
char AccntCurrRollbackDelete=\
#{
  spc_code=$spcAccntCurr_RollbackDelete;
  @THIS.InvokeKernel("DB_Kernel::AccntCurrSpc",
    CURRENT.get_name(), CURRENT.get_name() );
#}
char spc_default=@DefaultSpc(c_accnt,c_curr)
char DefaultSpc=\
#{
  $CURCFG::$CURSEC.InvokeKernel("DB_Kernel::AccntCurrSpc",
    CURRENT.get_name(), CURRENT.get_name() );
#}
char DefaultSpc_vld=BREAK=\
#{
  $CURCFG::$CURSEC.InvokeKernel("DB_Kernel::AccntCurrSpcVld",
    CURRENT.get_name(), CURRENT.get_name() );
#}
; устанавливаем курс валюты по виду счёта
char pipe_pre_insert=\
#{
  CURRENT.SetVarShort( "IO.rate_kind", @@Accnt.Acckind.rate_kind );
#}
;--------------------------------------------------
; special's
const char spc_codes=\
#{
  $spcRollbackInsert: PLACE_ACCNT;
  $spcRollbackDelete: PLACE_ACCNT;
  $spc_get_tunning_info (<@get_tunning_info (c_accnt,c_curr,necurracc,
                                             Accnt.naccnt,Accnt.nsymbf2,Accnt.nactpass,
                                             Accnt.c_branch,Accnt.c_naccnt,Accnt.c_nsymbf2_f5,
                                             Accnt.nsubacc,Accnt.access,Accnt.AccntName.name,Accnt.ncurracc,
                                             AccntCurr_OPL.oaccnt,AccntCurr_OPL.necurracc,AccntCurr_OPL.comment,
                                             AccntCurr_OPL.rest0,AccntCurr_OPL.rest0_rur,
                                             Accnt.ndep,Accnt.nukind,
                                             Turn.rest1)>):#Pget_tunning_info_parms;
#}

;> ------------------------------------------------
;> __get_tunning_info
;    получение аттрибутов объекта и сохранение их во внешней коллекции
;    для использования в Delphi
;> ------------------------------------------------
const char get_tunning_info_parms=\
#{";"
  ext_coll_name:Имя внешней коллекции#Tstring_t
#}
const char get_tunning_info=\
#{
  @ext_coll_name.RenewVarsFromColl(CURRENT.get_name());
#}


;--------------------------------------------------
; редактирование
[AccntCurr_bob]
char title=Добавление/удаление валюты счёта
char scr_name=fdr_accnt_multi
char filter_screen=fdr_accnt_multi
char scr_mode=view
char filter_mode=tselect
char edt_modes=six
char spc_list=/\
#{","
  $spcDelete
  $spcRollbackDelete
  $spcRollbackInsert
#}
long empty->add=1

;==================================================
; счета с ограничением по дню (только на чтение)
;--------------------------------------------------
; счета
[AccntDay]
const char main_class=DB_Kstat
const char read_access=any
const char ks_table=accnts_def
const char ks_keys=c_accnt,#today
char ks_order=c_accnt
char ks_where=$BRANCH_WHERE_OBJ
const char pseudo_keys=\
#{
  today/delete_day:#today between [open_day] and [delete_day];
#}
char foreigns=\
#{";"
  Branch($CURCFG::BranchAll):c_branch
  AccntName($CURCFG::AccntNameDay):c_accnt,#today
  RestRUR($CURCFG::Turnovers):c_accnt,'$CURR_ROUBLE'(c_curr),@today(op_day)
  NPL($CURCFG::NPl_accnt2):c_naccnt
  NS5($CURCFG::Nsymbols2_f5):c_nsymbf2_f5
#}
char references=\
#{
; для fltmap в RfcChoice
  AccntCurr($CURCFG::AccntCurrDay):c_accnt,#today;
#}
char fmt_desc=${Accnt:fmt_desc}
char synonyms=${Accnt:synonyms}
char filter_fields=${Accnt:filter_fields}
;--------------------------------------------------
; наименование счёта
[AccntNameDay]
const char main_class=DB_Kstat
const char read_access=any
const char ks_table=accnts_name
const char ks_keys=c_accnt,#today
char ks_order=c_accnt
const char pseudo_keys=\
#{
  today/next_change:#today between [prev_change] and [next_change];
#}
;--------------------------------------------------
; правильная сортировка
[AccDay]
const char main_class=DB_Kscurs
char parent_kstat=$CURCFG::AccntDay
char ks_order=naccnt,Branch.ndep,nsymbf2,nsubacc
;--------------------------------------------------
; валюта счетов
[AccntCurrDay]
const char main_class=DB_Kstat
const char read_access=any
const char ks_table=accnts_multi
const char ks_keys=c_accnt,c_curr,#today
char ks_order=c_accnt,c_curr
const char pseudo_keys=\
#{
  today/delete_day:#today between [open_day] and [delete_day];
#}
char cursor_type=scroll

char foreigns=\
#{";"
;;  Accnt($CURCFG::AccntDay):c_accnt,#today;
;;  Curr($CURCFG::Curr):c_curr;
;;; для просмотра остатков
  Turn($CURCFG::Turn):@today(op_day),c_accnt,c_curr;
#}
;;char fmt_desc=[Accnt.ncurracc]/[Curr.abbr]
;;; наименование счёта
;;char foreigns=${.:foreigns}\
;;#{
;;  AccntName($CURCFG::AccntNameDay):c_accnt,#today;
;;#}
;;char synonyms=name==AccntName.name;

;==================================================
; счета ОС, контрагентов, сотрудников и прочие обычные
;--------------------------------------------------
[AccntNormal]
const char main_class=DB_Kscurs
char parent_kstat=$CURCFG::Accnt_Of_Branch
char cursor_type=dynamic
char ks_order=naccnt,Branch.ndep,nsubacc
char ks_where=\
#{
  [ntype]=$ACCNT_NTYPE_FILRAS and
  [acckind]=$ACCKIND_NORMAL
#}
char ks_defaults=\
#{";"
  ntype:$ACCNT_NTYPE_FILRAS
  acckind:$ACCKIND_NORMAL
  c_branch:@BranchSelect.c_branch
  nukind:0
  ndep:0
  main:0
#}


;==================================================
; счета ОС
; (ndep настраивается в поле uk_ref_abbrs:cfg_attr)
;--------------------------------------------------
[AccntNormal_OS] default: AccntNormal
char ks_where=\
#{
  [ndep] in (1,2)
#}

;==================================================
; счета запасов
;--------------------------------------------------
[AccntNormal_Stocks]
const char main_class=DB_Kscurs
char parent_kstat=$CURCFG::Accnt_Of_Branch
char cursor_type=dynamic
char ks_order=naccnt,Branch.ndep,nsubacc
char ks_where=\
#{
  [ntype]=$ACCNT_NTYPE_FILRAS and
  [acckind]=$ACCKIND_STOCK
#}
char ks_defaults=\
#{";"
  ntype:$ACCNT_NTYPE_FILRAS
  acckind:$ACCKIND_STOCK
  c_branch:@BranchSelect.c_branch
  nukind:0
  ndep:0
  main:0
#}

;==================================================
; счета депозитов
;--------------------------------------------------
[AccntNormal_Deposits] default: AccntNormal
char ks_where=\
#{
  [naccnt] in ($NACCNTS_DEPOSITS)
#}


;==================================================
; счета работников
; (ndep настраивается в поле uk_ref_abbrs:cfg_attr)
;--------------------------------------------------
[AccntNormal_Employee] default: AccntNormal
char ks_where=\
#{
  [naccnt] in ($NACCNTS_EMPLOYEE)
#}


;==================================================
; обычные счета (контрагенты и прочие внутренние)
;--------------------------------------------------
[AccntNormal_Usual] default: AccntNormal
char ks_where=\
#{
  [ndep] in (0) and [c_nsymbf2_f5]=0 and [naccnt] not in ($NACCNTS_EMPLOYEE, $NACCNTS_DEPOSITS)
#}


;--------------------------------------------------
; редактирование
[AccntNormalEdit] default: EditorTpl
char parent_kstat=$CURCFG::AccntNormal
char title=Обычные счета
char scr_name=fdr_accnt_normal_frm
char filter_screen=fdr_accnt_flt
char scr_mode=select
char edt_modes=suix
char spc_list=/\
#{","
  $spcDelete
  $spcRollbackInsert
  $spcRollbackDelete
#}
; вычисляем субсчет по выходу из проекта
char c_branch_exit_add=*$CURCFG::acts:calc_normal_nsubacc

;--------------------------------------------------
[acts]
; вычислить субсчет по балансовому и проекту
char calc_normal_nsubacc=\
#{
  getvars{vars='nsubacc,naccnt,c_branch'};
  calc{expr='
    ( @@nsubacc !=0? 1:
      @@naccnt  ==0? 1:
      @@c_branch==0? 1:
        0 )?
;     ничего устанавливать не надо
      return(CURRENT.NewSubcol("IO","<null>")): 0;
    $LONG(IO.nsubacc)
    SQL select nvl(max(nsubacc),0)+1 into ?IO.nsubacc
        from accnts_def
        where naccnt=?naccnt and
          c_branch=?c_branch and
          delete_day>=?open_day'
  };
  setvars{subcol=IO};
#}

;==================================================
; счета доходов/расходов
;--------------------------------------------------
[AccntProfexp]
const char main_class=DB_Kscurs
char parent_kstat=$CURCFG::Accnt_Of_Branch
char cursor_type=dynamic
char ks_order=naccnt,Branch.ndep,nsymbf2,nsubacc
char ks_where=\
#{
  [ntype]=$ACCNT_NTYPE_PROFEXP and
  [acckind]=$ACCKIND_PROFEXP
#}
char ks_defaults=\
#{";"
  ntype:$ACCNT_NTYPE_PROFEXP
  acckind:$ACCKIND_PROFEXP
  c_nsymbf2_f5:0
  nsymbf2:0
  c_branch:@BranchSelect.c_branch
  ntax:$ACCNT_NTAX_NO
#}
;--------------------------------------------------
; редактирование
[AccntProfexpEdit] default: EditorTpl
char parent_kstat=$CURCFG::AccntProfexp
char title=Счета доходов/расходов
char scr_name=fdr_accnt_profexp_frm
char filter_screen=fdr_accnt_flt
char scr_mode=select
char edt_modes=suix
char spc_list=/\
#{","
  $spcDelete
  $spcRollbackInsert
  $spcRollbackDelete
#}
; вычисляем субсчет по выходу из символа
char nsymbf2_exit_add=*$CURCFG::acts:calc_profexp_nsubacc
;--------------------------------------------------
[acts]
; вычислить субсчет по балансовому, проекту и символу
char calc_profexp_nsubacc=\
#{
  getvars{vars='nsubacc,naccnt,c_branch,c_nsymbf2_f5'};
  calc{expr='
    ( @@nsubacc !=0? 1:
      @@naccnt  ==0? 1:
      @@c_branch==0? 1:
      @@c_nsymbf2_f5 ==0? 1:
        0 )?
;     ничего устанавливать не надо
      return(CURRENT.NewSubcol("IO","<null>")): 0;
    $LONG(IO.nsubacc)
    SQL select nvl(max(nsubacc),0)+1 into ?IO.nsubacc
        from accnts_def
        where
          naccnt       = ?naccnt and
          c_branch     = ?c_branch and
          c_nsymbf2_f5 = ?c_nsymbf2_f5 and
          delete_day  >= ?open_day'
  };
  setvars{subcol=IO};
#}

;==================================================
; счета переоценки
;--------------------------------------------------
[AccntReval] default: AccntProfexp
const char insert_access=PLACE_ACCNT_REVAL
const char update_access=PLACE_ACCNT_REVAL
const char delete_access=PLACE_ACCNT_REVAL
char ks_where=\
#{
  [ntype]=$ACCNT_NTYPE_PROFEXP and
  [acckind]=$ACCKIND_REVAL
#}
char ks_defaults=\
#{";"
  ntype:$ACCNT_NTYPE_PROFEXP
  acckind:$ACCKIND_REVAL
  nsymbf2:0
  c_branch:@BranchSelect.c_branch
  ntax:$ACCNT_NTAX_NO
#}
;--------------------------------------------------
; редактирование
[AccntRevalEdit] default: AccntProfexpEdit
char parent_kstat=$CURCFG::AccntReval
char title=Счета переоценки

;==================================================
; счета ОВП
;--------------------------------------------------
[AccntConv] default: AccntNormal
; запрещаем редактировать
const char insert_access=PLACE_NORIGHT
const char update_access=PLACE_NORIGHT
const char delete_access=PLACE_NORIGHT
char ks_where=\
#{
  [ntype]=$ACCNT_NTYPE_FILRAS and
  [acckind]=$ACCKIND_CONVERSION
#}
char ks_defaults=\
#{
  ntype:$ACCNT_NTYPE_FILRAS;
  acckind:$ACCKIND_CONVERSION;
  c_branch:0;
  nukind:0;
  ndep:0;
#}
;--------------------------------------------------
; редактирование
[AccntConvEdit] default: AccntNormalEdit
char parent_kstat=$CURCFG::AccntConv
char title=Счета ОВП

;==================================================
; переоценка по валютам
;--------------------------------------------------
[CurrReval]
const char main_class=DB_Kstat
const char read_access=any
const char insert_access=PLACE_ACCNT_REVAL
const char update_access=PLACE_ACCNT_REVAL
const char delete_access=PLACE_ACCNT_REVAL
const char ks_table=curr_reval
; c_curr      - код валюты
; c_reval_d   - счета переоценки
; c_reval_c
; prev_change - история
; next_change
char ks_keys=c_curr
char ks_order=c_curr
char history=change:prev_change/next_change
char query_defaults=prev_change:@today;next_change:$DayMax;
; используем lookups для начальной загрузки
char lookups=\
#{
  Curr($CURCFG::CurrNR):c_curr;
  RevalD($CURCFG::AccntReval):c_reval_d(c_accnt);
  RevalC($CURCFG::AccntReval):c_reval_c(c_accnt);
#}
;------------------------------------------
; validate
char kernel_history=\
#{
; проверяем счета, дубликат валюты
  New           : VldNew(rb_flag=0);
  RollbackDelete: VldNew(rb_flag=1);
; проверяем счета, неизменность валюты
  Change        : VldChg(rb_flag=0);
  RollbackChange: VldChg(rb_flag=1);
#}
char VldNew=\
#{
; проверяем указание валюты
  @@c_curr!=0? 0:
    RaiseError( ${errkern1:::eKernRevalNoCurr} );
; период для проверки дубликата
  local("day1,day2");
  day1=@@rb_flag? @@STORE.next_change+1: @@prev_change;
  day2=@@next_change;
; проверяем дубликат валюты
  $DATE(eday)
  SQL select min(prev_change)
      into ?eday
      from curr_reval
      where c_curr=?c_curr and
        prev_change<='@day2' and next_change>='@day1';
  isnull(@@eday)? 0:
    RaiseError( ${errkern1:::eKernRevalCurrExist},
      call("4glgpf::KeyDesc:Curr",@@c_curr), @@eday );
; проверяем счета
  call("$CURCFG::cmds:curr_reval_accnt_cex",
    @@rb_flag? @@STORE.prev_change: @@prev_change,
    @@next_change );
#}
char VldChg=\
#{
; проверяем неизменность валюты
  @@c_curr==@@STORE.c_curr? 0:
    RaiseError( ${errkern1:::eKernRevalCurrNoChange} );
; проверяем счета
  call("$CURCFG::cmds:curr_reval_accnt_cex",
    @@rb_flag? @@STORE.prev_change: @@prev_change,
    @@next_change );
#}
;--------------------------------------------------
[cmds]
; проверить существование счетов переоценки
char curr_reval_accnt_cex_parms=day1,day2
char curr_reval_accnt_cex=\
#{
; проверяем счет по дебету
  KernCheckAccntCurrRange( @@day1, @@day2, @@c_reval_d, $CURR_REVAL,
    "" );
; проверяем счет по кредиту
  KernCheckAccntCurrRange( @@day1, @@day2, @@c_reval_c, $CURR_REVAL,
    "" );
; TODO проверять тип счета А/П
#}
;--------------------------------------------------
; редактирование
[CurrRevalEdit]
const char main_class=DB_Form
char parent_kstat=$CURCFG::CurrReval
char title=Счета переоценки для каждой валюты
char scr_name=curr_reval_frm
char filter_screen=curr_reval_tbl
char scr_mode=select
char edt_modes=siux
char spc_list=/\
#{","
  $spcDelete
  $spcRollbackDelete
  $spcRollbackUpdate
  $spcRollbackInsert
#}
; проверка обязательности ввода select-полей
char c_curr_exit_add=\
#{
  getvars{vars='c_curr'};
  switch{var=c_curr,empty=
    error{code=${errkern1:::eKernRevalNoCurr}}
  };
#}

;==================================================
; остаток на счете
;--------------------------------------------------
[AccntMoney]
const char main_class=DB_Cfgcur
char read_access=any
char update_access=PLACE_ACCNT
char sections=$CURCFG::$CURSEC
char fields=c_curr,c_accnt
long c_curr=0
long c_accnt=0
char foreigns=\
#{
  Accnt($CURCFG::Accnt):c_accnt;
  AccntCurr($CURCFG::AccntCurr):c_accnt,c_curr;
  Curr($CURCFG::Curr):c_curr;
#}
;--------------------------------------------------
; редактирование
[AccntMoneyForm]
const char main_class=DB_Form
char parent_kstat=$CURCFG::AccntMoney
char title=Остаток по счету
char scr_name=accnt_money_som
char scr_mode=edit
char edt_modes=u1
char add_acts=${4glgpf::std_add_acts:cfgcur}()

;==================================================
; массовые операции над счетами
;--------------------------------------------------
; откатка счетов
[AccntRollback]
const char main_class=DB_Form
char parent_kstat=$CURCFG::Accnt
char title=Откатка счетов
char scr_name=fdr_accnt_mass_tbl
char scr_mode=tchoice
char edt_modes=sx
char spc_list=/\
#{","
  $spcDelete
  $spcRollbackInsert
  $spcRollbackDelete
#}
;--------------------------------------------------
; откатка валюты у счетов
[AccntCurrRollback] default: AccntRollback
char parent_kstat=$CURCFG::AccntCurr
char title=Откатка валюты у счетов
char scr_name=fdr_accnt_curr_mass_tbl
char spc_list=/\
#{","
  $spcDelete
  $spcRollbackInsert
  $spcRollbackDelete
#}

;> ============================================================================
;  документы
;> docs
;> ============================================================================
[KsConf]
const char main_class=DB_Kstat
const char read_access=any
const char insert_access=PLACE_DOCS
const char update_access=PLACE_DOCS
const char delete_access=PLACE_DOCS
const char ks_table=docs
const char ks_keys=c_doc
char ks_order=c_doc
char fmt_desc=Документ [Type.abbr] N [number]
char ks_defaults=\
#{
  op_day:@today;
  doc_day:@today;
  number:0;
  c_folder:$DOC_FOLDER_NO;
  state:$DOC_STATE_ENTERED;
; по умолчанию не требуем двойного ввода
  isum:;
#}
;--------------------------------------------------
char foreigns=\
#{
  Type($CURCFG::AbbrsDocType):type;
  State($CURCFG::AbbrsDocState):state(type);
; валюта валютных документов
  CurrNR($CURCFG::CurrNR):c_curr;
; для рублевых и валютных ордеров
  DP0($CURCFG::DocsPsums):c_doc,'0'(psum_id);
  CS0($CURCFG::DocsCpsums):c_doc,'0'(psum_id);
; для универсального просмотра
  MP0($CURCFG::MainProvs):c_doc,'0'(psum_id);
; счета в рублевых мемориальных ордерах
  AccntD($CURCFG::AccDay):DP0.c_accnt_d(c_accnt),op_day(#today);
  AccntC($CURCFG::AccDay):DP0.c_accnt_c(c_accnt),op_day(#today);
; корреспондирующие счета валютных документов
  AccntDC($CURCFG::AccDay):CS0.c_accnt_d(c_accnt),op_day(#today);
  AccntCC($CURCFG::AccDay):CS0.c_accnt_c(c_accnt),op_day(#today);
; для просмотра остатков
  TurnD($CURCFG::Turn):op_day,DP0.c_accnt_d(c_accnt),c_curr;
  TurnC($CURCFG::Turn):op_day,DP0.c_accnt_c(c_accnt),c_curr;
  TurnDC($CURCFG::Turn):op_day,CS0.c_accnt_d(c_accnt),c_curr;
  TurnCC($CURCFG::Turn):op_day,CS0.c_accnt_c(c_accnt),c_curr;
; ... в переоценочных ордерах
  TurnDR($CURCFG::Turn):op_day,CS0.c_accnt_d(c_accnt),c_curr_reval_d(c_curr);
  TurnCR($CURCFG::Turn):op_day,CS0.c_accnt_c(c_accnt),c_curr_reval_c(c_curr);
; требуется только для структуры DB_Kernel::doc_payint
  Payext($CURCFG::Payext):c_doc;
; основной документ цепочки
  ChainUp($CURCFG::KsConf):c_parent(c_doc);
#}
; зависимые
char references=ChainDown($CURCFG::KsConf):c_doc(c_parent);
;--------------------------------------------------
char synonyms=\
#{
; для акции state_init
  state_mode[LONG]=state($DOC_STATE_ENTERED:'1','0');
; для просмотра остатков в переоценочных ордерах
  c_curr_reval_d=AccntDC.acckind($ACCKIND_REVAL:'$CURR_REVAL',c_curr);
  c_curr_reval_c=AccntCC.acckind($ACCKIND_REVAL:'$CURR_REVAL',c_curr);
#}
;--------------------------------------------------
const char kernel_prefix=Doc
const char exclude_fields=*
; составные атрибуты метода DB_Kernel::DocChange
const char kernel_vars=\
#{","
  DP0.
  CS0.
; требуется только для структуры DB_Kernel::doc_payint
  Payext.
#}
; special через DB_Kernel
char spc_default=@DefaultSpc(prm=0)
char DefaultSpc_vld=\
#{
  BREAK=$CURCFG::$CURSEC.InvokeKernel( "DB_Kernel::DocSpcVld",
    CURRENT.get_name(), CURRENT.get_name() );
#}
char DefaultSpc=\
#{
  $CURCFG::$CURSEC.InvokeKernel( "DB_Kernel::DocSpc",
    CURRENT.get_name(), CURRENT.get_name() );
#}
;--------------------------------------------------
const char spc_codes=\
#{
; указаны только простые PLACE_..., дополнительные проверки
; осуществляются в DB_Kernel::DocSpc (dbdoc.cc)
  $spcDocToEnter: PLACE_DOCS;
  $spcDocPerform: PLACE_DOCS;
; стандартные (копия из dboconf.cfg)
  $spcDocDeffer*;
  $spcDocMove  (@DatePrmSpc(new_date=0)):*;
  $spcDocShift (@DatePrmSpc(new_date=0)):*;
  $spcDocDelete:*;
  $spcPrint-;
#}
;--------------------------------------------------
char DatePrmSpc_vld=\
#{
  BREAK=$CURCFG::$CURSEC.InvokeKernel( "DB_Kernel::DocSpcVld",
    CURRENT.get_name(), CURRENT.get_name() );
#}
char DatePrmSpc=\
#{
  prm=long(@@new_date);
  $CURCFG::$CURSEC.InvokeKernel( "DB_Kernel::DocSpc",
    CURRENT.get_name(), CURRENT.get_name() );
#}
;==================================================
; доп.атрибуты рублевых документов
[DocsPsums]
const char main_class=DB_Kstat
const char read_access=any
const char ks_table=docs_psums
const char ks_keys=c_doc,psum_id
char cursor_type=scroll
;--------------------------------------------------
; доп.атрибуты валютных документов
[DocsCpsums]
const char main_class=DB_Kstat
const char read_access=any
char ks_table=docs_cpsums
char ks_keys=c_doc,psum_id
char cursor_type=scroll
char ks_defaults=\
#{";"
  rate_day:@today
  rate:
  rsum:
#}
;--------------------------------------------------
; проводки
[MainProvs]
const char main_class=DB_Kstat
const char read_access=any
char ks_table=provs
char ks_where=[type]=$PROV_TYPE_BASE
char ks_keys=c_doc,psum_id
char cursor_type=scroll
char foreigns=\
#{
  AccntD($CURCFG::AccntDay):c_accnt_debit(c_accnt),op_day(#today);
  AccntC($CURCFG::AccntDay):c_accnt_credit(c_accnt),op_day(#today);
#}
;--------------------------------------------------
; требуется только для структуры DB_Kernel::doc_payint
[Payext]
const char main_class=DB_Kstat
const char read_access=any
const char ks_table=docs_payext
const char ks_keys=c_doc
char cursor_type=scroll

;==================================================
; документы по типам
;--------------------------------------------------
; шаблон для kscurs'а для редактирования одного документа
[DocType_tpl]
const char main_class=DB_Kscurs
char parent_kstat=$CURCFG::KsConf
char cursor_type=dynamic
char ks_where=\
#{
; для сообщения о необходимости выбора проекта
  @BranchSelect.c_branch!=0 and
  [op_day]=@today
#}
char ks_order=c_doc
char ks_defaults=
;--------------------------------------------------
; универсальный шаблон для редактирования
[NEdit_tpl]
const char main_class=DB_Form
char scr_mode=select
char flt_modes=s
char filter_screen=pay_sel
char filter_mode=tselect
char edt_modes=siud
char flt_modes=s
char extra_view=fdr_doc_status
; обработка по F8 и после вставки
char add_acts=\
#{
  ${4glgpf::std_add_acts:doc_like}
  ${4glgpf::std_add_acts:doc_like_spc}
  ${4glgpf::std_add_acts:state_spc}
; TODO заменить visual на aux или keyform
; *(edit|view,subobj,"Пpоводки#hПpоводки#w:1#P2"): CTRL_P
; { visual=DocProvsEdt };
#}
; без промежуточного состояния
char _spc_codes=\
#{","
  $spcDocToEnter
  $spcDocPerform
#}
long _msg_ask_delete=${errdoc:::eDocAskDelete}
; установка режима в зависимости от состояния
char enterline_edit=*4glgpf::std_add_acts:state_init
char enterline_view=*4glgpf::std_add_acts:state_init
;==================================================
; рублевый мемориальный ордер
[MemInt] DocType_tpl
char ks_where=${.:ks_where} and [type]=$DOC_TYPE_MEMINT
char ks_defaults=\
#{
  c_curr:$CURR_ROUBLE;
  type:$DOC_TYPE_MEMINT;
#}
;--------------------------------------------------
; редактирование
[MemIntEdit] default: NEdit_tpl
char parent_kstat=$CURCFG::MemInt
char title=Мемориальный рублевый ордер
char scr_name=fdr_memint_form
char pipes_pre=update/edit:'IO.isum=@@DP0.isum';
;==================================================
; валютный кредитовый
[CMemOut] DocType_tpl
char ks_where=${.:ks_where} and [type]=$DOC_TYPE_CMEM_OUT
char ks_defaults=\
#{
  c_curr:0;
  type:$DOC_TYPE_CMEM_OUT;
#}
;--------------------------------------------------
; редактирование
[CMemOutEdit] default: NEdit_tpl
char parent_kstat=$CURCFG::CMemOut
char title=Мемориальный валютный ордер (кредит)
char scr_name=fdr_cmem_form
char pipes_pre=update/edit:'IO.isum=@@CS0.isum';
;==================================================
; валютный дебетовый
[CMemIn] DocType_tpl
char ks_where=${.:ks_where} and [type]=$DOC_TYPE_CMEM_IN
char ks_defaults=\
#{
  c_curr:0;
  type:$DOC_TYPE_CMEM_IN;
#}
;--------------------------------------------------
; редактирование
[CMemInEdit] default: CMemOutEdit
char parent_kstat=$CURCFG::CMemIn
char title=Мемориальный валютный ордер (дебет)
;==================================================
; переоценочные ордера
[CMemOutRevalEdit] default: CMemOutEdit
char title=Мемориальный валютный ордер с переоценкой (кредит)
char scr_name=fdr_cmem_out_reval_form
;--------------------------------------------------
[CMemInRevalEdit] default: CMemInEdit
char title=Мемориальный валютный ордер с переоценкой (дебет)
char scr_name=fdr_cmem_in_reval_form
;==================================================
; пpосмотp одного документа любого типа
[ViewDocForm]
const char main_class=DB_Form
char parent_kstat=$CURCFG::KsConf
char title=Просмотр документа
char scr_name=doc_any_form
char union_desc=type(\
#{";"
  $DOC_TYPE_MEMINT:fdr_memint_form
  $DOC_TYPE_CMEM_IN:fdr_cmem_form
  $DOC_TYPE_CMEM_OUT:fdr_cmem_form
#})
char scr_mode=view
char edt_modes=u1
char extra_view=fdr_doc_status

;==================================================
; списки документов
;--------------------------------------------------
; шаблон для kscurs'а для изменения состояния документов
template [Confirm]
const char main_class=DB_Kscurs
char parent_kstat=dbores::TodayConf
char ks_where=
char ks_order=
char cursor_type=scroll
;--------------------------------------------------
; обычные документы текущего дня
[TodayConf] Confirm
char parent_kstat=$CURCFG::KsConf
char ks_where=\
#{
; для сообщения о необходимости выбора проекта
  @BranchSelect.c_branch!=0 and
  [op_day]=@today and
  [type] in($DOC_TYPE_MEMINT,$DOC_TYPE_CMEM_IN,$DOC_TYPE_CMEM_OUT)
#}
char ks_order=type,isum,c_doc
;--------------------------------------------------
[acts]
; на основе 4glgpf::std_add_acts:conf
template char std_conf=\
#{
  *(any,subobj,"Смотpеть документ#hДокумент#w:0#P2"):CTRL_V
  { ${subobj%+subobj=}$subobj${subobj%+,}
    keyform=$CURCFG::ViewDocForm
  };
  *(any,subobj,"Посмотреть зависимые#hЗависимые#w:3#P2"):CTRL_S
  { subobj=$subobj${subobj%+.}ChainDown,
    title='Зависимые документы',
    keyform=$CURCFG::Conf_bob
  };
  *(any,subobj,"Посмотреть основной#hОсновной#w:4#P2"):CTRL_B
  { subobj=$subobj${subobj%+.}ChainUp,
    title='Основной документ',
    keyform=$CURCFG::Conf_bob
  };
#}
;--------------------------------------------------
; шаблон для form'ы для изменения состояния документов
template [ConfirmForm]
const char main_class=DB_Form
char parent_kstat=
char title=Таблица изменения состояния документов
char scr_name=fdr_conf_tbl
char scr_mode=tchoice
char ks_selected=${CURSEC}_marks
char filter_screen=fdr_conf_tbl
char filter_mode=tchoice
char edt_modes=sx
char flt_modes=sx
char spc_list=
char add_acts=${acts:std_conf}()
char flt_add_acts=${acts:std_conf}()
;--------------------------------------------------
; пpосмотp документов списком
[Conf_bob] default: ConfirmForm
char parent_kstat=$CURCFG::KsConf
char title=Просмотр документов
char edt_modes=s
;==================================================
; введённые документы
[PerfDocs] Confirm
char ks_where=[state]=$DOC_STATE_ENTERED
;--------------------------------------------------
[PerfDocsForm] default: ConfirmForm
const char parent_kstat=$CURCFG::PerfDocs
char title=Введённые документы
char spc_list=/$spcDocPerform
;==================================================
; проведённые документы
[PassedDocs] Confirm
char ks_where=[state]=$DOC_STATE_PERFORMED
;--------------------------------------------------
[PassedDocsForm] default: ConfirmForm
const char parent_kstat=$CURCFG::PassedDocs
char title=Прошедшие документы
char spc_list=/$spcDocToEnter
;==================================================
; акции изменения параметров документа без откатки его
[acts]
template char doc_change_main=\
#{
  perform{
    subcol=IO,
    vars='c_doc,$1${extra_flds%+,}$extra_flds',
    opn=read
  };
  calc{expr='
    MDE_ChangeData_$1.ToFirst();
    CURRENT.SubcolByName("IO","newc");
    MDE_ChangeData_$1.DoUpdateForColl(@@newc);
  '};
  show
  { name=MDE_ChangeData_$1,
    keyform=MDE_ChangeEdit_$1,
    mode=edit
  };
  doopn{opn=read};
#}
char doc_change_comment=\
#{
  ${.:doc_change_main}(comment,
    doc_info=назначение платежа этого документа)
#}
; 1ый параметр - название поля,
; в секции $CURCFG::cmds должна быть определена команда mde_change_$1,
; также должно быть дано описание сущности в винительном падеже под
; именем mde_desc_vp_$1
template char mde_change_acts=\
#{
  *(edit,dispatch): SED_INIT
  { pipe=
      setmode{mode=edit};
      doopn{opn=first};
      calc{expr=new_$1=@@$1};
      setvars{vars='new_$1'};
      to_first_field
  };
  *(edit,dispatch,"Выполнить#P-"): LFENTER
  { pipe=
      get_chgflag;
      calc{scrvars=y,expr=
        ack="Изменять "+ConfigGet("$CURCFG::cmds:mde_desc_vp_$1")+
          " с '"+string(@@$1)+"' на '"+string(@@new_$1)+"'?";
      };
      user_choice{msg=%ack,alts=',Да,Нет',ret=ch};
      switch{var=ch,0=break,2=break};
      calc{scrvars=y,expr=*$CURCFG::cmds:mde_change_$1};
      exit;
  };
  *(edit,dispatch,"Заново#hЗаново#w0#P1"): PGDN
  { pipe=
      calc{expr=new_$1=@@$1};
      setvars{vars='new_$1'};
      clear_chgflag;
      to_first_field
  };
  *(edit,exit,"Выход#hВыход#w9#P1"): ESC;
#}
;--------------------------------------------------
template [MDE_ChangeData]
const char main_class=DB_Cfgcur
const char update_access=any
const char sections=$CURCFG::$CURSEC
char fields=c_doc,${CURSEC%<MDE_ChangeData_},new_${CURSEC%<MDE_ChangeData_}
long c_doc=0
;--------------------------------------------------
template [MDE_ChangeEdit]
const char main_class=DB_Form
char parent_kstat=MDE_ChangeData_${CURSEC%<MDE_ChangeEdit_}
char scr_name=$CURCFG:screens.$CURSEC
char scr_mode=edit
char edt_modes=u1!p
char title=
char add_acts=${acts:mde_change_acts}(${CURSEC%<MDE_ChangeEdit_})
;==================================================
[MDE_ChangeData_comment] default: MDE_ChangeData
char comment=
char new_comment=
;--------------------------------------------------
[MDE_ChangeEdit_comment] MDE_ChangeEdit
char title=Изменение назначения платежа
;--------------------------------------------------
[screens]
char MDE_ChangeEdit_comment=\
%@fd1w60[@[250\,#]],new_comment:ae,xstring_funcs,Исправьте строку%
;--------------------------------------------------
[cmds]
char mde_change_comment=\
#{
  SQL update docs set comment=?new_comment where c_doc=?c_doc;
  TodayConf.DiscardCache(0);
#}
char mde_desc_vp_comment=назначение платежа
;==================================================
; документы, введённые пользователем
[MyDocsEnter] Confirm
char ks_where=[c_enter]=@CurrUser.c_user
;--------------------------------------------------
[MyDocsEnterForm] default: ConfirmForm
const char parent_kstat=$CURCFG::MyDocsEnter
char title=Все документы, введённые вами
char scr_name=fdr_conf_state_tbl
char filter_screen=fdr_conf_state_tbl
char edt_modes=s
char flt_modes=s
char add_acts=${.:add_acts}\
#{
  *(any,select,"Нестандартные операции#hНестандарт#w3#P2"): ALT_F4
  { alts=
      Назначение платежа:
        dispatch{pipe=*$CURCFG::acts:doc_change_comment}
  };
#}
char flt_add_acts=${.:add_acts}
;==================================================
; документы, проведённые пользователем
[MyDocsPerf] Confirm
char ks_where=[c_ack]=@CurrUser.c_user
;--------------------------------------------------
[MyDocsPerfForm] default: ConfirmForm
const char parent_kstat=$CURCFG::MyDocsPerf
char title=Все документы, проведённые вами
char scr_name=fdr_conf_state_tbl
char filter_screen=fdr_conf_state_tbl
char edt_modes=s
char flt_modes=s

;==================================================
; для закpытия дня
;--------------------------------------------------
[CD_all_e_docs] default: Confirm
char ks_where=\
#{
; без сообщения о необходимости выбора проекта
;;@BranchSelect.c_branch!=0 and
  [op_day]=@today and
  [type] in($DOC_TYPE_MEMINT,$DOC_TYPE_CMEM_IN,$DOC_TYPE_CMEM_OUT) and
  [state]=$DOC_STATE_ENTERED
#}
;--------------------------------------------------
[CD_all_e_docsForm] ConfirmForm
char parent_kstat=dbores::CD_all_e_docs
char title=Обработка документов в состоянии ВВЕДЕН
char spc_list=/$spcDocDelete

;==================================================
; Аpхив документов
;--------------------------------------------------
; документы архива
[ConfArch] Confirm
char parent_kstat=$CURCFG::KsConf
char ks_where=\
#{
; для сообщения о необходимости выбора проекта
  @BranchSelect.c_branch!=0 and
  [type] in($DOC_TYPE_MEMINT,$DOC_TYPE_CMEM_IN,$DOC_TYPE_CMEM_OUT)
#}
char ks_order=-op_day,type,isum,c_doc
;--------------------------------------------------
; subobj через который просматриваем документы в архиве
[ConfArchForm] default: ConfirmForm
const char parent_kstat=$CURCFG::ConfArch
char title=Аpхив документов
char scr_name=fdr_conf_opday_tbl
char filter_screen=fdr_conf_opday_tbl
char edt_modes=s
char flt_modes=s
;--------------------------------------------------
; шаблоны объектов
[DocsArchByF]
const char main_class=DB_Ksrpt
char attrs=c_doc int
char ks_keys=c_doc
char foreigns=Conf($CURCFG::ConfArch):c_doc;
char base_attrs=Date0,Date1
char pipe_subobj=\
#{
  SQL create unique index @{_rpt_table} on @_rpt_table (c_doc);
  SQL update statistics high for table @_rpt_table (c_doc);
#}
;--------------------------------------------------
template [DocsArchBy_tpl]
const char main_class=DB_Cfgcur
char read_access=any
char update_access=PLACE_DOCS_ARCH
char sections=$CURCFG::$CURSEC
char fields=Date0,Date1
date Date0=31.12.2004
date Date1=31.12.2004
char ks_defaults=Date0:@today;Date1:@today
; для сообщения о необходимости выбора проекта
char pipe_init=StdEnv.GetVarLong( "BranchSelect.c_branch", "" );
;==================================================
; поиск по счетам
[DocsArchByAccntsF] DocsArchByF
char base_attrs=${.:base_attrs},accnts
char pipe_subobj=\
#{
  SQL insert into @_rpt_table (c_doc)
      select distinct p.c_doc
      from provs p
      where p.op_day between ?Date0 and ?Date1 and
        ( p.c_accnt_debit in(@accnts) or
          p.c_accnt_credit in(@accnts) );
#}\
${.:pipe_subobj}
;--------------------------------------------------
[DocsArchByAccnts] default: DocsArchBy_tpl
char fields=${.:fields},\
#{
  c_accnt_0,c_accnt_1,c_accnt_2,c_accnt_3,c_accnt_4,accnts
#}
long c_accnt_0=0
long c_accnt_1=0
long c_accnt_2=0
long c_accnt_3=0
long c_accnt_4=0
char accnts=
char foreigns=\
#{
  Accnt0(dbores::Accnt):c_accnt_0(c_accnt);
  Accnt1(dbores::Accnt):c_accnt_1(c_accnt);
  Accnt2(dbores::Accnt):c_accnt_2(c_accnt);
  Accnt3(dbores::Accnt):c_accnt_3(c_accnt);
  Accnt4(dbores::Accnt):c_accnt_4(c_accnt);
#}
char references=Docs($CURCFG::DocsArchByAccntsF):Date0,Date1,accnts;
char pipe_update=\
#{
  accnts="@c_accnt_0,@c_accnt_1,@c_accnt_2,@c_accnt_3,@c_accnt_4";
  pipe_update_RES=@THIS.DoMainOpn( cvtdii("DB_Astat::sql_opn:sqlUpdate"),
    CURRENT.get_name() );
#}
;--------------------------------------------------
[DocsArchByAccntsForm]
const char main_class=DB_Form
char parent_kstat=$CURCFG::DocsArchByAccnts
char title=Поиск по счетам
char scr_name=report:som_ask.accs_range
char scr_mode=edit
char edt_modes=u1
char add_acts=${4glgpf::std_add_acts:cfgcur}(\
#{""
  control{
    pipe\=*$CURCFG::acts:subobj_docs_conf\,
    finally\=*$CURCFG::acts:subobj_docs_conf_clean
  };
#})
;--------------------------------------------------
; акции для просмотра архива документов
[acts]
; подготовка подобъекта и показ его
char subobj_docs_conf=\
#{
  calc{expr='
;   прежде всего заводим пустые имена объектов
    $CHAR(ksr,ksf)
;   references получаем стандартным образом
    ksr=@OBJ.GetOpnRfcObj( "Docs",
      cvtdii("DB_Astat::io_opn:sqlSelect"), "<null>" );
;   дальнейшие подобъекты получаем, используя составной объект в
;   parent_kstat
    ksf=Auth.obj_by_desc( "[DB_Kscurs](parent_kstat=@ksr.Conf)",
      "", "dummy" );
  '};
  show{name=%ksf,keyform=$CURCFG::ConfArchForm};
#}
; удаление используемых объектов (в обратном порядке)
char subobj_docs_conf_clean=\
#{
  calc{expr='(@@ksf)!=""? Auth.delete_obj_by_name(@@ksf): 0;
             (@@ksr)!=""? Auth.delete_obj_by_name(@@ksr): 0'};
#}
;==================================================
; поиск по сумме
[DocsArchBySum] default: DocsArchBy_tpl
char fields=${.:fields},isum,c_curr,sum_cond
money isum=0
long c_curr=0
char sum_cond=
char foreigns=Curr($CURCFG::CurrNR):c_curr;
char references=\
#{
  Docs($CURCFG::DocsArchBySumF):Date0,Date1,c_curr,sum_cond;
#}
char pipe_update=\
#{
  @@isum>0? 0:
    RaiseError( ${errkern1:::eKernIllDocSum} );
  sum_cond="=@isum";
  pipe_update_RES=@THIS.DoMainOpn( cvtdii("DB_Astat::sql_opn:sqlUpdate"),
    CURRENT.get_name() );
#}
;--------------------------------------------------
[DocsArchBySumF] DocsArchByF
char base_attrs=${.:base_attrs},c_curr,sum_cond
char pipe_subobj=\
#{
  $CHAR(curr_cond)
  curr_cond=@@c_curr? "and d.c_curr=@c_curr": "";
  SQL insert into @_rpt_table (c_doc)
      select d.c_doc
      from docs d
      where d.op_day between ?Date0 and ?Date1 and
        d.isum @sum_cond @curr_cond;
#}\
${.:pipe_subobj}
;--------------------------------------------------
[DocsArchBySumForm] DocsArchByAccntsForm
char parent_kstat=$CURCFG::DocsArchBySum
char title=Поиск по сумме
char scr_name=sum_range_input_som
;==================================================
; поиск по интервалу сумм
[DocsArchBySums] default: DocsArchBy_tpl
char fields=${.:fields},isum0,isum1,c_curr,sum_cond
money isum0=0
money isum1=0
long c_curr=0
char sum_cond=
char foreigns=Curr:c_curr;
char references=Docs($CURCFG::DocsArchBySumF):Date0,Date1,c_curr,sum_cond
char pipe_update=\
#{
  sum_cond=" between @isum0 and @isum1";
  pipe_update_RES=@THIS.DoMainOpn( cvtdii("DB_Astat::sql_opn:sqlUpdate"),
    CURRENT.get_name() );
#}
;--------------------------------------------------
[DocsArchBySumsForm] DocsArchByAccntsForm
char parent_kstat=$CURCFG::DocsArchBySums
char title=Поиск по интервалу сумм
char scr_name=sums_range_input_som

;==================================================
; Нумерация документов
;--------------------------------------------------
[DocNum]
const char main_class=DB_Kstat
const char read_access=any
const char insert_access=PLACE_DOCNUM
const char delete_access=PLACE_DOCNUM
const char ks_table=list_docnum
; day1  - интервал нумерации
; day2
; <subj_list> - классы типов документов
const char ks_keys=day2
char ks_order=day1
char ks_defaults=\
#{
  day1:@today;
  day2:$DayMax;
#}
;--------------------------------------------------
; список классов типов документов
char subj_list=\
#{","
  mem
  cmem
#}
char ks_defaults=${.:ks_defaults}${.:subj_list%//,/:1;}:1;
;--------------------------------------------------
; validate
char pipe_insert_vld=\
#{
; проверяем, что добавляем последний интервал
  call("$CURCFG::cmds:doc_num_get_last" );
  isnull(@@last_day1)?
    0:
  @@day1<=@@last_day1?
    RaiseError( ${errkern1:::eKernDocNumIntervalNotLast}, @@last_day1 ):
  @@last_day2==$DayMax?
    0:
  @@day1<=@@last_day2?
    RaiseError( ${errkern1:::eKernDocNumIntervalNotLast}, @@last_day2 ):
    0;
; проверяем использование старого интервала
  call("$CURCFG::cmds:doc_num_cnu", @@day1, @@day2 );
#}
char pipe_delete_vld=\
#{
; проверяем использование удаляемого интервала
  call("$CURCFG::cmds:doc_num_cnu", @@day1, @@day2 );
#}
;--------------------------------------------------
; эмуляция истории
; реально insert обрабатывается как stdupdate
char pipe_pre_insert=\
#{
; в случае вставки первой записи будет обработано 0 записей
  SQL update list_docnum set day2=?day1-1
      where day2=$DayMax;
  IO.day2=$DayMax;
#}
; реально delete обрабатывается как stdrollback(update)
char pipe_pre_delete=HEAP.day1=@@day1;HEAP.day2=@@day2;
char pipe_post_delete=\
#{
; в случае удаления первой записи будет обработано 0 записей
  SQL update list_docnum set day2=?HEAP.day2
      where day2=?HEAP.day1-1;
#}
;--------------------------------------------------
[cmds]
; получить последний интервал
char doc_num_get_last=\
#{
  last_day1=last_day2=date("");
  SQL select max(day2)
      into ?last_day2
      from list_docnum;
  isnull(@@last_day2)?
    return(0): 0;
  SQL select day1
      into ?last_day1
      from list_docnum
      where day2=?last_day2;
#}
; проверить использование периода нумерации
char doc_num_cnu_parms=day1,day2
char doc_num_cnu=\
#{
; проверяем, что в интервале не было документов
  foreach( "subj", ",",
    ConfigGet("$CURCFG::DocNum:subj_list"),
    "KernDocNumCheckDoc( @@@@day1, @@@@day2, @@@@subj, "+
      "${errkern1:::eKernDocNumIntervalUsed}, 0 )" );
#}
;==================================================
[DocNumTable]
const char main_class=DB_Form
const char parent_kstat=$CURCFG::DocNum
char title=Нумерация документов
char scr_name=fdr_doc_num_tbl
; можно добавлять/удалять
char scr_mode=view
char filter_mode=tselect
char edt_modes=sid!p!P
; если нет записей перейти в режим добавления
long empty->add=1
char add_extra_obj=$CURCFG::DocNumForm
;--------------------------------------------------
[DocNumForm]
const char main_class=DB_Form
const char parent_kstat=$CURCFG::DocNum
char title=Новый интервал нумерации документов
char scr_name=doc_num_frm
char scr_mode=edit
char edt_modes=ui1!p
char enterline_add=set_chgflag;

;==================================================
; информация об остатках на счетах
;--------------------------------------------------
template [TurnTpl]
const char main_class=DB_Kstat
const char read_access=any
char ks_table=
const char ks_keys=op_day,c_accnt,c_curr

;--------------------------------------------------
[Turnovers] default: TurnTpl
const char ks_table=turnovers

[Turnovers_with_to] default: TurnTpl
const char ks_table=turn_rtr
const char ks_where=[turn_d]>0 or [turn_c]>0 or [op_day] in ($DATE_START, $DATE_YEAR_2017)
char synonyms=\
#{";"
  _year[LONG]=?/op_day/long(rfmtdate(@op_day, "yyyy"))
#}

;--------------------------------------------------
[Turn] default: TurnTpl
const char ks_table=turn_rtr
char foreigns=\
#{
   TI(TurnInfo):op_day,c_accnt,c_curr;
   RI(RestInfo):op_day,c_accnt,c_curr;
#}
char synonyms=\
#{
  turni_d[MONEY]=?/turn_d,TI.turn_d/money(@turn_d+
    (isnull(@TI.turn_d)?0:@TI.turn_d));
  turni_c[MONEY]=?/turn_c,TI.turn_c/money(@turn_c+
    (isnull(@TI.turn_c)?0:@TI.turn_c));
  resti[MONEY]=?/rest2,RI.rest2/money(@rest2+
    (isnull(@RI.rest2)?0:@RI.rest2));
  info[50]=?/rest1,resti/("("+rfmtmoneyl(@rest1)+"/"+rfmtmoneyl(@resti)+")");
#}
;--------------------------------------------------
[TurnInfo] default: TurnTpl
const char ks_table=turn_it
;--------------------------------------------------
[RestInfo] default: TurnTpl
const char ks_table=turn_ir2

;==================================================
; информация о банках
; (т.к. банк нужен только для указания его в качестве нашего банка, а в
; этом качестве у него используется только поле key_digit для
; формирования маски счета, то сокращаем работу с банками по минимуму:
; - чтение
; - начальное добавление)
;--------------------------------------------------
template [BankTpl]
const char main_class=DB_Kstat
const char read_access=any
const char insert_access=PLACE_NORIGHT
const char update_access=DISABLE
const char delete_access=DISABLE
char ks_keys=c_bank
;--------------------------------------------------
[BankAttr] default: BankTpl
const char ks_table=banks_attrs
; c_bank      - код банка
; name        - полное наименование
; shname      - краткое наименование
; mfo2        - БИК (вторичный ключ)
; key_digit   - ключ для проверки кодовой информации
; prev_change - история
; next_change 
char ks_order=c_bank
char history=change:prev_change/next_change
char query_defaults=prev_change:@today;next_change:$DayMax;
char ks_defaults=key_digit:-1
char masters=BankDef:c_bank;
char synonyms=bik==mfo2;
; для точного поиска
char synonyms=${.:synonyms}bik_lu==mfo2;bik_out=!0[mfo2];
char filter_fields=${.:filter_fields}bik_lu:(%?%=mfo2);
;------------------------------------------
; validate
char kernel_history=New:VldAdd;
char VldAdd=\
#{
; проверяем формат БИК
  ( strlen(@@mfo2)!=8? 1:
      strspn( @@mfo2, "0123456789" )!=8 )?
    RaiseError( ${errkern1:::eKernBankIllMFO8}, @@mfo2 ): 0;
; проверяем уникальность БИК
  $LONG(ekey)
  call("$CURCFG::cmds:bank_check_dup_bik");
#}
;--------------------------------------------------
char pipe_pre_insert=\
#{
; всегда вычисляем ключ
  IO.key_digit=KernCheckBankKey( @@mfo2, -1 );
#}
;--------------------------------------------------
[cmds]
; проверка уникальности БИК
; вх: c_bank - код проверяемого банка;
;     prev_change..next_change - период проверки;
;     mfo2 - проверяемые данные;
char bank_check_dup_bik=\
#{
  SQL select min(c_bank) into ?ekey
      from banks_attrs
      where mfo2=?mfo2 and
        next_change>=?prev_change and prev_change<=?next_change and
        c_bank!=?c_bank;
  isnull(@@ekey)?
    return(0): 0;
  $DATE(eday)
  SQL select min(prev_change) into ?eday
      from banks_attrs
      where c_bank=?ekey and
        mfo2=?mfo2 and
        next_change>=?prev_change and prev_change<=?next_change;
  RaiseError( ${errkern1:::eKernBankExistBIK_},
    call("4glgpf::KeyDesc:Bank"), @@eday );
#}
;==================================================
; определение банков (используется только для получения нового кода)
[BankDef] default: BankTpl
const char ks_table=banks_def
; c_bank    - код банка
; open_day/delete_day
char serial=c_bank
char ks_order=c_bank
char history=open:open_day/delete_day
char query_defaults=open_day:@today;delete_day:$DayMax;
;==================================================
; наш банк
[OurBank]
const char main_class=DB_Kstat
const char read_access=any
const char update_access=PLACE_OUR_BANK
const char insert_access=PLACE_OUR_BANK
const char delete_access=DISABLE
const char ks_table=our_bank
; c_bank    - код банка (в справочнике банков)
; name      - простое имя банка
; full_name - полное имя банка (с расшифровкой)
; inn       - ИНН
; kpp       - КПП
; prev_change/next_change
const char ks_keys=c_our_bank
const char serial=c_our_bank
char ks_order=c_our_bank,next_change
const char history=change:prev_change/next_change
char query_defaults=prev_change:@today;next_change:$DayMax;
char spc_codes=$spcRollbackUpdate: PLACE_OUR_BANK;
char lookups=Banks($CURCFG::BankAttr):c_bank;
;--------------------------------------------------
; validate
char kernel_history=\
#{
  New:            VldAdd;
  Change:         VldAdd;
  RollbackChange: VldAdd;
#}
char VldAdd=\
#{
; проверяем код
  @@c_our_bank==$OURBANK_OUR? 0:
    RaiseError( ${errkern1:::eKernOurBankExist} );
; проверяем ИНН
  @@inn==""? 0:
    CheckINN( @@inn );
; запрещаем пустой банк
  @@c_bank? 0:
    RaiseError( ${errkern1:::eKernOurBankNoBank} );
; проверяем существование банка
  KernCheckBankRange( @@prev_change, @@next_change, @@c_bank );
#}
;--------------------------------------------------
char pipe_pre_update=\
#{
; полное наименование не должно быть пустым
  @@full_name==""?
    IO.full_name=@@name: 0;
#}
;--------------------------------------------------
[OurBankEdit]
const char main_class=DB_Form
char parent_kstat=$CURCFG::OurBank
char scr_name=fdr_our_bank
char scr_mode=edit
char edt_modes=u1X!p
char spc_list=/$spcRollbackUpdate

;==================================================
; пользователи/группы
;--------------------------------------------------
; группы прав пользователей
[NGroups]
const char main_class=DB_Kstat
const char read_access=any
const char insert_access=PLACE_USERS
const char update_access=PLACE_USERS
const char delete_access=PLACE_USERS
const char ks_table=groups
; c_group - code of group
; shname  - short name
; name    - full name
const char ks_keys=c_group
const char serial=c_group
char ks_order=c_group
char slave_refs=NGRights($CURCFG::NGRights):c_group;
char rfc_modifiers=NGRights:u;
char references=Users($CURCFG::Users):c_group;
;--------------------------------------------------
; validate
char pipe_insert_vld=\
#{
; проверяем непустоту и дубликат краткого наименования
  @@shname==""?
    RaiseError( ${errkern1:::eKernGroupEmptyName} ): 0;
  $LONG(ekey)
  SQL select min(c_group) into ?ekey
      from groups
      where shname=?shname and
        not(c_group=?STORE.c_group);
  isnull(@@ekey)? 0:
    RaiseError( ${errkern1:::eKernGroupExist},
      call("4glgpf::KeyDesc:Group") );
#}
char pipe_update_vld=\
#{
; проверяем супер-группу
  @@c_group==$GROUP_SUPERGROUP?
    RaiseError( ${errkern1:::eKernGroupSuper} ): 0;
  call("$CURCFG::$CURSEC:pipe_insert_vld");
#}
char pipe_delete_vld=\
#{
; проверяем супер-группу
  @@c_group==$GROUP_SUPERGROUP?
    RaiseError( ${errkern1:::eKernGroupSuper} ): 0;
; проверяем использование
  $LONG(ekey)
  SQL select min(c_user) into ?ekey
      from users
      where c_group=?c_group;
  isnull(@@ekey)? 0:
    RaiseError( ${errkern1:::eKernGroupUsed},
      call("4glgpf::KeyDesc:User") );
#}
;--------------------------------------------------
; для редактирования (не разрешаем работать с группой SUPER)
[NGroupsNotSuper]
const char main_class=DB_Kscurs
const char parent_kstat=$CURCFG::NGroups
char ks_where=[c_group]!=$GROUP_SUPERGROUP
;--------------------------------------------------
; базовые пpава
[NGRights]
const char main_class=DB_Kstat
const char read_access=any
const char insert_access=PLACE_USERS
const char update_access=PLACE_USERS
const char delete_access=PLACE_USERS
const char ks_table=grouprights
const char ks_keys=c_group,c_base_right
char ks_order=c_group,c_base_right
char foreigns=UBR(dbores::BaseRightsDef):c_base_right;
;--------------------------------------------------
; базовые пpава, из которых формируются права группы
[BaseRightsDef]
const char main_class=DB_Kstat
const char read_access=any
const char ks_table=baserights_def
const char ks_keys=c_base_right
; не показываем базовое право для PLACE_NORIGHT
char ks_where=[c_base_right] not in(${rights::BASE_NORIGHT:id})
;==================================================
; редактирование
[GroupEdit]
const char main_class=DB_Form
char parent_kstat=dbores::NGroupsNotSuper
char title=Группы прав
char scr_name=groups_rights_tbl
char scr_mode=view
; разрешаем добавление по образцу
char edt_modes=suId!p!P
char add_extra_obj=$CURCFG::GroupForm
char edt_extra_obj=$CURCFG::GroupForm
long empty->add=1
;--------------------------------------------------
[GroupForm]
const char main_class=DB_Form
char parent_kstat=dbores::NGroupsNotSuper
char title=Группы прав пользователей
char scr_name=fdr_groups_frm
char scr_mode=edit
char edt_modes=ui1d!p
char add_acts=\
#{
  *(add,dispatch,"Вернуться в режим выбора#P3"): ESC
  { pipe=
      control{pipe=get_chgflag,break=exit};
      control{pipe=
        message{place=ask,text="Добавлять группу?"},
        break=exit
      };
      vldopn{opn=std};
      doopn{opn=insert};
      setmode{mode=edit};
      doopn{opn=read};
      enter_line
  };
  *(add,dispatch,"Вставка#P-"): LFENTER
  { pipe=
      control{pipe=get_chgflag,break=
        message{code=${formmsg:::msgNotInserted},place=prompt};
        exit
      };
      vldopn{opn=std};
      doopn{opn=insert};
      setmode{mode=edit};
      doopn{opn=read};
      enter_line
  };
#}
;--------------------------------------------------
[GroupView] default: GroupForm
char scr_mode=view
char edt_modes=u1
char add_acts=
;--------------------------------------------------
; редактирование списка прав группы
[GroupsRights_bob]
char title=Права группы
char scr_name=fdr_base_rights_tbl
char scr_mode=view
char filter_mode=tselect
char edt_modes=sid!p!P
long empty->add=1
;--------------------------------------------------
; просмотр членов группы
[GroupMembers_bob]
char title=Члены группы
char scr_name=users_tbl
char scr_mode=view
char filter_mode=tselect
char edt_modes=s!p!P
;==================================================
; пользователи
[Users]
const char main_class=DB_Kstat
const char read_access=any
const char insert_access=PLACE_USERS
const char update_access=PLACE_USERS
const char delete_access=PLACE_USERS
const char ks_table=users
; c_user  - code of user
; shname  - short name
; name    - full name
; c_group - code of group user belonged to
; level   - access level
; nregs   - максимальное число одновременно работающих пользователей
;           под этим именем
; open_day   - date of income
; delete_day - date of fire
const char ks_keys=c_user
char serial=c_user
char ks_order=name,-delete_day,open_day
char history=open:open_day/delete_day
char query_defaults=open_day:@today;delete_day:$DayMax;
char ks_defaults=nregs:1;
char foreigns=\
#{
  NGroups($CURCFG::NGroups):c_group;
  NGroupsNotSuper($CURCFG::NGroupsNotSuper):c_group;
#}
; разрешаем вводить любую дату delete_day
char options=${.:options}ERRMSG.delete_hist:-;
;--------------------------------------------------
; validate
char kernel_history=\
#{
; проверяем существование и дубликат
  New           : VldDup(rb_flag=0);
  RollbackDelete: VldDup(rb_flag=1);
; проверяем использование
  Delete        : VldDel(rb_flag=0);
  RollbackNew   : VldDel(rb_flag=1);
; проверяем существование и дубликаты, и использование
  Change        : VldChange;
#}
char VldDup=\
#{
; проверяем ручное заведение истории
  call("4glgpf:::HistRecCheck", Otoday() );
; пока существование группы не проверяем
; проверяем дубликат краткого наименования в периоде
  call("$CURCFG::cmds:user_cdu_shname",
    @@rb_flag? @@STORE.delete_day+1: @@open_day, @@delete_day );
#}
char VldDel=\
#{
; проверяем использование
  call("$CURCFG::cmds:user_cnu",
    @@rb_flag? @@STORE.open_day: @@delete_day+1, @@STORE.delete_day );
#}
char VldChange=\
#{
; проверяем ручное изменение истории
  call("4glgpf:::HistRecCheck", Otoday() );
; запрещаем изменение краткого наименования
  @@shname==@@STORE.shname? 0:
    RaiseError( ${errkern1:::eKernUserIllegalChange} );
; пока существование группы не проверяем
; проверяем дубликат краткого наименования в периоде
  @@open_day<@@STORE.open_day ||
  @@delete_day>@@STORE.delete_day ?
    call("$CURCFG::cmds:user_cdu_shname",
      @@open_day, @@delete_day ): 0;
; проверяем использование
  @@open_day>@@STORE.open_day?
    call("$CURCFG::cmds:user_cnu",
      @@STORE.open_day, @@open_day-1 ): 0;
  @@delete_day<@@STORE.delete_day?
    call("$CURCFG::cmds:user_cnu",
      @@delete_day+1, @@STORE.delete_day ): 0;
#}
;--------------------------------------------------
; дополнительные действия
char pipe_post_insert=\
#{
  SQL grant connect to "@shname";
  local("role");
  role=ConfigGet(":::UNIBANK_ROLE");
  @@role==""?
    return(0): 0;
  SQL grant @role to "@shname";
#}
;--------------------------------------------------
[cmds]
; проверить непустоту и дубликат краткого наименования в периоде
char user_cdu_shname_parms=day1,day2
char user_cdu_shname=\
#{
  @@shname!=""? 0:
    RaiseError( ${errkern1:::eKernUserEmptyName} );
  $LONG(ekey)
  SQL select min(c_user) into ?ekey
      from users
      where shname=?shname and
        delete_day>='@day1' and open_day<='@day2' and
        not(c_user=?STORE.c_user);
  isnull(@@ekey)? return(0): 0;
  $CHAR(ename)
  $DATE(eday)
  SQL select name,open_day
      into ?ename,?eday
      from users
      where c_user=?ekey;
  RaiseError( ${errkern1:::eKernUserExist}, @@ename, @@eday );
#}
; проверить использование пользователя в периоде
char user_cnu_parms=day1,day2
char user_cnu=\
#{
  $LONG(ekey)
; проверяем использование пользователя в балансовых документах
  SQL select min(c_doc) into ?ekey
      from docs
      where (c_enter=?c_user or c_vise=?c_user or c_ack=?c_user) and
        op_day between '@day1' and '@day2';
  isnull(@@ekey)? 0:
    RaiseError( ${errkern1:::eKernUserUsedByDocs},
      call("4glgpf::KeyDesc:Doc") );
#}
;==================================================
; редактирование
[UsersEdit] default: EditorTpl
char parent_kstat=$CURCFG::Users
char title=Пользователи системы
char scr_name=fdr_users_frm
char filter_screen=users_tbl
char scr_mode=select
char edt_modes=siux!P
char spc_list=/\
#{","
  $spcDelete
  $spcRollbackDelete
  $spcRollbackInsert
#}

;==================================================
; выбор принтера
;--------------------------------------------------
[PRINTER_list]
const char main_class=DB_Cfgcur
char sections=${::PRINTER_list:contents}
;--------------------------------------------------
[PRINTER_TeX_list]
const char main_class=DB_Cfgcur
char sections=${::PRINTER_TeX_list:contents}
;--------------------------------------------------
template [_PRINTER_show]
const char main_class=DB_Form
const char parent_kstat=${CURSEC%>_show}_list
char scr_name=PRINTERs
char scr_mode=tselect
long show_if_one=1
char flt_add_acts=
char add_acts=\
#{
  *(any,dispatch,"Выбрать принтер#P2#hВыбрать#w0"): ENTER
  { pipe=
      doopn{opn=find};
      getkeys;
      calc{expr=@set_printer};
      quit,
    set_printer='
      ConfigSetString(":::${CURSEC%>_show}",@@section);
      Message("status_line",-1,"Установлен пpинтеp @section");
      EnvShowPaint()'
  };
  *(any,dispatch,"Выбрать принтер глобально#P2#hГлобально#w1"): CTRL_G
  { pipe=
      doopn{opn=find};
      getkeys;
      calc{expr=@set_printer};
      quit,
    set_printer='
      ConfigSetString(":::${CURSEC%>_show}",@@section);
      ConfigSetString(":::g_${CURSEC%>_show}",@@section);
      Message("status_line",-1,"Установлен пpинтеp @section");
      EnvShowPaint()'
  }
#}
;--------------------------------------------------
[PRINTER_show] _PRINTER_show
[PRINTER_TeX_show] _PRINTER_show

;==================================================
; Сокращения (abbrs)
;--------------------------------------------------
[Abbrs]
const char main_class=DB_Kstat
const char ks_table=abbrs
const char ks_keys=type
const char read_access=any
; для точного поиска
char synonyms=abbr_lu==abbr
char filter_fields=abbr_lu:(%?%=abbr)
;--------------------------------------------------
template [SubAbbr]
const char main_class=DB_Kscurs
const char parent_kstat=Abbrs
char ks_where=
;--------------------------------------------------
[AbbrsAccntNtype] SubAbbr
const char ks_where=[type] in(\
#{","
  $ACCNT_NTYPE_INTERN
  $ACCNT_NTYPE_PROFEXP
  $ACCNT_NTYPE_FILRAS
#})
;--------------------------------------------------
[AbbrsRateKind] dbores::SubAbbr
const char ks_where=[type] in(\
#{","
  $RATE_FIXED
  $RATE_CBANK
  $NO_RATE
#})
;--------------------------------------------------
[AbbrsAccntAP] dbores::SubAbbr
const char ks_where=[type] in(\
#{","
  $ACCNT_TYPE_ACTIVE
  $ACCNT_TYPE_PASSIVE
#})

;--------------------------------------------------
[AbbrsNsymbf2AP] dbores::SubAbbr
const char ks_where=[type] in(\
#{","
  $ACCNT_TYPE_ACTIVE
  $ACCNT_TYPE_PASSIVE
  $ACCNT_TYPE_ACT_PASS
#})

;--------------------------------------------------
[AbbrsDocType] dbores::SubAbbr
const char ks_where=[type] between $DOC_TYPE_BASE and $DOC_TYPE_MASK
;--------------------------------------------------
[AbbrsDocState] dbores::SubAbbr
const char ks_where=[type] in(\
#{","
  $DOC_STATE_ENTERED
  $DOC_STATE_PERFORMED
#})

;==================================================
; ресурсы для RfcChoice
;--------------------------------------------------
; выбор типа по сокращению и имени (ширина 19, высота 6)
[Abbr_Name_select]
const char scr_name=abbr_name_slct
const char edt_modes=s
; выбор типа по сокращению и имени (ширина 40, высота 8)
[Abbr_Name40_select]
const char scr_name=abbr_name40_slct
const char edt_modes=s
; выбор имени (ширина 40 символов, высота 8)
[Name40_select]
const char scr_name=name40_slct
const char edt_modes=s
;--------------------------------------------------
; выбор валюты
[Curr_select]
const char scr_name=fdr_currinfo_slct
const char edt_modes=s
;--------------------------------------------------
; выбор балансового счета 1го порядка
[Naccnt1_Name_select]
const char scr_name=npl_accnt1_tbl
const char edt_modes=s
;--------------------------------------------------
; выбор балансового счета
[NAccnt_select]
const char scr_name=fdr_npl_accnt2_slct
const char edt_modes=s
; выбор балансового счета в таблице NAccntAcckind
[Acckind_NAccnt_select]
const vars_prefix=NPL
const char scr_name=fdr_npl_accnt2_slct
const char edt_modes=s
;--------------------------------------------------
; выбор проекта
[BranchSup_select]
const char scr_name=fdr_branch_sup_slct
const char edt_modes=s
;--------------------------------------------------
; выбор подпроекта
[BranchSub_select]
const char scr_name=fdr_branch_sub_slct
const char edt_modes=s
;--------------------------------------------------
; выбор символа доходов/расходов
[Nsymbf2_Name_select]
const char scr_name=fdr_nsymbols_slct
const char edt_modes=s
;--------------------------------------------------
; выбор места хранения
[Nukind_select]
const char scr_name=fdr_nukinds_tbl
const char edt_modes=s
;--------------------------------------------------
; выбор счёта
[Accnt_select]
const char scr_name=fdr_accnt_flt
const char edt_modes=s
; выбор счёта через валюту
[AccntAccnt_select]
const vars_prefix=Accnt
const char scr_name=fdr_accnt_flt
const char edt_modes=s
;--------------------------------------------------
; выбор счета с валютой
[Accnt_Curr_select]
const char scr_name=accnt_multi_slct
const char edt_modes=s
;--------------------------------------------------
; выбор группы прав пользователей
[GroupRight_select]
const char scr_name=groups_rights_tbl
const char edt_modes=s
;--------------------------------------------------
; выбор по имени пользователя
[User_select]
const char scr_name=users_tbl
const char edt_modes=s
;--------------------------------------------------
[]
