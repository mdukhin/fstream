;==================================================
; выписки с использованием объектов
#opencfg "abbrs.cfg"
#opencfg "ospcs.cfg"
#opencfg "4glgpf.cfg"
#opencfg "report.cfg"
SECPATH=abbrs::;ospcs::;4glgpf::;.;$CURCFG::;::
;--------------------------------------------------

;==================================================
; новая выписка (подокументная)
;--------------------------------------------------
; получение списка документов для выписки
[NStatDocs]
const char main_class=DB_Ksrpt
char attrs=\
#{
; связывающие атрибуты
  c_accnt int not null,
  c_curr int not null,
  op_day date not null,
; код основного документа
  c_doc int not null,
; сумма документа, относящаяся к счёту
  dc char(1) not null,
  isum money not null,
; тип документа (для выбора способа представления информации в выписке)
  type smallint not null,
; дополнительная информация о документе
; идентификатор проводки
  pc_doc int not null,
  psum_id smallint not null,
; * поля не нормализованы из-за сложности поддержки нескольких таблиц в
;   Ksrpt
; дополнительная информация о проводке
; - проводка может быть в другой валюте,
  pc_curr int not null,
; - сумма проводки,
  pdc char(1) not null,
  psum money not null,
; - счёт контрагента
  pc_accnt int not null,
; - информация о контрагенте
  ccurracc varchar($NELN) default '',
  cname varchar($BGLN) default '',
; признак конверсионного документа (c)
  conv_doc char(1) default ' '
#}
char ks_keys=c_accnt,c_curr,c_doc,pc_doc,psum_id
; для построения фильтра
char synonyms=\
#{
  Date0==op_day;
  Date1==op_day;
#}
char base_attrs=Date0,Date1,rep_accnts
char pipe_subobj=\
#{
  local("accnt_where");
  @@rep_accnts==""?
    accnt_where="":
    ExecutePipe(
      "-SQL create index @{rep_accnts}_ on @rep_accnts (c_accnt);"+
      "SQL update statistics high for table @rep_accnts (c_accnt);"+
      "accnt_where=\"@@@@1 in(select c_accnt from @rep_accnts) and\";"
    );
; собираем проводки
  SQL insert into @_rpt_table (c_accnt,c_curr,op_day,
        c_doc,dc,isum,type,
        pc_doc,psum_id,
        pc_curr,pdc,psum,pc_accnt)
      select p.c_accnt_debit,p.c_curr,p.op_day,
        p.c_doc,$DEBIT,p.isum,d.type,
        p.c_doc,p.psum_id,
        p.c_curr,$CREDIT,p.isum,p.c_accnt_credit
      from provs p
        join docs d on d.c_doc=p.c_doc
      where @accnt_where(p.c_accnt_debit)
        p.op_day between ?Date0 and ?Date1 and
        d.state in($DOC_STATE_PERFORMED,$DOC_STATE_ZPERFORMED);
  SQL insert into @_rpt_table (c_accnt,c_curr,op_day,
        c_doc,dc,isum,type,
        pc_doc,psum_id,
        pc_curr,pdc,psum,pc_accnt)
      select p.c_accnt_credit,p.c_curr,p.op_day,
;       используем сумму со знаком для упрощения суммирования
        p.c_doc,$DEBIT,-p.isum,d.type,
        p.c_doc,p.psum_id,
        p.c_curr,$DEBIT,p.isum,p.c_accnt_debit
      from provs p
        join docs d on d.c_doc=p.c_doc
      where @accnt_where(p.c_accnt_credit)
        p.op_day between ?Date0 and ?Date1 and
        d.state in($DOC_STATE_PERFORMED,$DOC_STATE_ZPERFORMED);
  SQL create unique index @{_rpt_table}_ on @_rpt_table (${.:ks_keys});
  SQL update statistics high for table @_rpt_table (${.:ks_keys});
; подготовливаем информацию о документах в таблице @_rpt_table (все
; частичные проводки)
  try("$CURCFG::cmds:nstat_process","", 0, 0, 1 );
#}
;--------------------------------------------------
char foreigns=\
#{
  Accnt(dbores::AccDay):c_accnt,op_day(#today);
  AccntCurr(dbores::AccntCurrDay):c_accnt,c_curr,op_day(#today);
  Curr(dbores::Curr):c_curr;
  Conf(dbores::KsConf):c_doc;
;;PCurr(dbores::Curr):pc_curr(c_curr);
;;PAccnt(accnt::AccntDay):pc_accnt(c_accnt),op_day(#today);
  Turn:op_day,c_accnt,c_curr;
#}
char synonyms=${.:synonyms}\
#{
  name==Accnt.name;
; две суммы
  debit  [MONEY]=?(@dc==$DEBIT ? @isum: 0);
  credit [MONEY]=?(@dc==$CREDIT? @isum: 0);
  pdebit [MONEY]=?(@pdc==$DEBIT ? @pisum: 0);
  pcredit[MONEY]=?(@pdc==$CREDIT? @pisum: 0);
#}
;--------------------------------------------------
[cmds]
; подготовить информацию о документах в таблице @_rpt_table
; вх: - таблица @_rpt_table, в которой оперделены поля:
;         c_accnt, c_curr, op_day, (связывающие атрибуты)
;         c_doc, dc, isum, type, (информация об основном документе)
;         pc_doc, psum_id, (идентификатор проводки)
;         pc_curr, pdc, psum, pc_accnt (информация о проводке);
;     one_pdoc - флаг выписки без информации о частичных проводках/
;       документах, в качестве корреспондирующего счёта используется
;       счёт первой частичной проводки;
;     our_bank_for_mem_cash - флаг указания нашего банка как банка
;       контрагента для внутренних документов (мемориальных ордеров и
;       кассовых документов);
; вых: определены остальные поля в таблице @_rpt_table;
char nstat_process_parms=one_pdoc,our_bank_for_mem_cash
char nstat_process=\
#{
; обрабатываем цепочку документов конверсии
; заменяем основной документ для цепочки документов конверсии
  local("c_convert");
  c_convert=KernGetStdAccntCode( "$STDACCNT_CONVERSION" );
  SQL create temp table reptmp
      (
        c_accnt int not null,
        c_curr int not null,
;       код основного документа цепочки
        c_doc int,
;       атрибуты основного документа
        op_day date,
        type smallint,
;       сумма документа, относящаяся к счёту (со знаком)
        isum money not null,
;       идентификатор проводки
        pc_doc int not null,
        psum_id smallint not null
      ) with no log;
  SQL insert into reptmp(c_accnt,c_curr,isum,pc_doc,psum_id)
      select c_accnt,c_curr,isum,pc_doc,psum_id
      from @_rpt_table
      where pc_accnt=@c_convert;
  GetProcessedRecsNum()>0?
    call("$CURCFG::cmds:nstat_process_conv"): 0;
  SQL drop table reptmp;
; считаем сумму документа, относящуюся к счёту и валюте
  SQL select c_accnt,c_curr,c_doc,sum(isum)::money isum
      from @_rpt_table
      where pc_curr=c_curr
      group by 1,2,3
      into temp reptmp with no log;
  SQL update @_rpt_table set isum=(select isum from reptmp r
        where r.c_accnt=@{_rpt_table}.c_accnt and
          r.c_curr=@{_rpt_table}.c_curr and
          r.c_doc=@{_rpt_table}.c_doc)
      where exists(select * from reptmp r
        where r.c_accnt=@{_rpt_table}.c_accnt and
          r.c_curr=@{_rpt_table}.c_curr and
          r.c_doc=@{_rpt_table}.c_doc);
  SQL drop table reptmp;
  SQL update @_rpt_table set
        dc=$CREDIT,isum=-isum
      where isum<0;
; удаляем ненужные частичные проводки
  @@one_pdoc?
    try("$CURCFG::cmds:nstat_process_one_pdoc",""): 0;
; устанавливаем дополнительную информацию о документе в целом (по
; аналогии с синонимами dboconf::RepStat_conf)
; - счёт проводки контрагента для остальных случаев
  SQL update @_rpt_table set
        ccurracc=(select am.necurracc from accnts_multi am
          where am.c_accnt=@_rpt_table.pc_accnt and
            am.c_curr=@_rpt_table.pc_curr and
            @_rpt_table.op_day between am.open_day and am.delete_day)
      where ccurracc="";
; - наименование счёта контрагента проводки для мемориальных ордеров
  SQL update @_rpt_table set
        cname=(select an.name from accnts_name an
          where an.c_accnt=@_rpt_table.pc_accnt and
            @_rpt_table.op_day between an.prev_change and
              an.next_change)
      where psum_id=0 and cname="" and
        type in($DOCTYPEC_MEM);
; сбрасываем сумму проводки кроме как для документов конвертации
  SQL update @_rpt_table set pdc=pdc+2
      where conv_doc!="c";
#}
char nstat_process_ERR=\
#{
 -SQL drop table reptmp;
#}
; обработать цепочку документов конверсии
; вх: - таблица reptmp, поля которой относятся к следующим категориям:
;       * которые необходимо перенести в выходную таблицу "как есть"
;         (c_accnt,c_curr,isum),
;       * код начального документа цепочки (pc_doc), по нему
;         определяется код основного документа (c_doc), который
;         переносится в выходную таблицу,
;       * атрибуты основного документа цепочки (op_day,type), после
;         выяснения кода основного документа цепочки на его основе
;         устанавливаются эти атрибуты и переносятся в выходную таблицу,
;       * идентификатор проводки (c_accnt,c_curr,pc_doc,psum_id),
;         который используется для удаления из выходной таблицы
;         заменяемых записей;
;     - выходная таблица @_rpt_table, в которой записи, относящиеся к
;       операциям конвертации (которые присутствуют в таблице reptmp),
;       будут заменены на записи с правильными проводками (pc_doc,
;       psum_id,pc_curr,psum,pc_accnt),
;     c_convert - счёт ОВП;
char nstat_process_conv=\
#{
; (по аналогии с repdoc::cmds:conv_check_group_init)
; определяем цепочку документов (заодно устанавливаем атрибуты
; начального документа цепочки, т.к., если он окажется основным, то это
; позволит избежать повторного обращения к таблице docs)
  SQL update reptmp set
        (c_doc,op_day,type)=((select d.c_parent,d.op_day,d.type
          from docs d
          where d.c_doc=reptmp.pc_doc));
; если главный документ цепочки не указан, то считаем, что начальный
; документ является главным
  SQL update reptmp set c_doc=pc_doc where c_doc=0;
  SQL update statistics high for table reptmp(c_doc);
; если главный документ отличается от начального, то определяем его
; атрибуты
  SQL update reptmp set
        (op_day,type)=((select d.op_day,d.type
          from docs d
          where d.c_doc=reptmp.c_doc))
      where c_doc!=pc_doc;
; удаляем заменяемые записи из выходной таблицы
  SQL delete from @_rpt_table
      where exists(select * from reptmp r where
        @_rpt_table.c_accnt=r.c_accnt and
        @_rpt_table.c_curr=r.c_curr and
        @_rpt_table.c_doc=r.pc_doc and
        @_rpt_table.pc_doc=r.pc_doc and
        @_rpt_table.psum_id=r.psum_id);
; (по аналогии с dboconf::cmds:print_conv_prepare_table)
; счёт ОВП по дебету
; or в условии плохо отрабатывается поэтому разбил select на 2      
  SQL insert into @_rpt_table (c_accnt,c_curr,op_day,
        c_doc,dc,isum,type,
        pc_doc,psum_id,
        pc_curr,pdc,psum,pc_accnt,
        conv_doc)
      select {+ORDERED} r.c_accnt,r.c_curr,r.op_day,
        r.c_doc,$DEBIT,r.isum,r.type,
        p.c_doc,p.psum_id,
        p.c_curr,$CREDIT,p.isum,p.c_accnt_credit,
        'c'
      from reptmp r
;       только основные документы
        join docs d on d.c_doc=r.c_doc
        join provs p on p.c_doc=d.c_doc and p.type=$PROV_TYPE_BASE
      where r.isum>0 and
        p.c_accnt_debit=@c_convert;
  SQL insert into @_rpt_table (c_accnt,c_curr,op_day,
        c_doc,dc,isum,type,
        pc_doc,psum_id,
        pc_curr,pdc,psum,pc_accnt,
        conv_doc)
      select {+ORDERED} r.c_accnt,r.c_curr,r.op_day,
        r.c_doc,$DEBIT,r.isum,r.type,
        p.c_doc,p.psum_id,
        p.c_curr,$CREDIT,p.isum,p.c_accnt_credit,
        'c'
      from reptmp r
;       только зависимые документы
        join docs d on d.c_parent=r.c_doc and d.c_doc!=r.c_doc
        join provs p on p.c_doc=d.c_doc and p.type=$PROV_TYPE_BASE
      where r.isum>0 and
        p.c_accnt_debit=@c_convert;
; счёт ОВП по кредиту
  SQL insert into @_rpt_table (c_accnt,c_curr,op_day,
        c_doc,dc,isum,type,
        pc_doc,psum_id,
        pc_curr,pdc,psum,pc_accnt,
        conv_doc)
      select {+ORDERED} r.c_accnt,r.c_curr,r.op_day,
;       используем сумму со знаком для упрощения суммирования
        r.c_doc,$DEBIT,r.isum,r.type,
        p.c_doc,p.psum_id,
        p.c_curr,$DEBIT,p.isum,p.c_accnt_debit,
        'c'
      from reptmp r
;       только основные документы
        join docs d on d.c_doc=r.c_doc
        join provs p on p.c_doc=d.c_doc and p.type=$PROV_TYPE_BASE
      where r.isum<0 and
        p.c_accnt_credit=@c_convert;
  SQL insert into @_rpt_table (c_accnt,c_curr,op_day,
        c_doc,dc,isum,type,
        pc_doc,psum_id,
        pc_curr,pdc,psum,pc_accnt,
        conv_doc)
      select {+ORDERED} r.c_accnt,r.c_curr,r.op_day,
        r.c_doc,$DEBIT,r.isum,r.type,
        p.c_doc,p.psum_id,
        p.c_curr,$DEBIT,p.isum,p.c_accnt_debit,
        'c'
      from reptmp r
;       только зависимые документы
        join docs d on d.c_parent=r.c_doc and d.c_doc!=r.c_doc
        join provs p on p.c_doc=d.c_doc and p.type=$PROV_TYPE_BASE
      where r.isum<0 and
        p.c_accnt_credit=@c_convert;
#}
; удалить ненужные (непервые) частичные проводки
char nstat_process_one_pdoc=\
#{
; выясняем код первого частичного документа
  SQL select r.c_accnt,r.c_curr,r.c_doc,
        min(r.pc_doc)::int pc_doc
      from @_rpt_table r
      group by 1,2,3
      into temp reptmp with no log;
  SQL create unique index reptmp_ on reptmp(c_accnt,c_curr,c_doc);
  SQL update statistics high for table reptmp(c_accnt,c_curr,c_doc);
; выясняем код первой частичной проводки
  SQL select r.c_accnt,r.c_curr,r.c_doc,r.pc_doc,
        min(r.psum_id)::int psum_id
      from @_rpt_table r
        join reptmp t on t.c_accnt=r.c_accnt and
          t.c_curr=r.c_curr and t.c_doc=r.c_doc and
          t.pc_doc=r.pc_doc
      group by 1,2,3,4
      into temp reptmp1 with no log;
  SQL drop table reptmp;
  SQL create unique index reptmp1_ on reptmp1(c_accnt,c_curr,c_doc,
        pc_doc);
  SQL update statistics high for table reptmp1(c_accnt,c_curr,c_doc,
        pc_doc);
; удаляем ненужные проводки
  SQL delete from @_rpt_table
      where not exists(select * from reptmp1 t
        where t.c_accnt=@_rpt_table.c_accnt and
          t.c_curr=@_rpt_table.c_curr and
          t.c_doc=@_rpt_table.c_doc and
          t.pc_doc=@_rpt_table.pc_doc and
          t.psum_id=@_rpt_table.psum_id);
  SQL drop table reptmp1;
#}
char nstat_process_one_pdoc_ERR=\
#{
 -SQL drop table reptmp;
 -SQL drop table reptmp1;
#}

;==================================================
; выписка по запросу
;--------------------------------------------------
; данные запроса
[NStatData]
const char main_class=DB_Cfgcur
const char sections=$CURCFG::$CURSEC
char read_access=any
char update_access=any
char fields=${report::accs_range:fields}
date Date0=
date Date1=
long c_accnt_0=0
long c_accnt_1=0
long c_accnt_2=0
long c_accnt_3=0
long c_accnt_4=0
char ks_defaults=${report::accs_range:ks_defaults}
char foreigns=${report::accs_range:foreigns}
; документы
char references=\
#{
  Docs($CURCFG::NStatDocs):Date0,Date1,'rep_accnts'(rep_accnts);
#}
;--------------------------------------------------
; счет и период
[NStatAsk] default: report::som_c_resource_tpl
char parent_kstat=$CURCFG::NStatData
char title=Выписка
char scr_name=${report::accs_range:scr_name}
char fields=${report::accs_range:fields}
char add_acts=${report::accs_range:add_acts}
;--------------------------------------------------
[NStatReport] default: report::Report
char desc=Выписка по счетам
char desc_full=\
#{
  Подокументная выписка
  по указанным счетам за указанный период
  со специальным отображением конверсионных операций
#}
char file=r_#U.r51
char som_ask_obj=$CURCFG::NStatAsk
char FormPath=rnstat3.lnf
; настройка отчета
char ks_where=
char ks_order=\
#{","
  Accnt.*order,c_curr,op_day
  -dc,isum,c_doc
  pc_doc,psum_id
#}
char som_command=\
#{
; передаём код счёта через таблицу с фиксированным именем
  SQL create temp table rep_accnts
      ( c_accnt int not null
      ) with no log;
  SQL insert into rep_accnts(c_accnt) values(?c_accnt_0);
  SQL insert into rep_accnts(c_accnt) values(?c_accnt_1);
  SQL insert into rep_accnts(c_accnt) values(?c_accnt_2);
  SQL insert into rep_accnts(c_accnt) values(?c_accnt_3);
  SQL insert into rep_accnts(c_accnt) values(?c_accnt_4);
; готовим ksrpt
  rep_accnts="rep_accnts";
  ksr=$CURCFG::NStatDocs.MakeFilter( "<null>",
    "Date0,Date1,rep_accnts", CURRENT(),
    @@ks_order, @@ks_where );
  SQL drop table rep_accnts;
; выводим
  CarbonCopySOM( @@FilePath, @@FormPath, @@ksr );
  Auth.delete_obj_by_name(@@ksr);
#}
char som_command_ERR=\
#{
 -SQL drop table rep_accnts;
 -Auth.delete_obj_by_name(@@ksr);
#}

;==================================================
; выписка за день
;--------------------------------------------------
[NStatReportDay] default: NStatReport
char desc=Выписка по всем счетам за день
char desc_full=\
#{
  Подокументная выписка
  по всем счетам за день
  со специальным отображением конверсионных операций
#}
char file=d=ddmmyy.r58
char som_ask_obj=
char FormPath=rnstat3.lnf
char som_command=\
#{
; готовим ksrpt
  rep_accnts="";
  ksr=$CURCFG::NStatDocs.MakeFilter( "<null>",
    "Date0,Date1,rep_accnts", CURRENT(),
    @@ks_order, @@ks_where );
; выводим
  CarbonCopySOM( @@FilePath, @@FormPath, @@ksr );
  Auth.delete_obj_by_name(@@ksr);
#}
char som_command_ERR=\
#{
 -Auth.delete_obj_by_name(@@ksr);
#}
;--------------------------------------------------
[NStatReportRange] default: NStatReportDay
char desc=Выписка по всем счетам за период
char desc_full=\
#{
  Подокументная выписка
  по всем счетам за указанный период
  со специальным отображением конверсионных операций
#}
char file=r_#U.r32
char FormPath=rnstat3.lnf
char ask_form=report:ask.range
[]
