#opencfg <4glgpf.cfg>
#opencfg <uk_const.cfg>

SECPATH=abbrs::;ospcs::;4glgpf::;uk_const::;$CURCFG::;::


[]

; -----------------------------------------------------------------------------
; по умолчанию выставляем переменные для тестового окружения
char FDR_BASE=kernel_fdr
char UTILS_BASE=kernel_fdr

long _TRUE  = -1
long _FALSE =  0
long _EMPTY = -2

const long CURR_USD = 3
const long CURR_EUR = 4
;const long CURR_CHF = 10
;const long CURR_GBP = 17
;const long CURR_CNY = 36

const spc_get_tunning_info = 1111


;30.12.2016 (-1 от даты в windows!)
long DATE_START     = 42733
long DATE_YEAR_2017 = 43099

char NACCNTS_EMPLOYEE = 60305, 60306, 60308, 60335, 60336
char NACCNTS_DEPOSITS = 20601, 20603, 20613

const long C_DOGOVOR_SIMPLE = 93


#ifdef0 FDR
char FDR_BASE=kern_fdr
char UTILS_BASE=kern_fdr
#endif




; -----------------------------------------------------------------------------
; настройки единые для всех
; -----------------------------------------------------------------------------

; -----------------------------------------------------------------------------
; допустимые символы для номера первичного документа
;    1) маленькие русские буквы заменяются на большие
;    2) Английские буквы, сходные по написанию с русскими - заменяются на соотв. русские (большие)
;    3) Остальные английские буквы - переводятся в верхний регистр и идут как есть
;    4) Цифры и всякие символы (кроме пробелов и скрытых) идут как есть
; -----------------------------------------------------------------------------
PRIM_NUMBER_CHARS=\
#{""
абвгдеёЁжзийклмнопрстуфхцчшщьыъэюя
ABCEHKMOPTXabcehkmoptx
dfgijlnqrsuvwyz
АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЬЫЪЭЮЯ
DFGIJLNQRSUVWYZ
0123456789
!#$$%&()*+,-./:;=?@[\]^_{|}~
==>
АБВГДЕЕЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЬЫЪЭЮЯ
АВСЕНКМОРТХАВСЕНКМОРТХ
DFGIJLNQRSUVWYZ
#}

; -----------------------------------------------------------------------------
; убираем все, кроме символа w - т.е. длина строки будет количеством рабочих дней в месяце
; -----------------------------------------------------------------------------
const char WORK_DAYS_SYMB=\
#{""
w
==>
w
#}

; -----------------------------------------------------------------------------
; убираем все, кроме символа i - т.е. длина строки будет количеством рабочих дней в месяце
; -----------------------------------------------------------------------------
const char ILLNESS_DAYS_SYMB=\
#{""
i
==>
i
#}

; -----------------------------------------------------------------------------
; убираем все, кроме символа v - т.е. длина строки будет количеством рабочих дней в месяце
; -----------------------------------------------------------------------------
const char VACATION_DAYS_SYMB=\
#{""
v
==>
v
#}



; -----------------------------------------------------------------------------
; допустимые символы для счета (только цифры)
; -----------------------------------------------------------------------------
const char CHARS_FOR_REMOVE=\
#{""
0123456789
==>
0123456789
#}

; -----------------------------------------------------------------------------
; условие выбора подпроекта текущего проекта
; !!! для схемы проект -> подпроект !!!
; -----------------------------------------------------------------------------
;char =\
;#{
;  @BranchSelect.c_branch=$BRANCH_CONS or
;  [c_branch] in(select c_branch from branches_cons_dep
;    where c_cons=@BranchSelect.c_branch)
;#}

; -------------------------------------
; -------------------------------------
; атрибут c_branch присутствует в искомом объекте
; -------------------------------------
; ------------------------------------- 

; -------------------------------------
; 1-й случай: 
;       для проекта показываем только его данные, для Конс - показываем всё
; -------------------------------------
char BRANCH_WHERE_OBJ=\
#{
  @BranchSelect.c_branch in ($BRANCH_CONS, [c_branch])
#}

char BRANCH_WHERE_SQL=\
#{
  @BranchSelect.c_branch in ($BRANCH_CONS, c_branch)
#}


; -------------------------------------
; 2-й случай: 
;       для проекта показываем только его данные + то, что помеченно для Конс
; -------------------------------------
char BRANCH_EXT_WHERE_OBJ=\
#{
  $BRANCH_WHERE_SQL or [c_branch] in ($BRANCH_CONS)
#}



;char =\
;#{
;  @BranchSelect.c_branch=$BRANCH_CONS or
;  [Accnt.c_branch] in (select c_branch from branches_cons_dep where c_cons=@BranchSelect.c_branch)
;#}

; -------------------------------------
; -------------------------------------
; атрибут c_branch присутствует в подобъекте Accnt
; -------------------------------------
; ------------------------------------- 
char BRANCH_ACCNT_WHERE=\
#{
  @BranchSelect.c_branch in ($BRANCH_CONS, [Accnt.c_branch])
#}




;> ============================================================================
;> Tables_UK (Управляющая компания/Фонды) 
;> ============================================================================
const char uk_ref_abbrs                       = $FDR_BASE:uk_ref_abbrs
const char uk_ref_settings                    = $FDR_BASE:uk_ref_settings
const char uk_ref_settings_accnts             = $FDR_BASE:uk_ref_settings_accnts
const char uk_ref_schema                      = $FDR_BASE:uk_ref_schema
const char uk_ref_dogkinds_ordertypes         = $FDR_BASE:uk_ref_dogkinds_ordertypes
const char uk_ref_users_branches              = $FDR_BASE:uk_ref_users_branches
const char uk_ref_depreciations               = $FDR_BASE:uk_ref_depreciations

const char uk_ref_measures                    = $FDR_BASE:uk_ref_measures
const char uk_ref_items                       = $FDR_BASE:uk_ref_items
const char uk_ref_item_groups                 = $FDR_BASE:uk_ref_item_groups

const char uk_users_filter_for_orders         = $FDR_BASE:uk_users_filter_for_orders

; -----------------
const char uk_accnts_multi_opl                = $FDR_BASE:uk_accnts_multi_opl
; -----------------
const char uk_contractors_def                 = $FDR_BASE:uk_contractors_def
const char uk_contractors_corp                = $FDR_BASE:uk_contractors_corp
const char uk_contractors_chiefs              = $FDR_BASE:uk_contractors_chiefs
const char uk_contractors_accnts              = $FDR_BASE:uk_contractors_accnts
const char uk_contractors_bank_details        = $FDR_BASE:uk_contractors_bank_details
; -----------------
const char uk_employees_def                   = $FDR_BASE:uk_employees_def
const char uk_employees_work_info             = $FDR_BASE:uk_employees_work_info
const char uk_employees_bank_details          = $FDR_BASE:uk_employees_bank_details
const char uk_employees_accnts                = $FDR_BASE:uk_employees_accnts
const char uk_employees_isums                 = $FDR_BASE:uk_employees_isums
const char uk_employees_calendar              = $FDR_BASE:uk_employees_calendar

; -----------------
const char uk_bank_details                    = $FDR_BASE:uk_bank_details
; -----------------
const char uk_dogovors_def                    = $FDR_BASE:uk_dogovors_def
const char uk_dogovors_params                 = $FDR_BASE:uk_dogovors_params
const char uk_dogovors_accnts                 = $FDR_BASE:uk_dogovors_accnts
const char uk_dogovors_isums                  = $FDR_BASE:uk_dogovors_isums

; -----------------
const char uk_orders_def                      = $FDR_BASE:uk_orders_def
const char uk_orders_params                   = $FDR_BASE:uk_orders_params
const char uk_orders_isums                    = $FDR_BASE:uk_orders_isums
const char uk_orders_provs                    = $FDR_BASE:uk_orders_provs
const char uk_orders_items                    = $FDR_BASE:uk_orders_items
const char uk_orders_states_history           = $FDR_BASE:uk_orders_states_history

; -----------------
; таблицы, связанные с пересчетом остатков
; -----------------
const char uk_ref_turn_field_kinds            = $FDR_BASE:uk_ref_turn_field_kinds
const char uk_ref_calc_resetisums_rules       = $FDR_BASE:uk_ref_calc_resetisums_rules
const char uk_ref_calc_resetparams_rules      = $FDR_BASE:uk_ref_calc_resetparams_rules
const char uk_ref_calc_params_rules           = $FDR_BASE:uk_ref_calc_params_rules

const char uk_calc_isums_employees            = $FDR_BASE:uk_calc_isums_employees
const char uk_calc_params_employees           = $FDR_BASE:uk_calc_params_employees


; -----------------
; таблицы импорта данных
; -----------------
const char uk_import_def                      = $FDR_BASE:uk_import_def
const char uk_import_data_stocks              = $FDR_BASE:uk_import_data_stocks

; -----------------
; таблица для переноса счетов из 1C
; -----------------
const char tmp_accnts_def                     = $FDR_BASE:tmp_accnts_def


; -----------------
; отчетность
; -----------------
const char uk_reports_def                     = $FDR_BASE:uk_reports_def
const char uk_reports_params                  = $FDR_BASE:uk_reports_params
const char uk_reports_msfo_lines_def          = $FDR_BASE:uk_reports_msfo_lines_def
const char uk_reports_msfo_lines_naccnts      = $FDR_BASE:uk_reports_msfo_lines_naccnts
const char uk_reports_msfo_lines_nsymbf2_f5   = $FDR_BASE:uk_reports_msfo_lines_nsymbf2_f5


;> ============================================================================
;> Tables_Utils (общие для всех)
;> ============================================================================
const char utl_months_dates                   = $UTILS_BASE:utl_months_dates
const char utl_quatro_dates                   = $UTILS_BASE:utl_quatro_dates
const char utl_half_year_dates                = $UTILS_BASE:utl_half_year_dates
const char utl_year_dates                     = $UTILS_BASE:utl_year_dates
const char utl_leap_boundary_dates            = $UTILS_BASE:utl_leap_boundary_dates

const char utl_operations_def                 = $UTILS_BASE:utl_operations_def
const char utl_operations_spc                 = $UTILS_BASE:utl_operations_spc
const char utl_operations_accnts              = $UTILS_BASE:utl_operations_accnts
const char utl_operations_accnts_spc          = $UTILS_BASE:utl_operations_accnts_spc


;> ============================================================================
;> Operations
;> ============================================================================

; -----------------------------------------------------------------------------
; массовые операции (как правило над счетами в конце года)
; -----------------------------------------------------------------------------
[UTL_Operations_Def]
const char main_class=DB_Kstat
const char read_access=any
const char update_access=PLACE_UK_OPERATIONS
const char insert_access=PLACE_UK_OPERATIONS
const char delete_access=PLACE_UK_OPERATIONS
const char mode=sidur
const char ks_table=$utl_operations_def
const char ks_keys=c_operation
const char serial=c_operation
const char ks_where=$BRANCH_WHERE_OBJ
const char ks_defaults=\
#{";"
  c_branch:@BranchSelect.c_branch
  op_day:@today
  c_accnt_common:0
  comment:
  comment_order:
  last_number:0
  state:$OPERATION_STATE_NEW
#}

const char foreigns=\
#{";"
  AccntCommon(Accnt):c_accnt_common(c_accnt)
  State(uk_main::UK_Abbrs_Operation_States):state(type)
#}

const char references=\
#{";"
  Spcs($CURCFG::UTL_Operations_Spc):c_operation
  Accnts($CURCFG::UTL_Operations_Accnts):c_operation
#}

const char spc_codes=\
#{";"
  $spc_operation_do_spc (<@_operation_do_spc (c_operation,op_day,last_number)>):#P_operation_do_spc_parms
#}

;> ----------------------------------------------------------------------------
;> __operation_do_spc
;> ----------------------------------------------------------------------------
const char _operation_do_spc_parms=_spc_code,_number,_spc_rollback
const char _operation_do_spc=\
#{
  $LONG(_today) _today = Otoday();
  (@@_today == @@op_day)
      ? 0
      : RaiseError(-1, "Для обработки операции необходимо выбрать опер. день [" + rfmtdate(@@op_day, "dd.mm.yyyy") + "].");

  $LONG(_c_accnt_spc)
  CURSOR
    select c_accnt_spc into ?_c_accnt_spc
    from $utl_operations_accnts
    where
      c_operation = @c_operation
    : call("$CURCFG::$CURSEC:_operation_accnt_do_spc", @@c_operation, @@_c_accnt_spc, @@_spc_code, @@_number, @@_spc_rollback);



; -------------------------------------
; меняем у всей операции в зависимости от номера spc
; ...
; -------------------------------------
  $LONG(_state)
  
  SQL
    select state into ?_state
    from $utl_operations_spc
    where
      c_operation = @c_operation and
      number      = @last_number;

  _coll_operation_update=Auth.obj_by_name("<null>", "DB_Coll");
  @_coll_operation_update.ClearNames();
    @_coll_operation_update.AssignVarLong("state", @@_state);

  @THIS.DoUpdateForColl(@@_coll_operation_update);
  
  Auth.delete_obj_by_name(@@_coll_operation_update);
#}

;> ----------------------------------------------------------------------------
;> __operation_accnt_do_spc
;> ----------------------------------------------------------------------------
const char _operation_accnt_do_spc_parms=_c_operation,_c_accnt_spc,_spc_code,_number,_spc_rollback
const char _operation_accnt_do_spc=\
#{
; -------------------------------------
; проверяем наличии записи, если уже есть - то считаем счет обработанным и просто выходим
; -------------------------------------
  $LONG(_count_spc)
  SQL
    select count(*) into ?_count_spc
    from $utl_operations_accnts_spc
    where
      c_operation = @_c_operation and
      c_accnt_spc = @_c_accnt_spc and
      spc_code    = @_spc_code;

  (@@_count_spc == 0)
      ? 0
      : return(0);

; -------------------------------------
; выполянем spc над счетом
; -------------------------------------
  _coll_accnt_params=Auth.obj_by_name("<null>", "DB_Coll");
  @_coll_accnt_params.ClearNames();
    @_coll_accnt_params.AssignVarLong("_spc_rollback",  @@_spc_rollback);

  $CURCFG::UTL_Operations_Accnts.SetKeyLong("c_operation", @@_c_operation);
  $CURCFG::UTL_Operations_Accnts.SetKeyLong("c_accnt_spc", @@_c_accnt_spc);
  $CURCFG::UTL_Operations_Accnts.DoSpc(@@_spc_code, @@_coll_accnt_params);

  Auth.delete_obj_by_name(@@_coll_accnt_params);
#}



[UTL_Operations_Spc]
const char main_class=DB_Kstat
const char read_access=any
const char update_access=PLACE_UK_OPERATIONS
const char insert_access=PLACE_UK_OPERATIONS
const char delete_access=PLACE_UK_OPERATIONS
const char mode=sidur
const char ks_table=$utl_operations_spc
const char ks_keys=c_operation,number
const char ks_defaults=\
#{";"
  number:0
  comment:
  spc_code:0
  spc_kind:$SPC_KIND_NORMAL
  spc_rollback:0
  state:$OPERATION_STATE_NEW
#}

const char foreigns=\
#{";"
  State(uk_main::UK_Abbrs_Operation_States):state(type)
  Spc(uk_main::UK_Abbrs_Operation_Spcs):spc_code(type)
  SpcRollback(uk_main::UK_Abbrs_Operation_Spcs):spc_rollback(type)
  Kind(uk_main::UK_Abbrs_Spc_Kinds):spc_kind(type)
#}

const char spc_codes=\
#{";"
  $spc_operation_do_spc (<@_operation_do_spc (c_operation,number,_spc_code=spc_code,spc_kind,spc_rollback)>)
#}

;> ----------------------------------------------------------------------------
;> __operation_do_spc
;> ----------------------------------------------------------------------------
const char _operation_do_spc=\
#{
  _coll_params=Auth.obj_by_name("<null>", "DB_Coll");


; -------------------------------------
; меняем состояние
; -------------------------------------
  @_coll_params.ClearNames();
    @_coll_params.AssignVarLong("state", $OPERATION_STATE_PERFORMED);

  (@@spc_kind == $SPC_KIND_NORMAL)
      ? @THIS.DoUpdateForColl(@@_coll_params)
      : 0;

; -------------------------------------
; выполняем spc над всей операцией
; -------------------------------------
  @_coll_params.ClearNames();
    @_coll_params.AssignVarLong("_spc_code",      @@_spc_code);
    @_coll_params.AssignVarLong("_number",        @@number);
    @_coll_params.AssignVarLong("_spc_rollback",  @@spc_rollback);
  $CURCFG::UTL_Operations_Def.SetKeyLong("c_operation", @@c_operation);
  $CURCFG::UTL_Operations_Def.DoSpc($spc_operation_do_spc, @@_coll_params);

  Auth.delete_obj_by_name(@@_coll_params);
#}



[UTL_Operations_Accnts]
const char main_class=DB_Kstat
const char read_access=any
const char update_access=PLACE_UK_OPERATIONS
const char insert_access=PLACE_UK_OPERATIONS
const char delete_access=PLACE_UK_OPERATIONS
const char mode=sidur
const char ks_table=$utl_operations_accnts
const char ks_keys=c_operation,c_accnt_spc
const char ks_defaults=\
#{";"
  comment:
  c_accnt_spc:0
  c_accnt_linked:0
#}

const char foreigns=\
#{";"
  Operation($CURCFG::UTL_Operations_Def):c_operation
  AccntSpc(Accnt):c_accnt_spc(c_accnt)
  AccntLinked(Accnt):c_accnt_linked(c_accnt)
  Order_MoveRest_Linked($CURCFG::UTL_Operations_Accnts_Spcs):c_operation,c_accnt_spc,'$spc_operation_move_rest_to_linked_accnt'(spc_code)
  Order_MoveRest_Common($CURCFG::UTL_Operations_Accnts_Spcs):c_operation,c_accnt_spc,'$spc_operation_move_rest_to_common_accnt'(spc_code)
#}

const char synonyms=\
#{";"
  _c_order[LONG]             =?/Order_MoveRest_Linked.Order.c_order,Order_MoveRest_Common.Order.c_order/(@Order_MoveRest_Linked.Order.c_order + @Order_MoveRest_Common.Order.c_order);
  _rest2_accnt_spc[MONEY]    =?/AccntSpc.RestRUR.debit2,AccntSpc.RestRUR.credit2/(@AccntSpc.RestRUR.debit2-@AccntSpc.RestRUR.credit2)
  _rest2_accnt_linked[MONEY] =?/AccntLinked.RestRUR.debit2,AccntLinked.RestRUR.credit2/(@AccntLinked.RestRUR.debit2-@AccntLinked.RestRUR.credit2)
#}

;> ----------------------------------------------------------------------------
;> __spc_codes
;> ----------------------------------------------------------------------------
const char spc_codes=\
#{
; -------------------------------------
; перенос остатков (2 spc)
; -------------------------------------
  $spc_operation_create_linked_accnt        (<@_create_linked_accnt (
                                                                      c_operation,c_accnt_spc,
                                                                        _naccnt=AccntSpc.naccnt,
                                                                        _c_nsymbf2_f5=AccntSpc.c_nsymbf2_f5,
                                                                        _ndep=AccntSpc.ndep,
                                                                        _nukind=AccntSpc.nukind,
                                                                        _acckind=AccntSpc.acckind,
                                                                        _c_branch=AccntSpc.c_branch,
                                                                        _nsubacc=AccntSpc.nsubacc,
                                                                        _access=AccntSpc.access,
                                                                        _name=AccntSpc.AccntName.name,
                                                                      _spc_check=$_FALSE
                                                                    )
                                            >);
  $spc_operation_move_rest_to_linked_accnt  (<@_move_rest_to (
                                                                c_operation,c_accnt_spc,
                                                                  _c_accnt_move=c_accnt_linked,
                                                                  _ap=AccntSpc.NPL.type,
                                                                  _debit2=AccntSpc.RestRUR.debit2,
                                                                  _credit2=AccntSpc.RestRUR.credit2,
                                                                  _op_day=Operation.op_day,
                                                                  _comment=Operation.comment_order,
                                                                _spc_check=$spc_operation_create_linked_accnt
                                                             )
                                            >);
  $spc_operation_move_rest_to_common_accnt  (<@_move_rest_to (
                                                                c_operation,c_accnt_spc,
                                                                  _c_accnt_move=Operation.c_accnt_common,
                                                                  _ap=AccntSpc.NPL.type,
                                                                  _debit2=AccntSpc.RestRUR.debit2,
                                                                  _credit2=AccntSpc.RestRUR.credit2,
                                                                  _op_day=Operation.op_day,
                                                                  _comment=Operation.comment_order,
                                                                _spc_check=$_FALSE
                                                             )
                                            >);
  $spc_operation_rollback_moving_rest  (<@_rollback_moving_rest (
                                                                  c_operation,c_accnt_spc,
                                                                  _spc_check=$spc_operation_move_rest_to_linked_accnt,
                                                                  _c_order
                                                                )
                                       >):#P_rollback_moving_rest_parms;
  
  $spc_operation_rollback_linked_accnt (<@_rollback_creating_accnt (
                                                                      c_operation,c_accnt_spc,
                                                                      _spc_check=$spc_operation_create_linked_accnt
                                                                   )
                                       >):#P_rollback_creating_accnt_parms;
#}


;> ----------------------------------------------------------------------------
;> __move_rest_to
;    !!! c_dogovor для произвольного договора вынести в настройки !!!
;> ----------------------------------------------------------------------------
const char _move_rest_to=\
#{
; -------------------------------------
; проверка
; -------------------------------------
  call("$CURCFG::$CURSEC:_check_accnt_for_previous_spc", @@c_operation, @@c_accnt_spc, @@_spc_check, $_TRUE);

  $MONEY(_isum)
    _isum = @@_debit2 + @@_credit2;

  (@@_isum == 0)
      ? return(0)
      : 0;

; -------------------------------------
; в зависимости от типа счета, вычисляем дебет и кредит
; -------------------------------------
  $CHAR(_attr_accnt_spc,_attr_accnt_move)
    _attr_accnt_spc   = (@@_ap == $ACCNT_TYPE_ACTIVE) ? "_c_accnt_c" : "_c_accnt_d";
    _attr_accnt_move  = (@@_ap == $ACCNT_TYPE_ACTIVE) ? "_c_accnt_d" : "_c_accnt_c";


; -------------------------------------
; формируем простое распоряжение
; -------------------------------------
  _coll_ext=Auth.obj_by_name("<null>", "DB_Coll");
    @_coll_ext.AssignVarLong("_c_order", 0);

  _coll_params=Auth.obj_by_name ("<null>", "DB_Coll");
    @_coll_params.AssignVarLong   (@@_attr_accnt_spc,  @@c_accnt_spc);
    @_coll_params.AssignVarLong   (@@_attr_accnt_move, @@_c_accnt_move);
    @_coll_params.SetVarMoney     ("_isum",            @@_isum);
    @_coll_params.AssignVarDate   ("_op_day",          @@_op_day);
    @_coll_params.AssignVarString ("_comment",         @@_comment);
    @_coll_params.AssignVarString ("_coll_ext",        @@_coll_ext);
  uk_main::UK_Dogovors_All.SetKeyLong("c_dogovor", $C_DOGOVOR_SIMPLE);
  uk_main::UK_Dogovors_All.DoSpc($spc_ordercreate_simple, @@_coll_params);
  

; -------------------------------------
; проводим распоряжение
; -------------------------------------
  $LONG(_c_order)
    @_coll_ext.SomeVarsToColl("_c_order", CURRENT.get_name(), "_c_order");


  uk_main::UK_Orders_Def.SetKeyLong("c_order", @@_c_order);
  uk_main::UK_Orders_Def.DoSpc($spc_uk_orders_performed_full, "<null>");

; -------------------------------------
; сохраняем информацию о нём
; -------------------------------------
  call("$CURCFG::cmds:_insert_operation_accnt_spc", @@c_operation, @@c_accnt_spc, @@spc_code, @@_c_order);
  
  Auth.delete_obj_by_name(@@_coll_ext);
  Auth.delete_obj_by_name(@@_coll_params);
#}


;> ----------------------------------------------------------------------------
;> __create_linked_accnt
;> ----------------------------------------------------------------------------
const char _create_linked_accnt=\
#{
  call("$CURCFG::$CURSEC:_check_accnt_for_previous_spc", @@c_operation, @@c_accnt_spc, @@_spc_check, $_TRUE);

  _coll_ext=Auth.obj_by_name("<null>", "DB_Coll");

; -------------------------------------
; создаем счет
; -------------------------------------
  $LONG(_c_accnt,_c_naccnt)
    _naccnt = @@_naccnt + 1000;
    _c_naccnt = call("$CURCFG::UserUtils:_get_c_naccnt_by_naccnt", @@_naccnt, @@_coll_ext);
    _c_accnt  = call("$CURCFG::UserUtils:_insert_new_accnt", $CURR_ROUBLE, @@_c_branch, @@_c_naccnt, @@_c_nsymbf2_f5, @@_ndep, @@_nukind, @@_nsubacc,
                                                             @@_access, @@_name, "", "", "", 0, 0, "AccntProfexp", @@_coll_ext);
  Auth.delete_obj_by_name(@@_coll_ext);


; -------------------------------------
; обновляем текущую запись
; -------------------------------------
  _coll_update=Auth.obj_by_name("<null>", "DB_Coll");
    @_coll_update.AssignVarLong("c_accnt_linked", @@_c_accnt);
  @THIS.DoUpdateForColl(@@_coll_update);

  Auth.delete_obj_by_name(@@_coll_update);

; -------------------------------------
; меняем состояние у текущего счета
; -------------------------------------
  call("$CURCFG::cmds:_insert_operation_accnt_spc", @@c_operation, @@c_accnt_spc, @@spc_code, 0);
#}

;> ----------------------------------------------------------------------------
;> __check_accnt_for_previous_spc
;> ----------------------------------------------------------------------------
const char _check_accnt_for_previous_spc_parms=_c_operation,_c_accnt_spc,_spc_check,_is_error
const char _check_accnt_for_previous_spc=\
#{
  $LONG(_is_performed)
  SQL
    select count(*) into ?_is_performed
    from $utl_operations_accnts_spc
    where
      c_operation = @_c_operation and
      c_accnt_spc = @_c_accnt_spc and
      spc_code    = @_spc_check;

  (@@_is_error == $_FALSE)
      ? return(0)
      : 0;

   ((@@_is_performed == 1) || (@@_spc_check == $_FALSE))
      ? 0
      : RaiseError(-1, "По данному счету не была выполнена предыдущая операция!");
#}

;> ----------------------------------------------------------------------------
;> __rollback_moving_rest
;> ----------------------------------------------------------------------------
const char _rollback_moving_rest_parms=_spc_rollback
const char _rollback_moving_rest=\
#{
  call("$CURCFG::$CURSEC:_check_accnt_for_previous_spc",  @@c_operation, @@c_accnt_spc, @@_spc_check, $_FALSE);
  call("$CURCFG::cmds:_delete_operation_accnt_spc",       @@c_operation, @@c_accnt_spc, @@_spc_rollback);

  (@@_c_order == 0)
      ? return(0)
      : 0;

  uk_main::UK_Orders_Def.SetKeyLong("c_order", @@_c_order);
  uk_main::UK_Orders_Def.DoSpc($spc_uk_orders_performed_full_rollback, "<null>");
  uk_main::UK_Orders_Def.DoSpc($spc_uk_orders_delete, "<null>");
#}

;> ----------------------------------------------------------------------------
;> __rollback_creating_accnt
;> ----------------------------------------------------------------------------
const char _rollback_creating_accnt_parms=_spc_rollback
const char _rollback_creating_accnt=\
#{
  return(0);
#}



; -----------------------------------------------------------------------------
; наличие записи означает что процедура уже(!) была произведена над счетом
; (самое главное - избежать дублирования!!!)
; -----------------------------------------------------------------------------
[UTL_Operations_Accnts_Spcs]
const char main_class=DB_Kstat
const char read_access=any
const char update_access=PLACE_UK_OPERATIONS
const char insert_access=PLACE_UK_OPERATIONS
const char delete_access=PLACE_UK_OPERATIONS
const char mode=sidur
const char ks_table=$utl_operations_accnts_spc
const char ks_keys=c_operation,c_accnt_spc,spc_code
const char ks_defaults=\
#{";"
  c_order:0
#}

const char foreigns=\
#{";"
  Order(uk_main::UK_Orders):c_order
#}

[cmds]

;> ----------------------------------------------------------------------------
;> __insert_operation_accnt_spc
;> ----------------------------------------------------------------------------
const char _insert_operation_accnt_spc_parms=_c_operation,_c_accnt_spc,_spc_code,_c_order
const char _insert_operation_accnt_spc=\
#{
  _coll_oper_accnt_spc=Auth.obj_by_name("<null>", "DB_Coll");
    @_coll_oper_accnt_spc.AssignVarLong("c_operation",  @@_c_operation);
    @_coll_oper_accnt_spc.AssignVarLong("c_accnt_spc",  @@_c_accnt_spc);
    @_coll_oper_accnt_spc.AssignVarLong("spc_code",     @@_spc_code);
    @_coll_oper_accnt_spc.AssignVarLong("c_order",      @@_c_order);
  $CURCFG::UTL_Operations_Accnts_Spcs.DoInsertForColl(@@_coll_oper_accnt_spc);
  Auth.delete_obj_by_name(@@_coll_oper_accnt_spc);
#}

;> ----------------------------------------------------------------------------
;> __delete_operation_accnt_spc
;> ----------------------------------------------------------------------------
const char _delete_operation_accnt_spc_parms=_c_operation,_c_accnt_spc,_spc_code
const char _delete_operation_accnt_spc=\
#{
    $CURCFG::UTL_Operations_Accnts_Spcs.SetKeyLong("c_operation", @@_c_operation);
    $CURCFG::UTL_Operations_Accnts_Spcs.SetKeyLong("c_accnt_spc", @@_c_accnt_spc);
    $CURCFG::UTL_Operations_Accnts_Spcs.SetKeyLong("spc_code",    @@_spc_code);
  $CURCFG::UTL_Operations_Accnts_Spcs.DoDelete();


  $LONG(_number_for_rollback,_state)
  SQL
    select number, state into ?_number_for_rollback, ?_state
    from $utl_operations_spc
    where
      c_operation = @_c_operation and
      spc_code    = @_spc_code;

  (@@_state == $OPERATION_STATE_NEW)
      ? return(0)
      : 0;

  _coll_operation_spc=Auth.obj_by_name("<null>", "DB_Coll");
  @_coll_operation_spc.ClearNames();
  @_coll_operation_spc.AssignVarLong("state", $OPERATION_STATE_NEW);


  $CURCFG::UTL_Operations_Spc.SetKeyLong("c_operation", @@_c_operation);
  $CURCFG::UTL_Operations_Spc.SetKeyLong("number",      @@_number_for_rollback);
  $CURCFG::UTL_Operations_Spc.DoUpdateForColl(@@_coll_operation_spc);

  Auth.delete_obj_by_name(@@_coll_operation_spc);

#}


;> ============================================================================
;> misc
;> ============================================================================

; -----------------------------------------------------------------------------
; справочный объект с да/нет
; -----------------------------------------------------------------------------
[Boolean_TRUE]
long _type   = $_TRUE
char _value  = "Да"
                            
[Boolean_FALSE]
long _type   = $_FALSE
char _value  = "Нет"

[UTL_Booleans]
const char main_class  = DB_Cfgcur
const char ks_keys     = _type
const char read_access = any
const char file        = $CURCFG
const char fields      = _type,_value

const char sections=\
#{","
   Boolean_TRUE
   Boolean_FALSE
#}

; -----------------------------------------------------------------------------
; справочный объект с годами
; -----------------------------------------------------------------------------
[UTL_Years]
const char main_class=DB_Kstat
const char read_access=any
const char mode=sr
const char ks_table=$utl_year_dates
const char ks_keys=cfdoy
const synonyms=\
#{";"
  _year_idx[LONG]=?/cfdom/long(rfmtdate(@cfdoy, "yyyy"))
  _year_name[4]=?/cfdom/rfmtdate(@cfdoy, "yyyy")
#}

; -----------------------------------------------------------------------------
; справочный объект с кварталами
; -----------------------------------------------------------------------------
[Quarter_1]
long _quarter_idx = 1
char _quarter_name = "I"
                            
[Quarter_2]
long _quarter_idx = 2
char _quarter_name = "II"

[Quarter_3]
long _quarter_idx = 3
char _quarter_name = "III"

[Quarter_4]
long _quarter_idx = 4
char _quarter_name = "IV"

[UTL_Quarters]
const char main_class  = DB_Cfgcur
const char ks_keys     = _quarter_idx
const char read_access = any
const char file        = $CURCFG
const char fields      = _quarter_idx,_quarter_name

const char sections=\
#{","
   Quarter_1
   Quarter_2
   Quarter_3
   Quarter_4
#}

[Month_01]
long _month_idx = 1
char _month_name = "Январь"

[Month_02]
long _month_idx = 2
char _month_name = "Февраль"

[Month_03]
long _month_idx = 3
char _month_name = "Март

[Month_04]
long _month_idx = 4
char _month_name = "Апрель"

[Month_05]
long _month_idx = 5
char _month_name = "Май"

[Month_06]
long _month_idx = 6
char _month_name = "Июнь"

[Month_07]
long _month_idx = 7
char _month_name = "Июль"

[Month_08]
long _month_idx = 8
char _month_name = "Август"

[Month_09]
long _month_idx = 9
char _month_name = "Сентябрь"

[Month_10]
long _month_idx = 10
char _month_name = "Октябрь"

[Month_11]
long _month_idx = 11
char _month_name = "Ноябрь"

[Month_12]
long _month_idx = 12
char _month_name = "Декабрь"


; -----------------------------------------------------------------------------
; справочный объект с месяцами
; -----------------------------------------------------------------------------
[UTL_Months]
const char main_class  = DB_Cfgcur
const char ks_keys     = _month_idx
const char read_access = any
const char file        = $CURCFG
const char fields      = _month_idx,_month_name

const char sections=\
#{","
   Month_01
   Month_02
   Month_03
   Month_04
   Month_05
   Month_06
   Month_07
   Month_08
   Month_09
   Month_10
   Month_11
   Month_12
#}

[cmds]
;> ----------------------------------------------------------------------------
;> __get_count_of_typed_days_in_clddays
;> ----------------------------------------------------------------------------
const char _get_count_of_typed_days_in_clddays_parms=_clddays,_subst
const char _get_count_of_typed_days_in_clddays=\
#{
  $CHAR(_clddays_subst)
    _clddays_subst = subst(@@_subst, @@_clddays);

  $LONG(_count)
    _count = strlen(@@_clddays_subst);

  return(@@_count);
#}

;> ----------------------------------------------------------------------------
;> __set_isum_with_history
;> ----------------------------------------------------------------------------
const char _set_isum_with_history_parms=_tbl_name,_key_name,_key_value,_isum_type,_isum,_date0,_date1
const char _set_isum_with_history=\
#{
; -------------------------------------
; 1) удаляем всё, что старше даты изменения
; -------------------------------------
  SQL delete from @_tbl_name where @_key_name = @_key_value and isum_type = @_isum_type and prev_change between @_date0 and @_date1;

; -------------------------------------
; 2) обрубаем вторую дату с историей
; -------------------------------------
  $LONG(_prev_change)
  -SQL select max(prev_change) into ?_prev_change from @_tbl_name where @_key_name = @_key_value and isum_type = @_isum_type;
  _prev_change = isnull(@@_prev_change) ? 0 : @@_prev_change;

  SQL update @_tbl_name set next_change = @_date0 - 1 where @_key_name = @_key_value and isum_type = @_isum_type and prev_change = @_prev_change;

; -------------------------------------
; 3) вставляем новое значение с даты его изменения
; -------------------------------------
  SQL
    insert into @_tbl_name (@_key_name, isum_type,    isum,   prev_change, next_change)
                    values (@_key_value, @_isum_type, @_isum, @_date0,     @_date1);

#}



;> ----------------------------------------------------------------------------
;> __addStringWithSep
;> ----------------------------------------------------------------------------
const char addStringWithSep_parms=_source,_s,_separator
const char addStringWithSep=\
#{
  (@@_source == "")
    ? return(@@_s)
    : return(@@_source + @@_separator + @@_s);
#}

;> ----------------------------------------------------------------------------
;> __calcAnalytRSNecurrac
;> ----------------------------------------------------------------------------
const char calcAnalytRSNecurrac_parms=\
#{","
  c_accnt
  c_curr
  card_acc
  client
  necurracc
  naccnt
  nsubacc
  curr_okw
  key_digit
  is_analit_accnt
#}
const char calcAnalytRSNecurrac=\
#{
  (@@is_analit_accnt == $_FALSE)
      ? return(" ")
      : 0;

; проверка обязательных аттрибутов для вычисления аналитического счета
  c_curr   = (isnull(@@c_curr)   ? 0 : @@c_curr);
  c_accnt  = (isnull(@@c_accnt)  ? 0 : @@c_accnt);
  card_acc = (isnull(@@card_acc) ? 0 : @@card_acc);
  ((@@c_curr==0)||(@@c_accnt==0)||(@@card_acc==0)) ? return(" ") : 0;

; в случае если счет не мультиклиентский - возвращать обычный 20-ти символьный счет
  (@@client!=$ACCKIND_CLIENT_MULTI) ? return(@@necurracc) : 0;

; т.к. в аналитическом счете субсчет счета - последние _ДВЕ_ цифры
; (приказ президента банка N419/ОД от 17.07.2007),
; то возможны накладки связанные с уникальностью аналитического счета
  (@@nsubacc > 99) ? RaiseError(-1,"Субсчет сводного счета " + string(@@necurracc) +
                                   " больше 99 - возможны накладки!!!","") : 0;


  $CHAR(analit_necurracc,NCECURRACC_PATTERN_MC)
  NCECURRACC_PATTERN_MC="AAAAACCC@@70NNPPPPPSS,B_AAAAACCC@@70NNPPPPPSS,1_71371371371371371371";
  analit_necurracc=CurrentAccntPrepare(@@NCECURRACC_PATTERN_MC,
                                       "A:@naccnt,C:@curr_okw,N:$NDEP_CURRENT,P:@card_acc,S:@nsubacc,b:@key_digit");
  return(@@analit_necurracc);
#}

;> ----------------------------------------------------------------------------
;> __getObjectInfo_To_Current
;> ----------------------------------------------------------------------------
const char getObjectInfo_To_Current_parms=_obj_name,\
                                          _key_name1,_key_value1,\
                                          _key_name2,_key_value2,\
                                          _vars_current,_vars_obj
const char getObjectInfo_To_Current=\
#{
; -------------------------------------
; встаем на нужную запись (пока ключ - одно поле)
; -------------------------------------
  @_obj_name.SetKeyLong("@_key_name1", @@_key_value1);
  @_obj_name.SetKeyLong("@_key_name2", @@_key_value2);


  coll_select=Auth.obj_by_name("<null>", "DB_Coll");
  CURRENT.SomeVarsToColl("@_vars_current", @@coll_select, "@_vars_obj");
  @_obj_name.DoSelectForColl(@@coll_select);
  @coll_select.SomeVarsToColl("@_vars_obj", CURRENT.get_name(), "@_vars_current");
  Auth.delete_obj_by_name(@@coll_select);
#}


;> ----------------------------------------------------------------------------
;> __add_curr_to_accnt
;> ----------------------------------------------------------------------------
const char add_curr_to_accnt_parms=_c_accnt,_c_curr,_rate_kind
const char add_curr_to_accnt=\
#{
  _coll_accnt_curr=Auth.obj_by_name("<null>", "DB_Coll");
      @_coll_accnt_curr.ClearNames();
      @_coll_accnt_curr.AssignVarLong("c_accnt", @@_c_accnt);
      @_coll_accnt_curr.AssignVarLong("c_curr",  @@_c_curr);

; -------------------------------------
; в этом случае рубли добавляются автоматически
; поэтому просто устанавливаем ключи на нужную запись,
; т.к. после вызова возможно чтение каких-либо аттрибутов
; -------------------------------------
  (@@_rate_kind == $NO_RATE)
      ? accnt::AccntCurr.KeysFromCollection(@@_coll_accnt_curr)
      : accnt::AccntCurr.ValidateInsertForColl(@@_coll_accnt_curr);

  (@@_rate_kind == $NO_RATE)
      ? 0
      : accnt::AccntCurr.DoInsertForColl(@@_coll_accnt_curr);
  Auth.delete_obj_by_name(@@_coll_accnt_curr);
#}



[]

; типы отчетных групп
template [Abbrs_Tmpl]
const char main_class  = DB_Cfgcur
const char ks_keys     = type
const char read_access = any
const char file        = $CURCFG
const char fields      = type,name,abbr


;> ----------------------------------------------------------------------------
;> Reports
;> ----------------------------------------------------------------------------

[UniReports]

; =============================================================================
; используется в таблицах вида: [...reports]
; =============================================================================
[ReportGroup1]
long type = 750
char name = Оператор
char abbr = REPORT_GROUP_OPER

[ReportGroup2]
long type = 752
char name = Руководство
char abbr = REPORT_GROUP_DIRECTOR

[ReportGroup3]
long type = 754
char name = Бухгалтерия
char abbr = REPORT_GROUP_BUH

[ReportGroup4]
long type = 755
char name = Валютный контроль
char abbr = REPORT_GROUP_VC

[ReportGroup5]
long type = 756
char name = ПЭУ
char abbr = REPORT_GROUP_PEU

[ReportGroup6]
long type = 758
char name = МСФО
char abbr = REPORT_GROUP_MSFO


[ReportGroups] default: Abbrs_Tmpl
const char sections=\
#{","
   ReportGroup1
   ReportGroup2
   ReportGroup3
   ReportGroup4
   ReportGroup5
   ReportGroup6
#}

;==============================================================================
; используется в таблицах вида: [...reports]
;==============================================================================
[ReportState1]
long type = 780
char name = Активный
char abbr = REPORT_STATE_ENABLED

[ReportState2]
long type = 782
char name = Редко используемый
char abbr = REPORT_STATE_RARE

[ReportState3]
long type = 784
char name = В разработке
char abbr = REPORT_STATE_DELIVERED

[ReportState4]
long type = 786
char name = Неиспользуемый
char abbr = REPORT_STATE_DELETED

[ReportStates] default: Abbrs_Tmpl
const char sections=\
#{","
   ReportState1
   ReportState2
   ReportState3
   ReportState4
#}

; =============================================================================
; 
; =============================================================================
[]
const long spcUserRight_CORR_ACCNTS             = 14000
const long spcUserRight_EXCHINT                 = 14001
const long spcUserRight_CHIEF_ACCOUNTANT_REPORT = 14002
const long spcUserRight_CONS_REP                = 14003


[UserUtils]
const char main_class=DB_Cfgcur
char read_access=any
char update_access=any
char sections=$CURCFG::$CURSEC

;> ----------------------------------------------------------------------------
;> __spc_codes
;> ----------------------------------------------------------------------------
const char spc_codes=\
#{";"
; -------------------------------------
;  $spcUserRight_CORR_ACCNTS             (@_check_user_right):PLACE_CORR_ACCNT
;  $spcUserRight_EXCHINT                 (@_check_user_right):PLACE_EXCHINT_CHIEF|PLACE_EXCHINT_CASHIER
;  $spcUserRight_CHIEF_ACCOUNTANT_REPORT (@_check_user_right):PLACE_CHIEF_ACCOUNTANT_REPORT
;  $spcUserRight_CONS_REP                (@_check_user_right):PLACE_CONS_REP|PLACE_CONS_REPX
;
;
;  $spc_set_current_corr   (<@_set_current_corr>):PLACE_CORR_ACCNT#P_set_current_corr_parms
; -------------------------------------
  $spc_set_current_branch (<@_set_current_branch>):#P_set_current_branch_parms
  $spc_set_accnt_rest0 (<@_set_accnt_rest0>):#P_set_accnt_rest0_parms
  $spc_get_last_nsubacc (<@_get_last_nsubacc>):#P_get_last_nsubacc_parms
  $spc_insert_accnt (<@_insert_accnt>):#P_insert_accnt_parms
  $spc_update_accnt (<@_update_accnt>):#P_update_accnt_parms
  $spc_get_c_naccnt_by_naccnt (<@_get_c_naccnt_by_naccnt>):#P_get_c_naccnt_by_naccnt_parms
  $spc_ordercreate_employee_pay_monthly_ensurance (<@_employee_pay_monthly_ensurance>):#P_employee_pay_monthly_ensurance_parms
  $spc_ordercreate_employee_pay_ndfl (<@_employee_pay_ndfl>):#P_employee_pay_ndfl_parms
  $spc_dublicate_schema_for_order_type (<@_dublicate_schema_for_order_type>):#P_dublicate_schema_for_order_type_parms
  $spc_get_branch_setting_accnt (<@_get_branch_setting_accnt>):#P_get_branch_setting_accnt_parms
  $spc_open_all_days_for_period (<@_open_all_days_for_period>):#P_open_all_days_for_period_parms
  $spc_open_one_day (<@_open_one_day>):#P_open_one_day_parms
#}

;> ----------------------------------------------------------------------------
;> __test
;> ----------------------------------------------------------------------------
const char _test=\
#{
  $LONG(_c_accnt)
  $MONEY(_credit1)

  CURSOR
    select a.c_accnt, s.isum into ?_c_accnt, ?_credit1
    from $uk_orders_def o
    where
      o.order_type = $ORDER_TYPE_EMPLOYEE_RESERV_INCREASE and
      o.state <> $ORDER_STATE_DELETED and
      o.op_day = '09.01.2017'
    : call("$CURCFG::$CURSEC:_update_turnovers", @@_c_accnt, @@_credit1);
#}


;> ----------------------------------------------------------------------------
;> __open_all_days_for_period
;> ----------------------------------------------------------------------------
const char _open_all_days_for_period_parms=\
#{
  _date0:Начало периода#Tdate_t
  _date1:Окончание периода#Tdate_t
#}
const char _open_all_days_for_period=\
#{
  _coll_params=Auth.obj_by_name("<null>", "DB_Coll");
    @_coll_params.ClearNames();
    @_coll_params.AssignVarLong("_is_error", $_FALSE);

  $LONG(_op_day)
    _op_day = long(@@_date0);

  while("@@_op_day <= long(@@_date1)", ConfigGetString("$CURCFG::$CURSEC:_open_one_day_from_period"));

  Auth.delete_obj_by_name(@@_coll_params);

  RaiseError(-1, "success", "");
#}

;> ----------------------------------------------------------------------------
;> __open_one_day_from_period
;> ----------------------------------------------------------------------------
const char _open_one_day_from_period=\
#{
  @_coll_params.AssignVarLong("_op_day", @@_op_day);
  @THIS.DoSpc($spc_open_one_day, @@_coll_params);

  _op_day = @@_op_day + 1;
#}


;> ----------------------------------------------------------------------------
;> __open_one_day
;> ----------------------------------------------------------------------------
const char _open_one_day_parms=\
#{";"
  _op_day:Опер. день#Tlong_t
  _is_error:Вывод ошибки#Tlong_t
#}
const char _open_one_day=\
#{
; -------------------------------------
; проверка на то, что день уже был открыт
; -------------------------------------
  $LONG(_count)

  SQL select count(*) into ?_count from opdays where op_day = @_op_day;
  (@@_count > 0)
      ? (@@_is_error == $_TRUE)
          ? RaiseError(-1, "Опер. день [" + rfmtdate(@@_op_day, "dd.mm.yyyy") + "] уже был открыт ранее!" , "")
          : return(0)
      : 0;

; -------------------------------------
; проверка на то, что не заведен календарь
; -------------------------------------
  $LONG(_month,_day,_year)
    rjulmdy(@@_op_day, "_month",  "_day", "_year");

  SQL select count(*) into ?_count from calendar where cldyear = @_year and cldmonth = @_month;
  (@@_count == 0)
      ? (@@_is_error == $_TRUE)
          ? RaiseError(-1, "Опер. день [" + rfmtdate(@@_op_day, "dd.mm.yyyy") + "] находится в месяце, на который не был заведен календарь!" , "")
          : return(0)
      : 0;

; -------------------------------------
; проверка на то, что опер. день попадает на выходной
; -------------------------------------
  $CHAR(_clddays,_day_letter)
  SQL select clddays into ?_clddays from calendar where cldyear = @_year and cldmonth = @_month;

  _day_letter = substr(@@_clddays, (@@_day-1), 1);
  (@@_day_letter == "h")
      ? (@@_is_error == $_TRUE)
          ? RaiseError(-1, "На опер. день [" + rfmtdate(@@_op_day, "dd.mm.yyyy") + "] приходится выходной день. Необходимо поменять календарь!" , "")
          : return(0)
      : 0;

; -------------------------------------
; вставляем данные
; -------------------------------------
  SQL insert into opdays (op_day, state, wstate4, wstate5, to2_state, nto2_state, close_user, wclose4_user, wclose5_user)
                  values (@_op_day, $DAY_STATE_OPEN, $DAY_STATE_OPEN, $DAY_STATE_OPEN, $DAY_STATE_OPEN, $DAY_STATE_OPEN, 0, 0, 0);
  SQL
    insert into opdays_grp (grpstate,op_day,state)
      select ga.type, @_op_day, $DAY_STATE_OPEN from abbrs ga where ga.type between $GRPSTATE_START and $GRPSTATE_END;


; -------------------------------------
; предыдущий день (нужен для входящих остатков)
; -------------------------------------
  $LONG(_prev_day)
  -SQL select max(op_day) into ?_prev_day from opdays where op_day < @_op_day;
  _prev_day = isnull(@@_prev_day) ? 0 : @@_prev_day;

; -------------------------------------
; актуальные счета для переноса остатков
; -------------------------------------
  -SQL drop table kaccnts;
  SQL
    create temp table kaccnts (
      c_accnt     int,
      c_curr      int,
      open_day    date,
      delete_day  date
    ) with no log;

  SQL
    insert into kaccnts (c_accnt, c_curr, open_day, delete_day)
      select ad.c_accnt, am.c_curr, ad.open_day, ad.delete_day
      from accnts_def ad
        join accnts_multi am on am.c_accnt=ad.c_accnt and am.open_day<=@_op_day and am.delete_day>=@_op_day
      where
        ad.open_day   <=  @_op_day and
        ad.delete_day >=  @_op_day;
  SQL create unique index idx_kaccnts_0 on kaccnts (c_accnt, c_curr);
  SQL create        index idx_kaccnts_1 on kaccnts (open_day, delete_day);
  SQL update statistics high for table kaccnts (c_accnt, c_curr, open_day, delete_day);


; -------------------------------------
; turnovers
; -------------------------------------
  call("$CURCFG::$CURSEC:_fill_turnovers_bal", "turnovers", "", @@_op_day, @@_prev_day);

; -------------------------------------
; rturnovers
; -------------------------------------
  call("$CURCFG::$CURSEC:_fill_turnovers_bal", "rturnovers", "where a.c_curr not in ($CURR_ROUBLE)", @@_op_day, @@_prev_day);

; -------------------------------------
; wturnovers
; -------------------------------------
  call("$CURCFG::$CURSEC:_fill_turnovers_wbal", "wturnovers", "", @@_op_day, @@_prev_day);


; -------------------------------------
; пробрасываем последние вылютные курсы
; -------------------------------------
  $LONG(_next_day,_curr_day)
  -SQL select min(op_day) into ?_next_day from opdays where op_day > @_op_day;
  _next_day = isnull(@@_next_day) ? (@@_op_day + 1) : @@_next_day;
  _curr_day = @@_prev_day + 1;

  -SQL drop table kprevrt;
  SQL
    create temp table kprevrt (
      kind    smallint,
      c_curr  int,
      nunits  int,
      rate    money(16,4)
    ) with no log;
  SQL
    insert into kprevrt(kind, c_curr, nunits, rate)
      select kind, c_curr, nunits, rate from curr_rate where op_day = @_prev_day;
  
  while("@@_curr_day < @@_next_day", ConfigGetString("$CURCFG::$CURSEC:_insert_curr_rates_one_day"));
#}

;> ----------------------------------------------------------------------------
;> __insert_curr_rates_one_day
;> ----------------------------------------------------------------------------
const char _insert_curr_rates_one_day=\
#{
  SQL
    insert into curr_rate (op_day, kind, c_curr, nunits, rate, delta_d, delta_c)
      select @_curr_day, kind, c_curr, nunits, rate, 0, 0
      from kprevrt;

  _curr_day = @@_curr_day + 1;
#}


;> ----------------------------------------------------------------------------
;> __fill_turnovers_bal
;> ----------------------------------------------------------------------------
const char _fill_turnovers_bal_parms=_tbl,_where,_op_day,_prev_day
const char _fill_turnovers_bal=\
#{
  SQL lock table @_tbl in share mode;

  -SQL drop table kbal;
  SQL
    select a.c_accnt, a.c_curr, nvl(t.debit2, 0) debit, nvl(t.credit2, 0) credit, t.last_op
    from kaccnts a
      left join @_tbl t on t.c_accnt = a.c_accnt and t.c_curr = a.c_curr and t.op_day = @_prev_day
    @_where
    into temp kbal with no log;

  SQL create unique index idx_kbal_0 on kbal (c_accnt, c_curr);
  SQL update statistics high for table kbal (c_accnt, c_curr);

  SQL
    insert into @_tbl (
                        op_day, c_accnt, c_curr,
                        debit1, credit1,
                        debit_to, credit_to,
                        debit2, credit2,
                        prev_op, last_op
                      )
    select @_op_day, a.c_accnt, a.c_curr,
           p.debit, p.credit, 
           0, 0, 
           p.debit, p.credit,
           p.last_op, p.last_op
    from kaccnts a
      join kbal p on p.c_accnt = a.c_accnt and p.c_curr = a.c_curr
    where
      @_op_day between a.open_day and a.delete_day;

;  SQL update @_tbl set (debit1, credit1, debit2, credit2)=(0, 0, 0, 0) where op_day between @_op_day and @_op_day and debit1 is null;

  SQL drop table kbal;
#}


;> ----------------------------------------------------------------------------
;> __fill_turnovers_wbal
;    (внебалансовые остатки - отдельно)
;> ----------------------------------------------------------------------------
const char _fill_turnovers_wbal_parms=_tbl,_where,_op_day,_prev_day
const char _fill_turnovers_wbal=\
#{
  SQL lock table @_tbl in share mode;

; -------------------------------------
; нулевые остатки. счета открытые позже
; -------------------------------------
  SQL
    insert into @_tbl (
                        op_day, c_accnt, c_curr,
                        rest1,
                        turnover_d,turnover_c,
                        rest2
                      )
    select @_op_day, c_accnt, c_curr,
           0, 0, 0, 0 
    from waccnts_multi
    where
      @_op_day between open_day and delete_day and
      open_day > @_prev_day;

; -------------------------------------
; входящие остатки для счетов, открытых ранее
; -------------------------------------
  -SQL drop table kprevtb;
  SQL
    select t.c_accnt, t.c_curr, t.rest2 as rest
    from waccnts_multi a
      join @_tbl t on t.c_accnt=a.c_accnt and t.c_curr=a.c_curr and t.op_day = @_prev_day
    where
      @_op_day between a.open_day and a.delete_day 
    into temp kprevtb with no log;
  SQL create unique index idx_kprevtb_0 on kprevtb (c_accnt, c_curr);
  SQL update statistics high for table kprevtb (c_accnt, c_curr);

  SQL
    insert into @_tbl (op_day, c_accnt, c_curr, rest1, turnover_d, turnover_c, rest2)
      select @_op_day, c_accnt, c_curr, rest, 0, 0, rest from kprevtb;
  SQL drop table kprevtb;
#}



;> ----------------------------------------------------------------------------
;> __update_turnovers
;> ----------------------------------------------------------------------------
const char _update_turnovers_parms=_c_accnt,_credit1
const char _update_turnovers=\
#{
#}

;> ----------------------------------------------------------------------------
;> __dublicate_schema_for_order_type
;> ----------------------------------------------------------------------------
const char _dublicate_schema_for_order_type_parms=\
#{
  _order_type_sourse:Тип-источник#Tlong_t
  _order_type_destination:Тип-назначеие#Tlong_t
#}

const char _dublicate_schema_for_order_type=\
#{
  $LONG(_today)
    _today = Otoday();

  $CHAR(_shname)
  $LONG(_number,_isum_type,_accnt_type_d,_accnt_type_c)

  _coll_insert  = Auth.obj_by_name("<null>", "DB_Coll");

  CURSOR
    select number, isum_type, accnt_type_d, accnt_type_c, shname into ?_number, ?_isum_type, ?_accnt_type_d, ?_accnt_type_c, ?_shname
    from $uk_ref_schema
    where
      order_type = @_order_type_sourse and
      @_today between prev_change and next_change
    : call("$CURCFG::$CURSEC:_create_schema_for_order_type", @@_order_type_destination, @@_number, @@_isum_type, @@_accnt_type_d, @@_accnt_type_c, @@_shname);

  Auth.delete_obj_by_name(@@_coll_insert);
#}


;> ----------------------------------------------------------------------------
;> __create_schema_for_order_type
;> ----------------------------------------------------------------------------
const char _create_schema_for_order_type_parms=_order_type,_number,_isum_type,_accnt_type_d,_accnt_type_c,_shname
const char _create_schema_for_order_type=\
#{
  @_coll_insert.ClearNames();
    @_coll_insert.AssignVarLong("order_type",   @@_order_type);
    @_coll_insert.AssignVarLong("number",       @@_number);
    @_coll_insert.AssignVarLong("isum_type",    @@_isum_type);
    @_coll_insert.AssignVarLong("accnt_type_d", @@_accnt_type_d);
    @_coll_insert.AssignVarLong("accnt_type_c", @@_accnt_type_c);
    @_coll_insert.AssignVarString("shname",     @@_shname);
  uk_main::UK_REF_Schema.DoInsertForColl(@@_coll_insert);
#}


;> ----------------------------------------------------------------------------
;> __get_branch_setting_accnt
;> ----------------------------------------------------------------------------
const char _get_branch_setting_accnt_parms=\
#{";"
  _accnt_type:Тип счета#Tlong_t
  _op_day:Дата#Tdate_t
  _coll_ext:Имя внешней коллекции#Tstring_t
#}
const char _get_branch_setting_accnt=\
#{
  $LONG(_c_accnt_setting)
    _c_accnt_setting = call("$CURCFG::$CURSEC:_get_setting_accnt", @@_accnt_type, long(@@_op_day));

  @_coll_ext.RenewVarsFromColl(CURRENT.get_name());
#}

;> ----------------------------------------------------------------------------
;> __get_setting_accnt
;> ----------------------------------------------------------------------------
const char _get_setting_accnt_parms=_accnt_type,_op_day
const char _get_setting_accnt=\
#{
  $LONG(_c_branch)
    StdEnv.GetVarLong("BranchSelect.c_branch", "_c_branch");

  $LONG(_c_accnt)
  -SQL
    select s.c_accnt into ?_c_accnt
    from $uk_ref_settings_accnts s
    where
      s.accnt_type = @_accnt_type and
      s.c_branch   = @_c_branch   and
      s.c_curr     = $CURR_ROUBLE and
      @_op_day between s.prev_change and s.next_change;
  _c_accnt = isnull(@@_c_accnt) ? 0 : @@_c_accnt;
  return(@@_c_accnt);
#}

;> ----------------------------------------------------------------------------
;> __get_rest2_for_setting_accnt
;> ----------------------------------------------------------------------------
const char _get_rest2_for_setting_accnt_parms=_accnt_type,_op_day,_fld_rest
const char _get_rest2_for_setting_accnt=\
#{
  $LONG(_c_accnt_setting)
  $MONEY(_rest2_setting_accnt)
    _c_accnt_setting      = call("$CURCFG::$CURSEC:_get_setting_accnt", @@_accnt_type, @@_op_day);
    _rest2_setting_accnt  = call("$CURCFG::$CURSEC:_get_rest2_for_accnt", @@_c_accnt_setting, $CURR_ROUBLE, @@_op_day, @@_fld_rest);

  return(@@_rest2_setting_accnt);
#}


;> ----------------------------------------------------------------------------
;> __get_rest2_for_accnt
;> ----------------------------------------------------------------------------
const char _get_rest2_for_accnt_parms=_c_accnt,_c_curr,_op_day,_fld_rest
const char _get_rest2_for_accnt=\
#{
  $MONEY(_rest2_accnt)
  -SQL
    select t.@{_fld_rest} into ?_rest2_accnt
    from turnovers t
    where
      t.c_accnt = @_c_accnt and
      t.c_curr  = @_c_curr and
      t.op_day  = @_op_day;
  _rest2_accnt = isnull(@@_rest2_accnt) ? 0 : @@_rest2_accnt;
  return(@@_rest2_accnt)
#}


;> ----------------------------------------------------------------------------
;> __employee_pay_ndfl
;> ----------------------------------------------------------------------------
const char _employee_pay_ndfl_parms=\
#{";"
  _op_day:Год#Tdate_t
#}
const char _employee_pay_ndfl=\
#{
; -------------------------------------
; проверка на существование распоряжения в текущем дне
; должно быть только одно в месяц
; -------------------------------------
  $LONG(__op_day,_count_of_order)
    __op_day        = long(@@_op_day);
    _count_of_order = call("uk_main::cmds_orders:_check_orders_on_unique", $ORDER_TYPE_EMPLOYEE_PAYMENT_TO_FNS, @@__op_day, @@__op_day, 0, 0, 0, 0, $_TRUE);


; -------------------------------------
; проверка на отсутсвие непроведенных распоряжений по работникам за сегодня
; -------------------------------------
  $LONG(_cnt_non_performed)
  SQL
    select count(*) into ?_cnt_non_performed
    from $uk_orders_def o
    where
      o.op_day between @__op_day and @__op_day and
      o.state not in ($ORDER_STATE_DELETED, $ORDER_STATE_PERFORMED) and
      o.order_type in (
                        $ORDER_TYPE_EMPLOYEE_SALARY_ADV,
                        $ORDER_TYPE_EMPLOYEE_SALARY_PRI,
                        $ORDER_TYPE_EMPLOYEE_VACATION_PAID,
                        $ORDER_TYPE_EMPLOYEE_VACATION_ACCEPT,
                        $ORDER_TYPE_EMPLOYEE_RESERV_INCREASE,
                        $ORDER_TYPE_EMPLOYEE_RESERV_DECREASE,
                        $ORDER_TYPE_EMPLOYEE_EXTRA_MONEY,
                        $ORDER_TYPE_EMPLOYEE_ILLNESS,
                        $ORDER_TYPE_EMPLOYEE_CHILD_PAYMENT
                      );

  (@@_cnt_non_performed == 0)
      ? 0
      : RaiseError(-1, "Обнаружены необработанные распоряжения  [@_cnt_non_performed шт.] по работникам!", "");

; -------------------------------------
; остатка на общих счетах 60335
; -------------------------------------
  $MONEY(_isum_ndfl)
  _isum_ndfl    = call("$CURCFG::$CURSEC:_get_rest2_for_setting_accnt", $ACCNTSETTING_TYPE_BRANCH_UK_SETTLE_NDFL, @@__op_day, "credit2");

; -------------------------------------
; 3. создаем распоряжение (при условии, что его еще не было)
; -------------------------------------
  _coll_insert  = Auth.obj_by_name("<null>", "DB_Coll");
    @_coll_insert.ClearNames();
    @_coll_insert.AssignVarLong("order_type",         $ORDER_TYPE_EMPLOYEE_PAYMENT_TO_FNS);
    @_coll_insert.AssignVarLong("c_curr",             $CURR_ROUBLE);
    @_coll_insert.AssignVarDate("op_day",             @@__op_day);
    @_coll_insert.SetVarMoney("ISum_LbrNDFL.isum", @@_isum_ndfl);
  uk_main::UK_Orders.DoInsertForColl(@@_coll_insert);

  $LONG(_c_order)
  uk_main::UK_Orders.GetKeyLong("c_order", "_c_order");
  Auth.delete_obj_by_name(@@_coll_insert);

; -------------------------------------  
  return(@@_c_order);
#}



;> ----------------------------------------------------------------------------
;> __employee_pay_monthly_ensurance
;> ----------------------------------------------------------------------------
const char _employee_pay_monthly_ensurance_parms=\
#{";"
  _year:Год#Tlong_t
  _month:Месяц#Tlong_t
#}
const char _employee_pay_monthly_ensurance=\
#{
  $LONG(_cfdom,_cldom,_ldom)
    _cfdom = rmdyjul(@@_month,  1, @@_year);
    _cldom = CldGetLimit(@@_cfdom, "cldom");
    _ldom  = CldGetLimit(@@_cfdom, "ldom");

; -------------------------------------
; проверка на существование распоряжения на закрытие общих счетов 60335 (перечисления в фонды)
; должно быть только одно в месяц
; -------------------------------------
  $LONG(_count_of_order)
    _count_of_order = call("uk_main::cmds_orders:_check_orders_on_unique", $ORDER_TYPE_EMPLOYEE_PAYMENT_TO_FUNDS, @@_cfdom, @@_cldom, 0, 0, 0, 0, $_FALSE);


; -------------------------------------
; проверка на отсутсвие непроведенных распоряжений по работникам в текущем месяце
; -------------------------------------
  $LONG(_cnt_non_performed)
  SQL
    select count(*) into ?_cnt_non_performed
    from $uk_orders_def o
    where
      o.op_day between @_cfdom and @_cldom and
      o.state not in ($ORDER_STATE_DELETED, $ORDER_STATE_PERFORMED) and
      o.order_type in (
                        $ORDER_TYPE_EMPLOYEE_SALARY_ADV,
                        $ORDER_TYPE_EMPLOYEE_SALARY_PRI,
                        $ORDER_TYPE_EMPLOYEE_VACATION_PAID,
                        $ORDER_TYPE_EMPLOYEE_VACATION_ACCEPT,
                        $ORDER_TYPE_EMPLOYEE_CHILD_PAYMENT,
                        $ORDER_TYPE_EMPLOYEE_PAYMENT_TO_FNS
                      );

  (@@_cnt_non_performed == 0)
      ? 0
      : RaiseError(-1, "Обнаружены необработанные распоряжения  [@_cnt_non_performed шт.] по работникам!", "");

; -------------------------------------
; остатка на общих счетах 60335
; -------------------------------------
  $MONEY(_isum_ndfl,_isum_pfr,_isum_fss,_isum_fss_acc,_isum_oms,_overpay_fss)
  _isum_ndfl    = call("$CURCFG::$CURSEC:_get_rest2_for_setting_accnt", $ACCNTSETTING_TYPE_BRANCH_UK_SETTLE_NDFL, @@_ldom, "credit2");
  _isum_pfr     = call("$CURCFG::$CURSEC:_get_rest2_for_setting_accnt", $ACCNTSETTING_TYPE_CONS_60335_PFR,        @@_ldom, "credit2");
  _isum_fss     = call("$CURCFG::$CURSEC:_get_rest2_for_setting_accnt", $ACCNTSETTING_TYPE_CONS_60335_FSS,        @@_ldom, "credit2");
  _isum_fss_acc = call("$CURCFG::$CURSEC:_get_rest2_for_setting_accnt", $ACCNTSETTING_TYPE_CONS_60335_FSS_ACC,    @@_ldom, "credit2");
  _isum_oms     = call("$CURCFG::$CURSEC:_get_rest2_for_setting_accnt", $ACCNTSETTING_TYPE_CONS_60335_OMS,        @@_ldom, "credit2");
  _overpay_fss  = call("$CURCFG::$CURSEC:_get_rest2_for_setting_accnt", $ACCNTSETTING_TYPE_CONS_60335_FSS,        @@_ldom, "debit2" );

; -------------------------------------
; 3. создаем распоряжение (при условии, что его еще не было)
; -------------------------------------
  _coll_insert  = Auth.obj_by_name("<null>", "DB_Coll");
    @_coll_insert.ClearNames();
    @_coll_insert.AssignVarLong("order_type",                               $ORDER_TYPE_EMPLOYEE_PAYMENT_TO_FUNDS);
    @_coll_insert.AssignVarLong("c_curr",                                   $CURR_ROUBLE);
    @_coll_insert.AssignVarDate("op_day",                                   @@_ldom);
    
    @_coll_insert.SetVarMoney("ISum_LbrNDFL.isum",                 @@_isum_ndfl    );
    @_coll_insert.SetVarMoney("ISum_LbrIns_PFR.isum",        @@_isum_pfr     );
    @_coll_insert.SetVarMoney("ISum_LbrIns_FSS.isum",        @@_isum_fss     );
    @_coll_insert.SetVarMoney("ISum_LbrIns_FSS_ACC.isum",    @@_isum_fss_acc );
    @_coll_insert.SetVarMoney("ISum_LbrIns_OMS.isum",        @@_isum_oms     );
    @_coll_insert.SetVarMoney("ISum_LbrOverpay_FSS.isum",          @@_overpay_fss  );

  (@@_count_of_order == 0)
      ? uk_main::UK_Orders.DoInsertForColl(@@_coll_insert)
      : 0;

  Auth.delete_obj_by_name(@@_coll_insert);

; -------------------------------------  
  _coll_60335  = Auth.obj_by_name("<null>", "DB_Coll");

  $LONG(_c_employee)

  CURSOR
    select e.c_employee into ?_c_employee
    from $uk_employees_def e
    : call("$CURCFG::$CURSEC:_create_order_with_checking_60335", @@_c_employee, @@_cfdom, @@_ldom);

  Auth.delete_obj_by_name(@@_coll_60335);

  $LONG(_c_order)
  uk_main::UK_Orders.GetKeyLong("c_order", "_c_order");

  return(@@_c_order);
#}

;> ----------------------------------------------------------------------------
;> __create_order_with_checking_60335
;    проверка счетов 60335 по работнику и в случае дебетового остатка создание распоряжения на коррекцию
;> ----------------------------------------------------------------------------
const char _create_order_with_checking_60335_parms=_c_employee,_date0,_date1
const char _create_order_with_checking_60335=\
#{
  $CHAR(_postfix)
  $MONEY(_isum_itogo,_debit2)
    _isum_itogo = 0;
    _debit2     = 0;

  @_coll_60335.ClearNames();
    @_coll_60335.AssignVarLong("c_employee", @@_c_employee);
    @_coll_60335.AssignVarLong("order_type", $ORDER_TYPE_EMPLOYEE_CHECK_60335);
    @_coll_60335.AssignVarLong("c_curr",     $CURR_ROUBLE);
    @_coll_60335.AssignVarDate("op_day",     @@_date1);

; -------------------------------------
; проверяем счета страховых взносов (60335)
; -------------------------------------
  CURSOR
    select trim(a.abbr[30, 50]), t.debit2 into ?_postfix, ?_debit2
    from $uk_ref_abbrs a
      join $uk_employees_accnts e on
                                      e.accnt_type = a.type and
                                      e.c_employee = @_c_employee and
                                      @_date1 between e.prev_change and e.next_change
      join turnovers t            on
                                      t.c_accnt = e.c_accnt and
                                      t.c_curr  = $CURR_ROUBLE and
                                      t.op_day  = @_date1
    where
      a.abbr matches "ACCNTEMPLOYEE_TYPE_INSURANCE_*"
    : call("$CURCFG::$CURSEC:_add_isum_field_to_coll", "ISum_LbrIns_", @@_postfix, @@_debit2);


; -------------------------------------
; проверяем счет 60305
; -------------------------------------
  -SQL
    select t.debit2 into ?_debit2
    from $uk_employees_accnts e
      join turnovers t            on
                                      t.c_accnt = e.c_accnt and
                                      t.c_curr  = $CURR_ROUBLE and
                                      t.op_day  = @_date1
    where
      e.accnt_type = $ACCNTEMPLOYEE_TYPE_SALARY and
      e.c_employee = @_c_employee and
      @_date1 between e.prev_change and e.next_change;
  _debit2 = isnull(@@_debit2) ? 0 : @@_debit2;
  call("$CURCFG::$CURSEC:_add_isum_field_to_coll", "ISum_LbrPaymentGROSS", "", @@_debit2);
    
  (@@_isum_itogo == 0)
      ? return(0)
      : 0;

  $LONG(_count_of_employee_order)
    _count_of_employee_order = call("uk_main::cmds_orders:_check_orders_on_unique", $ORDER_TYPE_EMPLOYEE_PAYMENT_TO_FUNDS, @_cfdom, @_cldom, 0, @_c_employee, 0, 0, $_FALSE);

    (@@_count_of_employee_order == 0)
      ? uk_main::UK_Orders.DoInsertForColl(@@_coll_60335)
      : 0
#}

;> ----------------------------------------------------------------------------
;> __add_isum_field_to_coll
;    проверка счетов 60335 по работнику и в случае дебетового остатка создание распоряжения на коррекцию
;> ----------------------------------------------------------------------------
const char _add_isum_field_to_coll_parms=_prefix,_postfix,_debit2
const char _add_isum_field_to_coll=\
#{
  (@@_debit2 == 0)
      ? return(0)
      : 0;

  _isum_itogo = @@_isum_itogo + @@_debit2;

  @_coll_60335.SetVarMoney("@{_prefix}@{_postfix}.isum", @@_debit2);
#}

;> ----------------------------------------------------------------------------
;> __get_c_naccnt_by_naccnt
;    получение id БС
;> ----------------------------------------------------------------------------
const char _get_c_naccnt_by_naccnt_parms=\
#{";"
  _naccnt:БС#Tlong_t
  _coll_ext:Имя внешней коллекции#Tstring_t
#}
const char _get_c_naccnt_by_naccnt=\
#{
  $LONG(_c_naccnt)
  -SQL select c_naccnt into ?_c_naccnt from npl_accnt2 where naccnt = @_naccnt;
  _c_naccnt = isnull(@@_c_naccnt) ? 0 : @@_c_naccnt;

  @_coll_ext.RenewVarsFromColl(CURRENT.get_name());
  return(@@_c_naccnt)
#}

;> ----------------------------------------------------------------------------
;> __get_last_nsubacc
;    получение последнего 
;    для использования в Delphi
;> ----------------------------------------------------------------------------
const char _get_last_nsubacc_parms=\
#{";"
  _c_branch:Проект#Tlong_t
  _c_naccnt:БС#Tlong_t
  _c_nsymbf2_f5:Доходы_Расходы#Tlong_t
  _nukind:Вид ОС#Tlong_t
  _ndep:Тип аммортизации#Tlong_t
  _coll_ext:Имя внешней коллекции#Tstring_t
#}
const char _get_last_nsubacc=\
#{
  $LONG(_last_nsubacc)
    _c_branch     = isnull(@@_c_branch)     ? 0 : @@_c_branch;
    _c_naccnt     = isnull(@@_c_naccnt)     ? 0 : @@_c_naccnt;
    _c_nsymbf2_f5 = isnull(@@_c_nsymbf2_f5) ? 0 : @@_c_nsymbf2_f5;
    _nukind       = isnull(@@_nukind)       ? 0 : @@_nukind;
    _ndep         = isnull(@@_ndep)         ? 0 : @@_ndep;

  -SQL
    select max(nsubacc) into ?_last_nsubacc
    from accnts_def
    where
      c_branch     = @_c_branch and
      c_naccnt     = @_c_naccnt and
      c_nsymbf2_f5 = @_c_nsymbf2_f5 and
      nukind       = @_nukind and
      ndep         = @_ndep;
  _last_nsubacc = isnull(@@_last_nsubacc) ? 1 : (@@_last_nsubacc + 1);

  @_coll_ext.RenewVarsFromColl(CURRENT.get_name());
  return(@@_last_nsubacc);
#}

;> ----------------------------------------------------------------------------
;> __check_user_right
;> ----------------------------------------------------------------------------
const char _check_user_right=return(0)

;> ----------------------------------------------------------------------------
;> __set_current_corr
;> ----------------------------------------------------------------------------
const char _set_current_corr_parms=_c_corr
const char _set_current_corr=\
#{
  Corr.SetKeyLong("c_corr", @@_c_corr);
  Corr.DoSpc($spcUserCode1, "<null>");
#}

;> ----------------------------------------------------------------------------
;> __set_current_branch
;> ----------------------------------------------------------------------------
const char _set_current_branch_parms=_c_branch,_coll_ext
const char _set_current_branch=\
#{
  BranchSelect.SetKeyLong("c_branch", @@_c_branch);
  BranchSelect.DoSpc($spcUserCode1, "<null>");
  BranchSelect.DoSelectForColl(@@_coll_ext);
#}

;> ----------------------------------------------------------------------------
;> __set_accnt_rest0
;    входящие остатки на дату начала работы программы (30.12.2016) либо в 31.12.2017 (технический день)
;> ----------------------------------------------------------------------------
const char _set_accnt_rest0_parms=_c_accnt,_c_curr,_rest0,_rest0_rur
const char _set_accnt_rest0=\
#{
  $LONG(_op_day) _op_day = Otoday();
  ((@@_op_day != $DATE_START) && (@@_op_day != $DATE_YEAR_2017)) && (@@_rest0 > 0)
      ? RaiseError(-1, "Входящий остаток возможно задать только в 30.12.2016 или 31.12.2017! Смените опер. день!", "")
      : 0;

  (@@_rest0 > 0) && (@@_rest0 == @@_rest0_rur) && (@@_c_curr != $CURR_ROUBLE)
      ? RaiseError(-1, "Неправильная сумма остатка в рублевом пересчете для валютного счета!", "")
      : 0;

; -------------------------------------
  $SHORT(_state)
  SQL select o.state into ?_state from opdays o where o.op_day = @_op_day;
  (@@_state != $DAY_STATE_OPEN)
      ? RaiseError(-1, "Опер. день должен быть в состоянии открыт!", "")
      : 0;

; -------------------------------------
  $MONEY(_turn_below)
  -SQL
    select sum(t.debit_to) + sum(t.credit_to) into ?_turn_below
    from turnovers t
    where
      t.c_accnt = @_c_accnt and
      t.c_curr  = @_c_curr;

  _turn_below = isnull(@@_turn_below) ? 0 : @@_turn_below;
  (@@_turn_below == 0)
      ? 0
      : RaiseError(-1, "Операция запрещена, т.к. счету уже были обороты!", "");

; -------------------------------------
  $CHAR(_fld_rest) _fld_rest = (@@_rest0 > 0) ? "debit" : "credit";

; -------------------------------------
; заново инициируем все остатки
; -------------------------------------
  SQL update turnovers  set (debit1, credit1, debit2, credit2) = (0, 0, 0, 0) where c_accnt = @_c_accnt and c_curr = @_c_curr;
  SQL update rturnovers set (debit1, credit1, debit2, credit2) = (0, 0, 0, 0) where c_accnt = @_c_accnt and c_curr = @_c_curr;

; -------------------------------------
; обновляем новыми значениями
; -------------------------------------
  SQL update turnovers  set (@{_fld_rest}1, @{_fld_rest}2) = (abs(@_rest0),     abs(@_rest0))     where c_accnt = @_c_accnt and c_curr = @_c_curr;
  SQL update rturnovers set (@{_fld_rest}1, @{_fld_rest}2) = (abs(@_rest0_rur), abs(@_rest0_rur)) where c_accnt = @_c_accnt and c_curr = @_c_curr;
#}

;> ----------------------------------------------------------------------------
;> __insert_new_accnt
;    процедура для создания счета (для оптимизации кода вывел всё в одно место)
;> ----------------------------------------------------------------------------
const char _insert_new_accnt_parms=_c_curr,_c_branch,_c_naccnt,_c_nsymbf2_f5,_ndep,_nukind,_nsubacc,_access,_name,_oaccnt,_necurracc,_comment,_rest0,_rest0_rur,_accnt_obj,_coll_ext
const char _insert_new_accnt=\
#{
  $LONG(_c_accnt)


; -------------------------------------
; 0)
;     если субсчет  не пришел         - вычисляем его
;     если рублевый остаток не пришел - вычисляем его
; -------------------------------------
  _nsubacc   = (@@_nsubacc == 0)            
                    ? call("$CURCFG::$CURSEC:_get_last_nsubacc", @@_c_branch, @@_c_naccnt, @@_c_nsymbf2_f5, @@_nukind, @@_ndep, @@_coll_ext)
                    : @@_nsubacc;
  _rest0_rur = (@@_c_curr  == $CURR_ROUBLE)
                    ? @@_rest0
                    : @@_rest0_rur;

; -------------------------------------
; отладка
; -------------------------------------
;  "_c_branch = @_c_branch";
;  "_c_naccnt = @_c_naccnt";
;  "_c_nsymbf2_f5 = @_c_nsymbf2_f5";
;  "_ndep = @_ndep";
;  "_nukind = @_nukind";
;  "_nsubacc = @_nsubacc";
;  "_access = @_access";
;  "_name = @_name";


; -------------------------------------
; 1) вставляем счет
; -------------------------------------
  _coll_accnt_insert  = Auth.obj_by_name("<null>", "DB_Coll");
    @_coll_accnt_insert.ClearNames();

    @_coll_accnt_insert.AssignVarLong("c_branch",                 @@_c_branch);
    @_coll_accnt_insert.AssignVarLong("c_naccnt",                 @@_c_naccnt);
    @_coll_accnt_insert.AssignVarLong("c_nsymbf2_f5",             @@_c_nsymbf2_f5);
    @_coll_accnt_insert.AssignVarShort("ndep",                    @@_ndep);
    @_coll_accnt_insert.AssignVarShort("nukind",                  @@_nukind);
    @_coll_accnt_insert.AssignVarLong("nsubacc",                  @@_nsubacc);
    @_coll_accnt_insert.AssignVarLong("access",                   @@_access);
    @_coll_accnt_insert.AssignVarString("AccntName.name",         @@_name);


  @_accnt_obj.DoInsertForColl(@@_coll_accnt_insert);
  @_accnt_obj.GetKeyLong( "c_accnt", "_c_accnt");

; -------------------------------------
; 2) добавляем валюту
; -------------------------------------
  @_coll_accnt_insert.ClearNames();
    @_coll_accnt_insert.AssignVarLong("c_accnt",                   @@_c_accnt);
    @_coll_accnt_insert.AssignVarLong("c_curr",                    @@_c_curr);
    @_coll_accnt_insert.AssignVarString("AccntCurr_OPL.oaccnt",    @@_oaccnt);
    @_coll_accnt_insert.AssignVarString("AccntCurr_OPL.necurracc", @@_necurracc);
    @_coll_accnt_insert.AssignVarString("AccntCurr_OPL.comment",   @@_comment);
    @_coll_accnt_insert.SetVarMoney("AccntCurr_OPL.rest0",         @@_rest0);
    @_coll_accnt_insert.SetVarMoney("AccntCurr_OPL.rest0_rur",     @@_rest0_rur);
  AccntCurr.DoInsertForColl(@@_coll_accnt_insert);

; -------------------------------------
; 3) инициируем входящие остатки (если дата соответствующая)
; -------------------------------------
  call("$CURCFG::$CURSEC:_set_accnt_rest0", @@_c_accnt, @@_c_curr, @@_rest0, @@_rest0_rur);

; -------------------------------------
  Auth.delete_obj_by_name(@@_coll_accnt_insert);

  return(@@_c_accnt);
#}


;> ----------------------------------------------------------------------------
;> __insert_accnt
;> ----------------------------------------------------------------------------
const char _insert_accnt_parms=\
#{";"
  c_curr:Валюта#Tlong_t
  c_branch:Проект#Tlong_t
  c_naccnt:БС#Tlong_t
  c_nsymbf2_f5:Доходы_Расходы#Tlong_t
  nukind:Вид ОС#Tlong_t
  ndep:Тип аммортизации#Tlong_t
  nsubacc:Субсчет#Tlong_t
  access:Уровень доступа#Tlong_t
  name:Наименование#Tstring_t
  oaccnt:Старый БС#Tstring_t
  necurracc:Старый счет#Tstring_t
  comment:Наименование#Tstring_t
  rest0:Вх. остаток#Tmoney_t
  rest0_rur:Вх. остаток (RUR)#Tmoney_t
  _accnt_obj:Имя объекта для создания счета#Tstring_t
  _coll_ext:Имя внешней коллекции#Tstring_t
#}
const char _insert_accnt=\
#{
  $LONG(_c_accnt)
  _c_accnt = call("$CURCFG::$CURSEC:_insert_new_accnt", @@c_curr, @@c_branch, @@c_naccnt, @@c_nsymbf2_f5, @@ndep, @@nukind, @@nsubacc,
                                                        @@access, @@name, @@oaccnt, @@necurracc, @@comment, @@rest0, @@rest0_rur, @@_accnt_obj, @@_coll_ext);
  @_coll_ext.RenewVarsFromColl(CURRENT.get_name());
#}


;> ----------------------------------------------------------------------------
;> __update_accnt
;> ----------------------------------------------------------------------------
const char _update_accnt_parms=\
#{";"
  c_accnt:Счет#Tlong_t
  c_curr:Валюта#Tlong_t
  access:Уровень доступа#Tlong_t
  name:Наименование#Tstring_t
  oaccnt:Старый БС#Tstring_t
  necurracc:Старый счет#Tstring_t
  comment:Наименование#Tstring_t
  rest0:Вх. остаток#Tmoney_t
  rest0_rur:Вх. остаток (RUR)#Tmoney_t
#}
const char _update_accnt=\
#{
  _coll_accnt_update=Auth.obj_by_name("<null>", "DB_Coll");

; -------------------------------------
; AccntsDef
; -------------------------------------
    @_coll_accnt_update.ClearNames();
    @_coll_accnt_update.AssignVarLong("access",                    @@access);
    @_coll_accnt_update.AssignVarString("AccntName.name",          @@name);

  Accnt.SetKeyLong("c_accnt", @@c_accnt);
  Accnt.DoUpdateForColl(@@_coll_accnt_update);

; -------------------------------------
; AccntsMulti
; -------------------------------------
  rest0_rur = (@@c_curr  == $CURR_ROUBLE)
                    ? @@rest0
                    : @@rest0_rur;

    @_coll_accnt_update.ClearNames();
    @_coll_accnt_update.AssignVarString("AccntCurr_OPL.oaccnt",    @@oaccnt);
    @_coll_accnt_update.AssignVarString("AccntCurr_OPL.necurracc", @@necurracc);
    @_coll_accnt_update.AssignVarString("AccntCurr_OPL.comment",   @@comment);
  AccntCurr.SetKeyLong("c_accnt", @@c_accnt);
  AccntCurr.SetKeyLong("c_curr",  @@c_curr);
  AccntCurr.DoUpdateForColl(@@_coll_accnt_update);

  Auth.delete_obj_by_name(@@_coll_accnt_update);

; -------------------------------------
; 3) меняем входящие остатки (если дата соответствующая)
; -------------------------------------
  $LONG(_op_day) _op_day = Otoday();
  ((@@_op_day != $DATE_START) && (@@_op_day != $DATE_YEAR_2017))
      ? return(0)
      : 0;

  call("$CURCFG::$CURSEC:_set_accnt_rest0", @@c_accnt, @@c_curr, @@rest0, @@rest0_rur);


  _coll_accnt_update=Auth.obj_by_name("<null>", "DB_Coll");
    @_coll_accnt_update.ClearNames();
    @_coll_accnt_update.SetVarMoney("AccntCurr_OPL.rest0",         @@rest0);
    @_coll_accnt_update.SetVarMoney("AccntCurr_OPL.rest0_rur",     @@rest0_rur);
  AccntCurr.SetKeyLong("c_accnt", @@c_accnt);
  AccntCurr.SetKeyLong("c_curr",  @@c_curr);
  AccntCurr.DoUpdateForColl(@@_coll_accnt_update);

  Auth.delete_obj_by_name(@@_coll_accnt_update);
#}


;> ----------------------------------------------------------------------------
;> __refresh_accnt_on_contractor
;> ----------------------------------------------------------------------------
const char _refresh_accnt_on_contractor_parms=_c_accnt,_c_contractor,_naccnt_type
const char _refresh_accnt_on_contractor=\
#{
  (@@_c_contractor == 0) ? return(0) : 0;

  $LONG(_accnt_type)
  _accnt_type = (@@_naccnt_type == $ACCNT_TYPE_ACTIVE) ? $ACCNTCONTRACTOR_TYPE_ACTIVE : $ACCNTCONTRACTOR_TYPE_PASSIVE;

  SQL delete from $uk_contractors_accnts where c_contractor = @_c_contractor and accnt_type = @_accnt_type;

  _coll_contractor_accnt_insert  = Auth.obj_by_name("<null>", "DB_Coll");
    @_coll_contractor_accnt_insert.ClearNames();

    @_coll_contractor_accnt_insert.AssignVarLong("c_contractor", @@_c_contractor);
    @_coll_contractor_accnt_insert.AssignVarLong("c_accnt",      @@_c_accnt);
    @_coll_contractor_accnt_insert.AssignVarLong("accnt_type",   @@_accnt_type);

  uk_main::UK_Contractors_Accnts.DoInsertForColl(@@_coll_contractor_accnt_insert);
  Auth.delete_obj_by_name(@@_coll_contractor_accnt_insert);
#}

const char _refresh_accnt_on_contractor_ERR = -Auth.delete_obj_by_name(@@_coll_contractor_accnt_insert);


;> ----------------------------------------------------------------------------
;> __move_uni_doc
;> ----------------------------------------------------------------------------
const char _move_uni_doc_parms=_c_doc,_day_move
const char _move_uni_doc=\
#{
  _coll_uni_doc_move = Auth.obj_by_name("<null>", "DB_Coll");
    @_coll_uni_doc_move.ClearNames();
    @_coll_uni_doc_move.AssignVarLong("new_date", @@_day_move);

  KsConf.SetKeyLong("c_doc", @@_c_doc);
  KsConf.DoSpc($spcDocMove, @@_coll_uni_doc_move);
  
  Auth.delete_obj_by_name(@@_coll_uni_doc_move);
#}
const char _move_uni_doc_ERR = -Auth.delete_obj_by_name(@@_coll_uni_doc_move);


[]

[cmds_tmp]

; -----------------------------------------------------------------------------
; создание таблицы с оперднями для вычисления среднего остатка за период с date1 по date2
; (!первичным является поле rest_day!)
; in
;   _tmp_table_name - имя временной таблицы для создания
;   _date1           - первый календарный день периода
;   _date2           - последний календарный день периода
const char createTempOpdays_parms=_tmp_table_name,_date1,_date2
const char createTempOpdays=\
#{
  -SQL DROP TABLE @_tmp_table_name;
  SQL
    CREATE TEMP TABLE @_tmp_table_name (
      op_day date,
      rest_day date,
      isum money default 0,
      isum_rde money default 0,
      isum_vde money default 0,
      coef int default 1
    ) WITH NO LOG;

  SQL CREATE UNIQUE INDEX idx_@{_tmp_table_name}_0 ON @_tmp_table_name (rest_day);
  SQL CREATE UNIQUE INDEX idx_@{_tmp_table_name}_1 ON @_tmp_table_name (op_day);

; -----------------
; все рабочие дни + предыдущие с начала периода до даты отчета
  SQL INSERT INTO @_tmp_table_name (op_day, rest_day)
        SELECT o.op_day, max(op.op_day)
        FROM opdays o
          JOIN opdays op ON op.op_day < o.op_day
        WHERE o.op_day >= @_date1
        GROUP BY o.op_day
        HAVING MAX(op.op_day)<=@_date2;

  SQL UPDATE STATISTICS HIGH FOR TABLE @_tmp_table_name (op_day, rest_day);

; -----------------
; поле coef - множитель для "протаскивания" остатков на следующие за рабочим днем выходные
  SQL UPDATE @_tmp_table_name SET coef = min2(op_day, @_date2+1)-max2(rest_day, @_date1);
#}


[]
